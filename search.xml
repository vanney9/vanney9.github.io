<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[OC关联对象及其内存管理]]></title>
      <url>/2017/07/14/association-object-and-retain-count/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OC的关联对象经常被用来存储Category中的属性对应的实例变量，当然它还有其他的用途。</p>
<p>这篇文章将讨论关联对象是如何实现的，以及关联对象的内存管理问题。</p>
<a id="more"></a>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>先用一段代码来引入要讲的东西：</p>
<pre><code class="objective-c">#import &quot;HCBase.h&quot;

@interface HCBase (vanney)

@property (nonatomic, assign) int cui;
@property (nonatomic, strong) NSString *van;

@end

/* -----------------  这里是分割线  -------------- */

#import &quot;HCBase+vanney.h&quot;

@implementation HCBase (vanney)

- (void)setCui:(int)cui {
    objc_setAssociatedObject(self, &quot;cui&quot;, @(cui), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (int)cui {
    return [objc_getAssociatedObject(self, &quot;cui&quot;) intValue];
}

- (void)setVan:(NSString *)van {
    objc_setAssociatedObject(self, &quot;van&quot;, van, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

- (NSString *)van {
    return objc_getAssociatedObject(self, &quot;van&quot;);
}

@end
</code></pre>
<p>可以看到：</p>
<ol>
<li>在头文件中，我们定义了两个属性 <strong>cui</strong> 和 <strong>van</strong></li>
<li>在.m文件中，我们使用了关联对象来存储这两个实例变量</li>
<li>使用关联对象时，我们还指定了它的内存管理的方式 <strong>OBJC_ASSOCIATION_RETAIN_NONATOMIC</strong> 和 <strong>OBJC_ASSOCIATION_COPY_NONATOMIC</strong></li>
</ol>
<h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><p>关联对象的实现是开源的，在runtime的<code>objc-references.m</code>源文件中。在OC中，使用一个全局的表来存储所有的关联对象，如下图所示：</p>
<p><img src="/lionheart/1706/association.png" alt="association"></p>
<p>关于这张图的解释可以参考我的这篇文章<a href="http://vanney9.com/2017/06/07/objective-c-runtime-category/" target="_blank" rel="external">Objective-C runtime - 分类与关联对象</a></p>
<p>上面的Demo使用了下面两个函数来存取关联对象，我们来看看他们的源码</p>
<ol>
<li><strong>objc_setAssociatedObject</strong></li>
<li><strong>objc_getAssociatedObject</strong></li>
</ol>
<h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>这个方法用来设置关联对象：</p>
<pre><code class="objective-c">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // 关联对象使用 ObjcAssociation 这个c++对象来存储。
      // 设置新对象，那么有可能有老的对象会被废弃。那么新建一个ObjcAssociation对象，之后用来存储老的对象
    ObjcAssociation old_association(0, nil);

      // acquireValue函数： 设置新的对象的retainCount，也就是对他进行手动内存管理
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

          // 如果确实是要设置新关联对象的时候
        if (new_value) {
            // break any existing association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);

              // 这个对象之前设置过关联对象，也就是说该对象的关联对象数量大于1
            if (i != associations.end()) {
                // secondary table exists
                ObjectAssociationMap *refs = i-&gt;second;
                ObjectAssociationMap::iterator j = refs-&gt;find(key);

                  // 寻找全局的关联对象表，如果存在老对象的话
                if (j != refs-&gt;end()) {
                      // 存储老对象到之前新建的ObjcAssociation对象中
                    old_association = j-&gt;second;
                      // 设置新的关联对象
                    j-&gt;second = ObjcAssociation(policy, new_value);
                }
                  // 不存在老对象，直接设置新关联对象
                  else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            }

              // 这个对象之前没有设置过任何的关联对象
              else {
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);

                  // 将对象的isa的has_assoc字段设置成true
                object-&gt;setHasAssociatedObjects();
            }
        } 
          // 要将关联对象设成 nil，也就是取消该关联对象。先存老对象，再在全局表中删除该关联对象
          else {
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i-&gt;second;
                ObjectAssociationMap::iterator j = refs-&gt;find(key);
                if (j != refs-&gt;end()) {
                    old_association = j-&gt;second;
                    refs-&gt;erase(j);
                }
            }
        }
    }


    // 释放老对象，retainCount相关，内存管理相关
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>
<p> 可以看到设置新的关联对象其实很简单：</p>
<ol>
<li>现在全局关联对象表中寻找这个key</li>
<li>先存原来关联对象</li>
<li>再设置新的关联对象</li>
<li>释放原有的关联对象</li>
</ol>
<h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>获取关联对象就更简单了，直接到表中去找对应的key的对象就好了。</p>
<h2 id="关联对象的内存管理"><a href="#关联对象的内存管理" class="headerlink" title="关联对象的内存管理"></a>关联对象的内存管理</h2><p>在上面讲到的源代码中，涉及到管理对象内存管理的有两个函数</p>
<ol>
<li><strong>acquireValue</strong></li>
<li><strong>ReleaseValue</strong></li>
</ol>
<h3 id="requireValue"><a href="#requireValue" class="headerlink" title="requireValue"></a>requireValue</h3><pre><code class="objective-c">static id acquireValue(id value, uintptr_t policy) {
    switch (policy &amp; 0xFF) {
    case OBJC_ASSOCIATION_SETTER_RETAIN:
        return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
    case OBJC_ASSOCIATION_SETTER_COPY:
        return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);
    }
    return value;
}
</code></pre>
<p>可以看到，设置关联对象的内存管理方式和你手动传进来的policy有关。</p>
<p>将policy和0XFF相与：</p>
<ol>
<li>结果是<strong>OBJC_ASSOCIATION_SETTER_RETAIN</strong>的话，就调用对象的retain函数，也就是将retainCount加一</li>
<li>结果是<strong>OBJC_ASSOCIATION_SETTER_COPY</strong>的话，就调用对象的copy函数，也就是将拷贝对象，并给新对象的retainCount赋1</li>
</ol>
<p><strong>PS</strong> :</p>
<ol>
<li>没有找到具体的SEL_copy的实现。</li>
<li>至于retain的实现，其实就是将对象的isa的extra_rc字段加1 具体可以参考这篇博客<a href="http://www.jianshu.com/p/18c3e88dfbf1" target="_blank" rel="external">OC源码 —— retain和release</a></li>
</ol>
<h3 id="各种常量"><a href="#各种常量" class="headerlink" title="各种常量"></a>各种常量</h3><p>在我们自己调用存取关联对象的时候使用了<code>objc_AssociationPolicy</code>常量：</p>
<pre><code class="objective-c">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
</code></pre>
<p>根据名字很容易想到所对应的内存管理语义。</p>
<p>在<code>objc-references.mm</code>中使用的是另外的常量：</p>
<pre><code class="objective-c">enum { 
    OBJC_ASSOCIATION_SETTER_ASSIGN      = 0,
    OBJC_ASSOCIATION_SETTER_RETAIN      = 1,
    OBJC_ASSOCIATION_SETTER_COPY        = 3,            // NOTE:  both bits are set, so we can simply test 1 bit in releaseValue below.
    OBJC_ASSOCIATION_GETTER_READ        = (0 &lt;&lt; 8), 
    OBJC_ASSOCIATION_GETTER_RETAIN      = (1 &lt;&lt; 8), 
    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (2 &lt;&lt; 8)
};
</code></pre>
<p>可以看到这两个enum中，前三个是相对应的，他们有相同的值</p>
<h3 id="ReleaseValue"><a href="#ReleaseValue" class="headerlink" title="ReleaseValue"></a>ReleaseValue</h3><pre><code class="objective-c">static void releaseValue(id value, uintptr_t policy) {
    if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) {
        ((id(*)(id, SEL))objc_msgSend)(value, SEL_release);
    }
}

struct ReleaseValue {
    void operator() (ObjcAssociation &amp;association) {
        releaseValue(association.value(), association.policy());
    }
};
</code></pre>
<p>再来看看如何释放对象。可以看到，他是将关联对象的<code>policy</code>和<code>OBJC_ASSOCIATION_SETTER_RETAIN</code>相与，简单计算就会发现：<strong>当policy为retain和copy时，这个if判断都是正确的，也就会对相应关联对象执行release操作。和我们预想的是一致的。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://vanney9.com/2017/06/07/objective-c-runtime-category/" target="_blank" rel="external">Objective-C runtime - 分类与关联对象</a></li>
<li><a href="http://www.jianshu.com/p/de95ff8230bd" target="_blank" rel="external">Runtime源码 —— Associated Object</a></li>
<li><a href="http://www.jianshu.com/p/18c3e88dfbf1" target="_blank" rel="external">OC源码 —— retain和release</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ARC下关于autorelease的一些疑问]]></title>
      <url>/2017/07/13/question-about-autorelease/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a>这篇博客的时候，发现了一些问题。主要问题在于：</p>
<pre><code class="objective-c">// ARC 情况下
@autoreleasepool {
  id __strong array = [NSMutableArray array];
  NSLog(@&quot;array count is %lu&quot;, _objc_rootRetainCount(array));
  _objc_autoreleasePoolPrint();
}
</code></pre>
<p><strong>这里的array对象的retainCount到底是1还是2？</strong></p>
<p>按照查找的博客，以及之前看的《Objective-C高级编程 iOS与OS X多线程和内存管理》这本书的结论：这里的retainCount应该是1，因为这个对象没有注册到autoreleasepool中。但是实际运行下来却并非如此。</p>
<p><a href="https://stackoverflow.com/questions/45075336/ios-arc-objc-rootretaincount" target="_blank" rel="external">Stack Overflow</a></p>
<a id="more"></a>
<h2 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h2><h3 id="AutoreleasePool-自动释放池"><a href="#AutoreleasePool-自动释放池" class="headerlink" title="AutoreleasePool 自动释放池"></a>AutoreleasePool 自动释放池</h3><p>Autorelease就是延迟release的调用时间，将需要延迟release的对象加入autoreleasepool。当pool倾倒时，就开始调用pool中的对象的release方法。每一个线程对应一个自动释放池。</p>
<p>在ARC中，使用<code>@autoreleasepool{}</code>来表示一个自动释放池。将OC代码通过clang的<code>-rewrite-objc</code>，可以生成C++代码。可以看到自动释放池是一个<code>__AtAutoreleasePool</code>C++对象。然后这个对象只是对<code>AutoreleasePoolPage</code>对象的封装，可以在<code>NSObject.mm</code>文件中找到它的详细定义。</p>
<p>下面这两篇博客对自动释放池有详细的解释：</p>
<ol>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://www.jianshu.com/p/ca7835b41699" target="_blank" rel="external">OC源码 —— autoreleasepool</a></li>
</ol>
<h3 id="Autorelease返回值的快速释放机制"><a href="#Autorelease返回值的快速释放机制" class="headerlink" title="Autorelease返回值的快速释放机制"></a>Autorelease返回值的快速释放机制</h3><pre><code class="objective-c">// ARC下
id array = [NSMutableArray array];

+ (NSMutableArray *)array {
  return [[NSMutableArray alloc] init];
}
</code></pre>
<p>因为<code>array</code>类方法是不持有对象的，那么正常情况下调用该方法时，该方法会将返回对象先注册到自动释放池；但是由于ARC下面存在这么一个机制，可以不将对象注册到自动释放池，直接给array持有。</p>
<p>这个机制主要由这两个函数构成：</p>
<ol>
<li><code>objc_autoreleaseReturnValue(id);</code></li>
<li><code>objc_retainAutoreleasedReturnValue(id);</code></li>
</ol>
<p>不过通过我的测试，发现这个说法有点说不通啊。来看看实际的情况</p>
<h2 id="实地测试"><a href="#实地测试" class="headerlink" title="实地测试"></a>实地测试</h2><p><strong>测试的时候需要两个关键的函数：</strong></p>
<ol>
<li><code>uintptr_t _objc_rootRetainCount(id obj);</code> : 返回对象的retainCount</li>
<li><code>void _objc_autoreleasePoolPrint();</code> ：打印此时的自动释放池的内容</li>
</ol>
<h3 id="MacOS-Command-Line-Tools"><a href="#MacOS-Command-Line-Tools" class="headerlink" title="MacOS Command Line Tools"></a>MacOS Command Line Tools</h3><p>新建一个MacOS Command Line Tools的项目，总共只有下面这些代码：</p>
<pre><code class="objective-c">#import &lt;Foundation/Foundation.h&gt;

extern uintptr_t _objc_rootRetainCount(id obj);
extern void _objc_autoreleasePoolPrint();

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        id array = [NSMutableArray array];
        NSLog(@&quot;array count is %lu&quot;, _objc_rootRetainCount(array));
        _objc_autoreleasePoolPrint();
    }

    return 0;
}
</code></pre>
<p>来看看输出结果：</p>
<pre><code>2017-07-13 20:21:52.419722 autoreleaseMac[87916:6040616] array count is 2
objc[87916]: ##############
objc[87916]: AUTORELEASE POOLS for thread 0x10012c3c0
objc[87916]: 2 releases pending.
objc[87916]: [0x102001000]  ................  PAGE  (hot) (cold)
objc[87916]: [0x102001038]  ################  POOL 0x102001038
objc[87916]: [0x102001040]       0x1004032b0  __NSArrayM
objc[87916]: ##############
Program ended with exit code: 0
</code></pre><p>可以发现：使用<code>array</code>类函数生成的对象不仅被array给强引用，还被注入到了自动释放池；所以他的retainCount为2。<strong>这就说明了在Mac下面，貌似这个Autorelease返回值的快速释放机制不起作用</strong></p>
<h3 id="iOS-APP"><a href="#iOS-APP" class="headerlink" title="iOS APP"></a>iOS APP</h3><p>新建一个iOS的项目，来看看iOS的<code>viewDidLoad</code>方法：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];

    // id __weak ref = nil;   先暂时注释掉这一行

    id array = [NSMutableArray array];
      NSLog(@&quot;%p&quot;, array);
    NSLog(@&quot;array count is %lu&quot;, _objc_rootRetainCount(array));
    _objc_autoreleasePoolPrint();
}
</code></pre>
<p>来看看打印结果：</p>
<pre><code class="objective-c">2017-07-13 20:31:29.637 autorelease[89067:6068334] array count is 1
objc[89067]: ##############
objc[89067]: AUTORELEASE POOLS for thread 0x112c2b3c0
objc[89067]: 888 releases pending.
...
// 并没有发现array对象加入了自动释放池
</code></pre>
<p>在iOS下面这个array对象的retainCount位1，也没有加入到自动释放池。<strong>这么看貌似这个快速释放机制起作用了</strong></p>
<p>先别急：让我们取消注释，声明一个__weak变量，再来看看运行结果：</p>
<pre><code class="objective-c">2017-07-13 20:35:39.510 autorelease[89587:6080048] 0x6080000468a0  // 对象地址
2017-07-13 20:35:39.510 autorelease[89587:6080048] array count is 2
objc[89587]: ##############
objc[89587]: AUTORELEASE POOLS for thread 0x1110ce3c0
objc[89587]: 889 releases pending.
...
objc[89587]: [0x7ff4b281ec20]    0x7ff4b4005f80  ViewController
objc[89587]: [0x7ff4b281ec28]    0x7ff4b4005f80  ViewController
objc[89587]: [0x7ff4b281ec30]    0x6080000468a0  __NSArrayM   // 加入到自动释放池中的对象地址，和上面的相同
objc[89587]: ##############
</code></pre>
<p>可以看到retainCount变成了2，而且也确实是将array对象加入到了自动释放池中。<strong>这时候这个快速释放机制貌似又失效了。。</strong></p>
<p><strong>这里的一个完全无关的__weak变量的声明，似乎是这个快速释放机制的开关；有点玄学=。=</strong></p>
<h2 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h2><h3 id="clang-S"><a href="#clang-S" class="headerlink" title="clang -S"></a>clang -S</h3><p>可以通过clang的<code>-S</code>选项，来看看这些文件生成的汇编代码，或许可以从中看出些端倪。但是我不懂汇编=.=</p>
<h3 id="LinkMap"><a href="#LinkMap" class="headerlink" title="LinkMap"></a>LinkMap</h3><p>开启Xcode的Write Link Map File选项，查看可执行文件的构成。</p>
<p>当没有定义__weak变量时：</p>
<p><img src="/lionheart/1707/without.png" alt="without"></p>
<p>当有定义__weak变量时：</p>
<p><img src="/lionheart/1707/with.png" alt="with"></p>
<p>可以看到在定义了__weak变量时，多了两个函数的调用：</p>
<ol>
<li>__Unwind_Resume</li>
<li>_objc_destroyWeak</li>
</ol>
<p>所以感觉问题就在这两个函数之中</p>
<h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>我将该问题放在了<a href="https://stackoverflow.com/questions/45075336/ios-arc-objc-rootretaincount" target="_blank" rel="external">Stack Overflow</a>上面了。如果哪位大神碰巧看到了这篇文章，并且还耐心的看到了这里，碰巧还知道答案的话，可以到StackOverflow上面帮我解解惑</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.cnbang.net/tech/2296/" target="_blank" rel="external">iOS APP可执行文件的组成</a></li>
<li><a href="https://reverseengineering.stackexchange.com/questions/8163/in-a-mach-o-executable-how-can-i-find-which-function-a-stub-targets" target="_blank" rel="external">In a Mach-O executable, how can I find which function a stub targets?</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JSPatch源码分析]]></title>
      <url>/2017/07/07/JSPatch-source-analyze/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch</a>是一个可以动态更新iOS APP的开源库。通过JSPatch，可以使用JS书写原生代码，动态更新APP，替换项目原生代码修复Bug。</p>
<p>JSPatch充分应用了Objective-C的runtime，来实现自己的功能。</p>
<p>这篇文章将结合Demo，来分析JSPatch的主要的实现过程。包括：</p>
<ol>
<li>使用JS新建类</li>
<li>使用JS替换原有方法</li>
<li>使用JS添加全新方法</li>
<li>OC调用JS定义的方法</li>
<li>JS调用OC定义的方法</li>
</ol>
<a id="more"></a>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>使用官方提供的<a href="https://github.com/bang590/JSPatch/tree/master/Demo/iOSDemo" target="_blank" rel="external">Demo</a>。先来看看Demo的关键代码：</p>
<h4 id="JPViewController"><a href="#JPViewController" class="headerlink" title="JPViewController"></a>JPViewController</h4><pre><code class="objective-c">@implementation JPViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 50)];
    [btn setTitle:@&quot;Push JPTableViewController&quot; forState:UIControlStateNormal];
    [btn addTarget:self action:@selector(handleBtn:) forControlEvents:UIControlEventTouchUpInside];
    [btn setBackgroundColor:[UIColor grayColor]];
    [self.view addSubview:btn];
}

- (void)handleBtn:(id)sender
{
}

@end
</code></pre>
<p>这个JPViewController创建了一个button，并给该button赋予了一个点击事件。<strong>但是该点击事件<code>- (void)handleBtn:(id)sender;</code>没做任何事情</strong></p>
<h4 id="demo-js"><a href="#demo-js" class="headerlink" title="demo.js"></a>demo.js</h4><pre><code class="javascript">/* 给JPViewController重新定义 handleBtn: 方法 */
defineClass(&#39;JPViewController&#39;, {
  handleBtn: function(sender) {
    var tableViewCtrl = JPTableViewController.alloc().init()
    self.navigationController().pushViewController_animated(tableViewCtrl, YES)
  }
})

// 定义了一个新的类型 JPTableViewController
defineClass(&#39;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&#39;, [&#39;data&#39;], {
  dataSource: function() {
    var data = self.data();
    if (data) return data;
    var data = [];
    for (var i = 0; i &lt; 20; i ++) {
      data.push(&quot;cell from js &quot; + i);
    }
    self.setData(data)
    return data;
  },
  numberOfSectionsInTableView: function(tableView) {
    return 1;
  },
  tableView_numberOfRowsInSection: function(tableView, section) {
    return self.dataSource().length;
  },
  tableView_cellForRowAtIndexPath: function(tableView, indexPath) {
    var cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) 
    if (!cell) {
      cell = require(&#39;UITableViewCell&#39;).alloc().initWithStyle_reuseIdentifier(0, &quot;cell&quot;)
    }
    cell.textLabel().setText(self.dataSource()[indexPath.row()])
    return cell
  },
  tableView_heightForRowAtIndexPath: function(tableView, indexPath) {
    return 60
  },
  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
     var alertView = require(&#39;UIAlertView&#39;).alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;Alert&quot;,self.dataSource()[indexPath.row()], self, &quot;OK&quot;,  null);
     alertView.show()
  },
  alertView_willDismissWithButtonIndex: function(alertView, idx) {
    console.log(&#39;click btn &#39; + alertView.buttonTitleAtIndex(idx).toJS())
  }
})
</code></pre>
<p>该JS是Demo的唯一一个JS。它做了两件事：</p>
<ol>
<li>重新定义<code>JPViewController</code>的<code>handleBtn:</code>方法；现在点击该button的话，会新建一个tableView</li>
<li>定义一个新的类型 <code>JPTableViewController</code>；这个新的类型负责创建相关的tableView</li>
</ol>
<h4 id="JPEngine-m-和-JSPatch-js"><a href="#JPEngine-m-和-JSPatch-js" class="headerlink" title="JPEngine.m 和 JSPatch.js"></a>JPEngine.m 和 JSPatch.js</h4><p> 这是JSPatch库的最核心的两个文件。</p>
<p><strong>该Demo创建了一个button，点击button之后，会调用JS里面的方法：该JS方法会创建一个tableView，并给每个cell设置一个click事件</strong></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="使用JS创建Objective-C的类"><a href="#使用JS创建Objective-C的类" class="headerlink" title="使用JS创建Objective-C的类"></a>使用JS创建Objective-C的类</h3><p>在<code>demo.js</code>中使用了 <code>defineClass</code> 方法来创建新的Objective-C类。这个方法定义在<code>JSPatch.js</code>中。现在来看看它的实现：(<strong>只显示了核心代码</strong>)</p>
<pre><code class="javascript">global.defineClass = function(declaration, properties, instMethods, clsMethods) {
    var newInstMethods = {}, newClsMethods = {}

    // 获得类名，忽略冒号之后的superClass以及protocol //
    var realClsName = declaration.split(&#39;:&#39;)[0].trim()

    // JS &lt;=&gt; OC 的一些格式化 暂时不管，这一步之后将会产生
    _formatDefineMethods(instMethods, newInstMethods, realClsName)
    _formatDefineMethods(clsMethods, newClsMethods, realClsName)

    // 核心代码： 在_OC_defineClass中调用OC的方法，创建新的Objective-C类，并添加或者替代方法
    var ret = _OC_defineClass(declaration, newInstMethods, newClsMethods)

    /* 此处省略800字 */
    return require(className)
}
</code></pre>
<p>使用iOS7引入的<strong>JavaScriptCore框架</strong> ，可以实现在JS中调用OC的方法（具体参考<a href="http://nshipster.cn/javascriptcore/" target="_blank" rel="external">JavaScriptCore</a>）。<code>defineClass</code>方法中，调用<code>_OC_defineClass</code>方法来创建新的类，以及替换原有方法或者生成新的方法。</p>
<p>来看看定义在<code>JPEngine.m</code>文件中的这个方法：</p>
<pre><code class="objective-c">+ (void)startEngine {
  context[@&quot;_OC_defineClass&quot;] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) {
    return defineClass(classDeclaration, instanceMethods, classMethods);
  };
}
</code></pre>
<p>这里的<code>context</code> 变量是<strong>JSContext</strong>变量，也就是JS的执行环境；在该执行环境里面定义了一个<code>_OC_defineClass</code> Block。那么JS就可以调用该<code>_OC_defineClass</code>方法，并执行Block，也就是执行OC代码。</p>
<p>来看看Block里面的<code>defineClass</code>这一个C方法</p>
<pre><code class="objective-c">static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)
{
      // 这里的classDeclaration类似这种格式 ： ClassName : NSObject &lt;protocolName&gt;
    NSScanner *scanner = [NSScanner scannerWithString:classDeclaration];

    NSString *className;
    NSString *superClassName;
    NSString *protocolNames;

      /* 此处省略800字 解析生成className  superClassName 和 protocolName*/

    Class cls = NSClassFromString(className);

    // 如果OC中不存在这个类 则新建class
    if (!cls) {
        Class superCls = NSClassFromString(superClassName);
        cls = objc_allocateClassPair(superCls, className.UTF8String, 0);
        objc_registerClassPair(cls);
    }

    // 给该类添加协议
    if (protocols.count &gt; 0) {
        for (NSString* protocolName in protocols) {
            Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]);
            class_addProtocol (cls, protocol);
        }
    }

      /* 此处省略800字 */
}
</code></pre>
<p><strong>总结： 可以看到，在JS中创建的类名会被传入OC。OC会判断该类名对应的类是否存在；如果不存在，就会使用runtime方法来动态创建这个类</strong></p>
<h3 id="使用JS替换原有方法"><a href="#使用JS替换原有方法" class="headerlink" title="使用JS替换原有方法"></a>使用JS替换原有方法</h3><p>再来看一下<code>demo.js</code></p>
<pre><code class="javascript">defineClass(&#39;JPViewController&#39;, {
  handleBtn: function(sender) {
    var tableViewCtrl = JPTableViewController.alloc().init()
    self.navigationController().pushViewController_animated(tableViewCtrl, YES)
  }
})
</code></pre>
<p>这里使用JS定义了<code>JPViewController</code>类的<code>handleBtn:</code>方法；执行完<code>defineClass</code>这个JS方法之后，这里的实现会替换原来的<code>handleBtn:</code>的实现。</p>
<p>先来说一下<strong>方法替换</strong>的具体流程：</p>
<ol>
<li>创建一个<code>ORIGhandleBtn:</code>  selector，指向<code>handleBtn:</code>的IMP</li>
<li>创建一个<code>ORIGforwardInvocation:</code> selector，指向<code>JPViewController</code> 的 <code>forwardInvocation:</code> 的IMP</li>
<li>将<code>handleBtn:</code> selector 指向 <code>_objc_msgForward</code> ；也就是说执行<code>handleBtn:</code>这个方法的时候，不会去查找它的实现，会直接进行消息转发(关于消息转发，可以看我的这篇文章 <a href="http://vanney9.com/2017/06/08/objective-c-runtime-message/" target="_blank" rel="external">Objective-C runtime - 消息</a>)</li>
<li>在OC的全局变量 <code>_JSOverideMethods</code> 中保存这个方法的实现，也就是保存JS中定义的这个方法</li>
<li>将<code>forwardInvocation:</code> 这个selector指向 <code>JPForwardInvocation</code>的实现；<strong><code>JPForwardInvocation</code>又是JSPatch里面的一个核心方法</strong>。在这个方法里面会寻找JS定义的<code>handleBtn</code>，并调用该方法</li>
</ol>
<p>来看看代码</p>
<pre><code class="objective-c">static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)
{
    /* 此处省略800字 */

      // i == 0 添加实例方法； i == 1 添加类方法
    for (int i = 0; i &lt; 2; i ++) {
        BOOL isInstance = i == 0;
        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;

        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String);

          // 获取方法列表，for循环逐个给类添加方法
        NSDictionary *methodDict = [jsMethods toDictionary];
        for (NSString *jsMethodName in methodDict.allKeys) {
            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];
            int numberOfArg = [jsMethodArr[0] toInt32];
            NSString *selectorName = convertJPSelectorString(jsMethodName);
            if ([selectorName componentsSeparatedByString:@&quot;:&quot;].count - 1 &lt; numberOfArg) {
                selectorName = [selectorName stringByAppendingString:@&quot;:&quot;];
            }

            JSValue *jsMethod = jsMethodArr[1];
            if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) {
                // 已经有对应的方法了，替换方法
                overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL);
            } else {
                // 新增方法
               /* 先省略800字 后文再说 */
            }
        }
    }

      // 添加统一的setter/getter函数
    class_addMethod(cls, @selector(getProp:), (IMP)getPropIMP, &quot;@@:@&quot;);
    class_addMethod(cls, @selector(setProp:forKey:), (IMP)setPropIMP, &quot;v@:@@&quot;);

    return @{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName};
}
</code></pre>
<p>看来替换方法的核心还在<code>overrideMethod</code> 里面，来看看这个方法</p>
<pre><code class="objective-c">static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)
{
      // 获取方法名对应的selector
    SEL selector = NSSelectorFromString(selectorName);

    // 获取method的typeDescription:也就是获取方法的typeEncoding
    if (!typeDescription) {
        Method method = class_getInstanceMethod(cls, selector);
        typeDescription = (char *)method_getTypeEncoding(method);
    }

      // 获取方法的最初的实现
    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : NULL;

      // 获取_objc_msgForward的实现
    IMP msgForwardIMP = _objc_msgForward;

    // 保留forwardInvocation:的原有实现，并将它指向JPForwardInvocation这个新的实现上面
    if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) != (IMP)JPForwardInvocation) {
        IMP originalForwardImp = class_replaceMethod(cls, @selector(forwardInvocation:), (IMP)JPForwardInvocation, &quot;v@:@&quot;);
        if (originalForwardImp) {
            class_addMethod(cls, @selector(ORIGforwardInvocation:), originalForwardImp, &quot;v@:@&quot;);
        }
    }

    // 保留将要替换的方法：使用ORIGselectorName这一个selector指向原有的实现
    if (class_respondsToSelector(cls, selector)) {
        NSString *originalSelectorName = [NSString stringWithFormat:@&quot;ORIG%@&quot;, selectorName];
        SEL originalSelector = NSSelectorFromString(originalSelectorName);
        if(!class_respondsToSelector(cls, originalSelector)) {
            class_addMethod(cls, originalSelector, originalImp, typeDescription);
        }
    }

      // 将JS定义的实现保存到OC的全局变量中
    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];
    _initJPOverideMethods(cls);
    _JSOverideMethods[cls][JPSelectorName] = function;

       // 将要替换的方法，指向_objc_msgForward这一函数，直接进行消息转发
    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);
}
</code></pre>
<h3 id="使用JS创建新的方法"><a href="#使用JS创建新的方法" class="headerlink" title="使用JS创建新的方法"></a>使用JS创建新的方法</h3><p>还是先来看看<code>demo.js</code></p>
<pre><code class="javascript">defineClass(&#39;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&#39;, [&#39;data&#39;], {
  dataSource: function() {
    var data = self.data();
    if (data) return data;
    var data = [];
    for (var i = 0; i &lt; 20; i ++) {
      data.push(&quot;cell from js &quot; + i);
    }
    self.setData(data)
    return data;
  },
  numberOfSectionsInTableView: function(tableView) {
    return 1;
  },
  tableView_numberOfRowsInSection: function(tableView, section) {
    return self.dataSource().length;
  },
  tableView_cellForRowAtIndexPath: function(tableView, indexPath) {
    var cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) 
    if (!cell) {
      cell = require(&#39;UITableViewCell&#39;).alloc().initWithStyle_reuseIdentifier(0, &quot;cell&quot;)
    }
    cell.textLabel().setText(self.dataSource()[indexPath.row()])
    return cell
  },
  tableView_heightForRowAtIndexPath: function(tableView, indexPath) {
    return 60
  },
  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
     var alertView = require(&#39;UIAlertView&#39;).alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;Alert&quot;,self.dataSource()[indexPath.row()], self, &quot;OK&quot;,  null);
     alertView.show()
  },
  alertView_willDismissWithButtonIndex: function(alertView, idx) {
    console.log(&#39;click btn &#39; + alertView.buttonTitleAtIndex(idx).toJS())
  }
})
</code></pre>
<p>在这个JS方法里面，不仅定义了一个新的OC类<code>JPTableViewController</code>，并给他添加了多个方法。来看看具体实现：</p>
<pre><code class="objective-c">static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)
{
    /* 上文提过，省略 */

      // i == 0 添加实例方法； i == 1 添加类方法
    for (int i = 0; i &lt; 2; i ++) {
        BOOL isInstance = i == 0;
        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;

        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String);
        NSDictionary *methodDict = [jsMethods toDictionary];
        for (NSString *jsMethodName in methodDict.allKeys) {
            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];
            int numberOfArg = [jsMethodArr[0] toInt32];
            NSString *selectorName = convertJPSelectorString(jsMethodName);
            if ([selectorName componentsSeparatedByString:@&quot;:&quot;].count - 1 &lt; numberOfArg) {
                selectorName = [selectorName stringByAppendingString:@&quot;:&quot;];
            }

            JSValue *jsMethod = jsMethodArr[1];
            if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) {
                overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL);
            } else {
                /* 开始新增方法 */
                BOOL overrided = NO;

                // 先添加protocol的方法
                for (NSString *protocolName in protocols) {
                      // 通过protocol获取方法的typeEncoding
                    char *types = methodTypesInProtocol(protocolName, selectorName, isInstance, YES);
                    if (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, NO);
                    if (types) {
                          // 还是使用 overrideMethod 方法来创建新的方法。走的是消息转发的那一套
                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, types);
                        free(types);
                        overrided = YES;
                        break;
                    }
                }

                // 不是protocol方法，新增类的方法
                if (!overrided) {
                    if (![[jsMethodName substringToIndex:1] isEqualToString:@&quot;_&quot;]) {
                        NSMutableString *typeDescStr = [@&quot;@@:&quot; mutableCopy];
                        for (int i = 0; i &lt; numberOfArg; i ++) {
                            [typeDescStr appendString:@&quot;@&quot;];
                        }
                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:NSUTF8StringEncoding]);
                    }
                }
            }
        }
    }

      /* 省略无关代码 */

    return @{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName};
}
</code></pre>
<p><strong>可以看到：新增方法其实和替换方法是一个原理，走的都是消息转发那一套；但是新增方法没有必要保留原有方法的实现，因为本来就不存在原有的方法</strong></p>
<h3 id="OC调用JS定义的方法"><a href="#OC调用JS定义的方法" class="headerlink" title="OC调用JS定义的方法"></a>OC调用JS定义的方法</h3><p>现在JS已经定义好了需要的类，以及需要的方法了。那么何时来调用这些方法，以及如何调用呢？</p>
<p>回顾一下<code>JPViewController.m</code></p>
<pre><code class="objective-c">#import &quot;JPViewController.h&quot;

@implementation JPViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 50)];
    [btn setTitle:@&quot;Push JPTableViewController&quot; forState:UIControlStateNormal];
    [btn addTarget:self action:@selector(handleBtn:) forControlEvents:UIControlEventTouchUpInside];
    [btn setBackgroundColor:[UIColor grayColor]];
    [self.view addSubview:btn];
}

- (void)handleBtn:(id)sender
{
}

@end
</code></pre>
<p>这个文件很简单：创建一个button，给button添加一个执行方法<code>handleBtn:</code> 。那么当运行APP，并点击这一button的时候；会去调用<code>handleBtn:</code>方法。但是由上面的分析可知：<code>handleBtn:</code>方法已经指向<code>_objc_msgForward</code>，也就是说会对这一方法直接进行转发，调用<code>forwardInvocation:</code>方法。下面来看看这个<code>JPForwardInvocation</code>方法：</p>
<pre><code class="objective-c">static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)
{
      // 根据Invocation，来获取方法的参数信息等等
    BOOL deallocFlag = NO;
    id slf = assignSlf;
    NSMethodSignature *methodSignature = [invocation methodSignature];
    NSInteger numberOfArguments = [methodSignature numberOfArguments];
    NSString *selectorName = NSStringFromSelector(invocation.selector);
    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];

      // 从全局JS方法列表中获取当前的JS方法
    JSValue *jsFunc = getJSFunctionInObjectHierachy(slf, JPSelectorName);

    // JS 没有定义该方法 那么就走原始的转发方法
    if (!jsFunc) {
        JPExecuteORIGForwardInvocation(slf, selector, invocation);
        return;
    }

    NSMutableArray *argList = [[NSMutableArray alloc] init];
    /* 省略800字 */

    // 从Invocation中根据method的 type Encoding 来获取参数列表，并将其添置argList数组中
    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];

        // 根据type Encoding来添加相应的参数。r代表const
        switch(argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {
            /* 此处省略不只800字。。 具体实现看源码 */

          // for example
          case &#39;@&#39;:
              // 这个参数是一个OC对象，所以需要往argList中添加对象
              id arg;
              [invocation getArgument:&amp;arg atIndex:i];
              [argList addObject:arg];
              break;
          case &#39;:&#39;:
              // 添加selector对应的NSString
        }
    }

    /* 此处省略800字 */

      // 参数列表，将OC对象转化成JS可以使用的对象
    NSArray *params = _formatOCToJSList(argList);

      // 保存返回值的类型
    char returnType[255];
    strcpy(returnType, [methodSignature methodReturnType]);

      // 根据返回类型来调用JS函数
    switch (returnType[0] == &#39;r&#39; ? returnType[1] : returnType[0]) {
        /* 此处省略不只800字  这一块是该函数的核心代码  下面只说主要过程 */

          // jsval用来存储JS调用的返回值
          JSValue *jsval;

           // JS调用时单线程，需要加锁
        [_JSMethodForwardCallLock lock];

          // !!!  核心代码出现啦  OC调用JS定义的方法  !!!  */
        jsval = [jsFunc callWithArguments:params];
        [_JSMethodForwardCallLock unlock];

          // 检查JS方法的返回值，看是否需要执行回调函数
        while (![jsval isNull] &amp;&amp; ![jsval isUndefined] &amp;&amp; [jsval hasProperty:@&quot;__isPerformInOC&quot;]) {
            NSArray *args = nil;
            JSValue *cb = jsval[@&quot;cb&quot;];
            if ([jsval hasProperty:@&quot;sel&quot;]) {
                id callRet = callSelector(![jsval[@&quot;clsName&quot;] isUndefined] ? [jsval[@&quot;clsName&quot;] toString] : nil, [jsval[@&quot;sel&quot;] toString], jsval[@&quot;args&quot;], ![jsval[@&quot;obj&quot;] isUndefined] ? jsval[@&quot;obj&quot;] : nil, NO);
                args = @[[_context[@&quot;_formatOCToJS&quot;] callWithArguments:callRet ? @[callRet] : _formatOCToJSList(@[_nilObj])]];
            }
            [_JSMethodForwardCallLock lock];
              //  执行回调函数，该回调函数也是在JS中定义的
            jsval = [cb callWithArguments:args];
            [_JSMethodForwardCallLock unlock];
        }

          // 设置消息转发的调用结果，也就是设置 invocation 的 returnValue
          [invocation setReturnValue:&amp;jsval];
    }

    /* 此处省略800字 和对象释放相关的 */
}
</code></pre>
<p>了解了这个消息转发的过程之后，就会知道OC调用JS定义的方法是在<code>JSForwardInvocation</code>中。它回去查找定义在OC里面的存储JS方法的全局变量，找到该JS方法，并执行。</p>
<h3 id="JS调用OC的方法"><a href="#JS调用OC的方法" class="headerlink" title="JS调用OC的方法"></a>JS调用OC的方法</h3><p>回顾一下<code>demo.js</code>的代码：</p>
<pre><code class="javascript">defineClass(&#39;JPViewController&#39;, {
  handleBtn: function(sender) {
    var tableViewCtrl = JPTableViewController.alloc().init()
    self.navigationController().pushViewController_animated(tableViewCtrl, YES)
  }
})
</code></pre>
<p>当OC调用<code>handleBtn:</code>方法时，实际上执行的是这个JS定义的方法。在这个JS方法里面会创建一个<code>JPTableViewController</code>对象，并将该对象显示出来。来看看JS如何调用OC的代码：</p>
<pre><code class="javascript">__c: function(methodName) {
  /* 省略一系列迷人的JS操作 */

  return function(){
    var args = Array.prototype.slice.call(arguments)
    // 获取调用方法的类名，调用方法的对象，调用的方法的参数，并且执行这个 _methodFunc 方法
    return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper)
  }
},
</code></pre>
<p>在JS里面调用OC方法：如 <code>UIView.alloc().init()</code> 都会被转化成这种格式 <code>UIView.__c(&#39;alloc&#39;)().__c(&#39;init&#39;)()</code>。也就是调用上述的<code>__c</code>方法。</p>
<p>而<code>__c()</code>方法也就是获取调用该方法的类名，对象；以及该方法的参数。并将这些全部传给<code>_methodFunc()</code>方法。所以说<code>__c()</code>方法有点像OC的<code>objc_megSend(id self, selector, ...)</code>，它只是一个转发器。</p>
<p>真正调用OC的JS方法是这个<code>_methodFunc</code>（定义在<code>JSPatch.js</code>中）：</p>
<pre><code class="javascript">var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) {
  // 做一些准备活动：将JS方法名转成相应的OC方法名(驼峰命名)
  var selectorName = methodName
  if (!isPerformSelector) {
    methodName = methodName.replace(/__/g, &quot;-&quot;)
    selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;)
    var marchArr = selectorName.match(/:/g)
    var numOfArgs = marchArr ? marchArr.length : 0
    if (args.length &gt; numOfArgs) {
      selectorName += &quot;:&quot;
    }
  }

  // 使用_OC_callI / _OC_callC 来调用OC的方法。传递给这两方法的参数是对象，参数，selector等等
  var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):
  _OC_callC(clsName, selectorName, args)
  return _formatOCToJS(ret)
}
</code></pre>
<p>我们以<code>_OC_callI</code>为例 （定义在<code>JPEngine.m</code>中）：</p>
<pre><code class="objective-c">context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) {
    return callSelector(nil, selectorName, arguments, obj, isSuper);
};
</code></pre>
<p>在OC中，这个方法接收obj，selectorName，arguments等参数；实际调用的<code>callSelector</code>方法：</p>
<pre><code class="objective-c">static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)
{
      /* 省略800字 做一些前期准备：获取类，selector，格式化参数列表等等 */

       /* 再省略800字 设置Invocation的target 这个调用还是以消息转发的形式来的 */
      [invocation setTarget:instance];

      // 和OC调用JS一样，set Invocation的调用参数
      // 注意：在OC调用JS中，这里是 get Invocation的参数
    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {
        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];
        id valObj = argumentsObj[i-2];
        switch (argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {
              // 代码省略了
             [invocation setArgument:&amp;value atIndex:i];       
        }
    }

      // 执行OC代码，也就是设置好这一个invocation之后，invoke它
      [invocation invoke];

    char returnType[255];
    strcpy(returnType, [methodSignature methodReturnType]);

      // 使用returnValue来存储Invocation返回值
    id returnValue;
    [invocation getReturnValue:&amp;result];

    // 根据返回值类型来创建returnValue，并返回。 for example
      returnValue = (__bridge id)result;
      return returnValue;
}
</code></pre>
<p>这样就实现了OC代码的调用。</p>
<h2 id="JSPatch核心方法"><a href="#JSPatch核心方法" class="headerlink" title="JSPatch核心方法"></a>JSPatch核心方法</h2><h3 id="JPEngine-m"><a href="#JPEngine-m" class="headerlink" title="JPEngine.m"></a>JPEngine.m</h3><ol>
<li>defineClass</li>
<li>overrideMethod</li>
<li>JPForwardInvocation</li>
<li>callSelector</li>
</ol>
<h3 id="JSPatch-js"><a href="#JSPatch-js" class="headerlink" title="JSPatch.js"></a>JSPatch.js</h3><ol>
<li>__c()</li>
<li>_methodFunc()</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JSPatch充分应用了 <strong>runtime</strong> 和 <strong>JavaScriptCore</strong> 两大技术，实现了OC和JS的通信。</p>
<p>对于OC调用JS，和JS调用OC 都是使用的消息转发的机制；这两种调用是一个相反的过程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3" target="_blank" rel="external">JSPatch 实现原理详解</a></li>
<li><a href="http://nshipster.cn/javascriptcore/" target="_blank" rel="external">JavaScriptCore</a></li>
<li><a href="http://vanney9.com/2017/06/08/objective-c-runtime-message/" target="_blank" rel="external">Objective-C runtime - 消息</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关于ARC，Block以及GCD，runloop]]></title>
      <url>/2017/06/27/iOS-ARC-Block-GCD-Runloop/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近又看了一遍 <strong>Objective-C高级编程 iOS与OS X多线程和内存管理</strong> 这本书。对一些问题有了一些新的认识。这篇文章将讲讲下面几个话题：</p>
<ol>
<li><strong>ARC，MRC 与 引用计数</strong></li>
<li><strong>Block的实现</strong></li>
<li><strong>GCD与runloop</strong></li>
</ol>
<a id="more"></a>
<h2 id="ARC-MRC-与-引用计数"><a href="#ARC-MRC-与-引用计数" class="headerlink" title="ARC, MRC 与 引用计数"></a>ARC, MRC 与 引用计数</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Objective C的生成的数据会存放在栈或者堆上面。对于存放在栈上面的数据（比如局部int变量等）在不需要时，系统会自动释放内存空间；对于存放在堆上面的数据（比如对象等）会使用引用计数来决定是否释放内存空间。</p>
<p>创建一个对象时，会malloc一块对象所需大小的内存空间；当有一变量持有该对象时（一般是有一指针指向该内存时）该对象的引用计数加一；当持有该对象的变量不再持有它时（一般是指针被销毁，或指向其他地方）该对象的引用计数减一。<strong>当对象的引用计数为0时，free这一块内存</strong></p>
<p><strong>MRC和ARC实质上都是对这个引用计数进行操作</strong></p>
<h3 id="手动引用计数-MRC"><a href="#手动引用计数-MRC" class="headerlink" title="手动引用计数 MRC"></a>手动引用计数 MRC</h3><p>手动引用计数要确保<strong>在对象从被创建到销毁的一生中，该对象的引用计数也从1变成0</strong>。</p>
<p>与对象引用计数相关的函数只有3个：</p>
<ol>
<li>alloc/new/copy/mutableCopy</li>
<li>retain</li>
<li>release</li>
</ol>
<h4 id="alloc-new-copy-mutableCopy"><a href="#alloc-new-copy-mutableCopy" class="headerlink" title="alloc/new/copy/mutableCopy"></a>alloc/new/copy/mutableCopy</h4><p>这几个函数生成一个对象，并且该对象的引用计数为1</p>
<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><p><code>retain</code>函数将对象的引用计数加1</p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>release</code>函数将对象的引用计数减一</p>
<h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><h5 id="autorelease函数"><a href="#autorelease函数" class="headerlink" title="autorelease函数"></a>autorelease函数</h5><pre><code class="objective-c">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]  // 1
id obj = [[NSObject alloc] init];                           // 2
[obj autorelease];                                          // 3
[id dosomething];                                           // 4
[pool drain];                                               // 5
</code></pre>
<ol>
<li>注释2处，使用<code>alloc</code>方法新建一个对象，该对象的引用计数为1</li>
<li>注释3处，调用了<code>autorelease</code>函数；该函数并没有更改对象的引用计数，但是它将对象注册到自动释放池中</li>
<li>注释4处，因为注释3没有减少引用计数，所以对象的引用计数还是1。所以这个地方对象依然存在，可以正常使用对象</li>
<li>注释5处，因为在注释3时将对象注册进pool。此时<code>[pool drain]</code>方法会去调用对象的<code>release</code>方法，将对象引用计数减1；此时引用计数为0，那么释放内存空间</li>
</ol>
<p>所以从上面看出：<strong><code>autorelease</code>函数并没有改变对象的引用计数，只是简单的将对象与释放池挂钩；当<code>pool drain</code>时才调用对象的<code>release</code>函数</strong>。</p>
<p>所以 <strong><code>autorelease</code>函数实质就是延迟对象的<code>release</code>方法；可以让你放心使用对象，但又防止了你忘记释放对象</strong></p>
<h5 id="array类对象"><a href="#array类对象" class="headerlink" title="array类对象"></a>array类对象</h5><pre><code class="objective-c">id obj = [NSMutableArray array];
</code></pre>
<p>这里不需要调用对象的<code>release</code>方法。因为在内部的实现是：</p>
<pre><code class="objective-c">+ (id)array {
      id obj = [[NSMutableArray alloc] init];
      [obj autorelease];
      return obj;
}
</code></pre>
<p><code>array</code>类方法返回的对象，该对象的引用计数为1；但是已经注册到自动释放池中了，会在释放池结束时调用<code>release</code>方法</p>
<h4 id="MRC总结"><a href="#MRC总结" class="headerlink" title="MRC总结"></a>MRC总结</h4><p>对象一定成对的存在 <code>alloc</code> 和  <code>release</code>方法；或者成对的存在<code>retain</code> 和  <code>release</code> 方法。只有这样才能对引用计数有增有减，才能保证对象能正确的释放。</p>
<p>如果没有成对的出现，但是程序又是正确的，那么这3个方法的调用肯定在某函数的内部。比如<code>[pool drain]</code> 或者 <code>[NSMutableArray array]</code> 等函数中。</p>
<h3 id="自动引用计数-ARC"><a href="#自动引用计数-ARC" class="headerlink" title="自动引用计数 ARC"></a>自动引用计数 ARC</h3><p>ARC不再需要你来手动调用<code>retain</code> 和 <code>release</code> 函数了，系统会自己调用这些函数。那么ARC需要注意的是什么呢：</p>
<ol>
<li><strong>__strong</strong></li>
<li><strong>__weak</strong></li>
<li><strong>__autorelease</strong></li>
</ol>
<p>使用以上三个修饰符对对象进行修饰，那么就会自动增减引用计数</p>
<h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><p><strong>会自动release</strong></p>
<pre><code class="objective-c">{
      id obj = [[NSObject alloc] init];
}

// 转化之后

id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_release(obj);

/*--------------------------分割符------------------*/
{
      id __strong obj = obj2;
    // do something
}

// 转化之后

id obj = obj2;
[obj retain];
// do something
[obj release];
</code></pre>
<p>可以看到<code>__strong</code>会持有对象，并自动调用release将引用计数减一</p>
<p><strong>会阻止对象注册到release pool中，并持有对象</strong></p>
<pre><code class="objective-c">{
   id __strong obj = [NSMutableArray array];
}

// 转化之后

id obj = objc_msgSend(NSMutableArray, @selector(alloc));
objc_msgSend(obj, @selector(init));
return objc_autoreleaseReturnValue(obj);  

objc_retainAutoreleasedReturnValue(obj);
objc_release(obj);
</code></pre>
<p>可以看到，__strong会将即将注册到pool的对象抢过来，自己持有，并释放。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>__strong</code>修饰符会持有对象，并自动释放。有时会抢过pool的对象，来自己释放</p>
<h4 id="autorelease"><a href="#autorelease" class="headerlink" title="__autorelease"></a>__autorelease</h4><p>不常用，基本原理：</p>
<ol>
<li>对于已经/或即将注册到pool的对象，没有变化。会由pool来释放该对象</li>
<li>对于其他对象，会将对象retain，并强制注册到pool，由pool来release</li>
</ol>
<h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><p>weak变量不对引用计数产生影响。来看一下代码：</p>
<pre><code class="objective-c">id __weak obj1 = obj;
id __weak obj2 = obj;
</code></pre>
<p>APP管理一个全局的weak表，上面这两行代码，会往该表中插入2行记录：</p>
<p>每行记录的key是对象的首地址，也就是 <code>obj</code> ；value是存放weak变量的地址，也就是<code>&amp;obj1</code> 和 <code>&amp;obj2</code> 。</p>
<ol>
<li>当weak变量obj1被废弃时，将weak表中的value为<code>&amp;obj1</code>的记录删除</li>
<li>当对象被废弃时，这时候obj1,obj2应该指向nil。这时就将weak表中，key为<code>obj</code>的记录的key置成nil</li>
</ol>
<p><strong>所以寻找weak变量对应的对象地址时，其实就是寻找weak表中的key值</strong></p>
<h5 id="使用-weak变量时"><a href="#使用-weak变量时" class="headerlink" title="使用__weak变量时"></a>使用__weak变量时</h5><pre><code class="objective-c">{
      id __weak o = obj;
      NSLog(@&quot;%@&quot;, o);
}

// 转化之后

id o;
objc_initWeak(&amp;o, obj);
id tmp = objc_loadWeakRetained(&amp;o);
objc_autorelease(tmp);
NSLog(@&quot;%@&quot;, tmp);
objc_destoryWeak(&amp;o);
</code></pre>
<p>可以看到使用weak变量时，其实是将该weak变量指向的对象交由一个tmp变量持有，并将该对象注册到pool中。这样可以保证对象万一被释放了，也至少还有tmp持有他，可以正常使用。</p>
<h2 id="Block的实现"><a href="#Block的实现" class="headerlink" title="Block的实现"></a>Block的实现</h2><p><strong>使用clang的<code>-rewrite-objc</code>选项，可以将OC代码转换成C++代码。这样就可以看到Block的C++的实现</strong></p>
<h3 id="不截获任何变量的Block"><a href="#不截获任何变量的Block" class="headerlink" title="不截获任何变量的Block"></a>不截获任何变量的Block</h3><pre><code class="objective-c">int main() {
  void (^blk)(void) = ^{printf(&quot;Block\n&quot;);};
  blk();
  return 0;
}
</code></pre>
<p>经过 <code>clang -rewrite-objc main.m</code> 转化之后，生成<code>main.cpp</code> 。来看看Block在C++中如何表现：</p>
<pre><code class="c">// 只截取关键代码
struct __main_block_impl_0 {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
  struct __main_block_desc_0 *Desc;

  __main_block_impl_0(void *fp) {
    isa = &amp;_NSConcreteStackBlock;
    FuncPtr = fp;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  printf(&quot;Block\n&quot;);
};

int main() {
  struct __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0);
  struct __main_block_impl_0 *blk = &amp;tmp;
  (*blk-&gt;FuncPtr)(blk);
  return 0;
}
</code></pre>
<p><strong>可以发现Block实际上是一个结构体，blk变量是指向<code>__main_block_impl_0</code>结构体的指针。该结构体中有一个函数指针 <code>FuncPtr</code>，执行Block时，其实就是执行该结构体中函数指针对应的函数。</strong></p>
<h3 id="截获变量但不修改的Block"><a href="#截获变量但不修改的Block" class="headerlink" title="截获变量但不修改的Block"></a>截获变量但不修改的Block</h3><pre><code class="objective-c">int main() {
  int val = 10;
  void (^blk)(void) = ^{printf(&quot;%d&quot;, val);};
  blk();
  return 0;
}
</code></pre>
<p>相同的方法，来看一下转化之后的结果：</p>
<pre><code class="c">struct __main_block_impl_0 {
  void *fp;
  int Flags;
  int Reserved;
  void *FuncPtr;
  struct __main_block_desc_0 *Desc;

  int val;

  __main_block_impl_0(void *fp, int _val) : val(_val) {
    isa = &amp;_NSConcreteStackBlock;
    FuncPtr = fp;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int val = __cself-&gt;val;
  printf(&quot;%d&quot;, val);
}

int main() {
  int val = 10;
  struct __main_block_impl_0 = __main_block_impl_0(__main_block_func_0, val);
  struct __main_block_impl_0 *blk = &amp;tmp;
  (*blk-&gt;FuncPtr)(blk);

  return 0;
}
</code></pre>
<p><strong>可以看到，对于截获但是未曾改变的变量<code>val</code>，Block结构体会将该变量拷贝到结构体中的同名成员变量中。所以当main函数里面定义的val之后无论如何改变，都不会影响到Block中存储的val变量；因为他们两个是不同的两个变量。</strong></p>
<h3 id="截获-block变量"><a href="#截获-block变量" class="headerlink" title="截获__block变量"></a>截获__block变量</h3><p>当要在Block里面改变截获的变量时，需要使用<strong>__block</strong>修饰符。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><pre><code class="c">int global_val = 2;
int main() {
  // do something
}
</code></pre>
<p>对于全局变量，Block可以直接访问，不需要做任何的改变</p>
<h4 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h4><pre><code class="objective-c">int main() {
  static int static_val = 3;
  void (^blk)(void) = ^{
    static_val += 1;
  }

  return 0;
}
</code></pre>
<p>来看转化之后：</p>
<pre><code class="c">struct __main_block_impl_0 {
  // 一些其他成员
  int *static_val;

  __main_block_impl_0(void *fp, int *_static_val) : static_val(_static_val) {
    isa = &amp;_NSConcreteStackBlock;
    FuncPrt = fp;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *static_val = __cself-&gt;static_val;
  *static_val += 1;
}

int main() {
  static int static_val = 3;
  blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;static_val);

  return 0;
}
</code></pre>
<p><strong>可以看到，对于静态局部变量，Block的结构体中存放的是指向该变量的指针，所以可以通过指针来改变该静态局部变量。这是因为，静态局部变量即使其作用域已经结束，但是它并不会被销毁，其内存空间是一直存在的</strong></p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><pre><code class="objective-c">int main() {
  __block int val = 10;
  void (^blk)(void) = ^{val = 1;};
  return 0;
}
</code></pre>
<p><strong>在Block中改变局部自动变量需要使用<code>__block</code>修饰符</strong>；转化成C++代码：</p>
<pre><code class="c">struct __Block_byref_val_0 {
  void *__isa;
  __Block_byref_val_0 *__forwarding;
  int __flags;
  int __size;
  int val;
};

struct __main_block_impl_0 {
  // 其他成员变量

  __Block_byref_val_0 *val;

  __main_block_impl_0(void *fp, __Block_byref_val_0 *_val) : val(_val-&gt;__forwarding) {
    //
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself-&gt;val;
  (val-&gt;forwarding-&gt;val) = 1;
}

int main() {
  __Block_byref_val_0 val = {
    0,
    &amp;val,
    0,
    sizeof(__Block_byref_val_0),
    10
  };

  blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;val);
  return 0;
}
</code></pre>
<p>可以看到_<em>block变量val其实是一个结构体 \</em>_Block_byref_val_0。在里面有val这个变量。</p>
<p>因为正常生成的Block都是在栈上面的，但是在合适的情况下面，栈上的Block会被拷贝到堆上；与此同时，Block所拥有的__block结构体也会被拷贝到堆上，相当于Block持有__block变量。</p>
<p>当block变量还在栈上时，它的forwarding指向自己；当被拷贝到堆上时，forwarding指向堆上的block变量。在使用时全部使用forwarding，这样可以保证改变的是同一个变量。</p>
<p><strong>使用这么一个结构体来存放局部变量，可以保证局部变量可以时时刻刻被更改，也可以保证栈上局部变量被释放后，堆上的局部变量依然可以访问</strong></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在堆上的Block或者block变量才谈论对象的retain以及release；在栈上的Block和block会被栈自动释放，也不存在对象的retain和release</p>
<p>Block会在一下情况下被复制到堆上面：</p>
<ol>
<li>显式调用Block的<code>copy</code>方法</li>
<li>Block作为函数返回值返回</li>
<li>将Block赋给<code>__strong</code>的id类型或者Block的类的成员变量时 （这时候要注意self和Block的循环引用）</li>
<li>方法名中含有usingBlock的Cocoa框架方法，或者GCD中使用的Block</li>
</ol>
<h2 id="GCD-与-runloop"><a href="#GCD-与-runloop" class="headerlink" title="GCD 与 runloop"></a>GCD 与 runloop</h2><ol>
<li>GCD操作的是<code>queue</code>，然后由queue来确定block该由哪个线程来执行。</li>
<li>runloop对应的则直接是线程。一个线程可以有0-1个runloop在上面执行。</li>
</ol>
<h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><p>runloop实际上就是一个运行在特定线程上面的do-while循环。在do-while循环里面，可以处理多种事件：</p>
<ol>
<li>port-based event，多半是系统事件</li>
<li>其他线程传递给当前线程来直线的block</li>
<li>Timer，定时事件</li>
<li>Observer，当runloop状态变化时，执行相应的监听器</li>
</ol>
<p>有事件来时，runloop就执行事件；没有事件，就进入休眠，但是并没有退出do-while循环。只有当runloop到达限定时间，或者手动退出runloop；这个do-while循环才会结束</p>
<h4 id="主线程与runloop"><a href="#主线程与runloop" class="headerlink" title="主线程与runloop"></a>主线程与runloop</h4><p>APP的主线程一直运行着一个runloop循环，这个runloop由系统运行，并且已经往该runloop中添加了一些事件。</p>
<h5 id="硬件事件响应"><a href="#硬件事件响应" class="headerlink" title="硬件事件响应"></a>硬件事件响应</h5><p>当发生硬件事件时，也就是触摸，锁屏，摇动等事件时；这些事件都是系统事件，也就是port-based的类型。那么runloop会使用<code>_UIApplicationHandleEventQueue()</code>该函数来处理这一类事件</p>
<h5 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h5><p>在<code>_UIApplicationHandleEventQueue()</code>函数中，会识别出需要待处理的手势。当runloop进入休眠之前，会出发Observer，在这个Observer中会调用<code>_UIGestureRecognizerUpdateObserver()</code>函数，该函数会处理手势（也就是这行手势的回调函数）</p>
<h5 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h5><p>每当runloop即将进入休眠，或者即将退出时，会执行一个Observer。在这个Observer里面会查看每个View的frame等属性，如果需要重新绘制，那么开始重新绘制的过程。（layout -&gt; display -&gt; draw 等等）</p>
<p><strong>所以当其他的事件执行时间过长，超过16ms的话，就会推迟进入休眠，也就会推迟Observer的触发，也就会推迟界面的更新。那么就会造成卡顿的现象。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 如果还有其他的话]]></title>
      <url>/2017/06/10/objective-c-runtime-other/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列应该是最后一篇：还真要来讲一点其他的东西：</p>
<ol>
<li><strong>self &amp;&amp; super</strong></li>
<li><strong>alloc &amp;&amp; init</strong></li>
</ol>
<a id="more"></a>
<h2 id="self-amp-amp-super"><a href="#self-amp-amp-super" class="headerlink" title="self &amp;&amp; super"></a>self &amp;&amp; super</h2><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>self是每个类函数中的隐藏参数，比如一个类的函数<code>- (void)someFunc;</code> 它经过编译之后会变成 <code>void someFunc(id self, SEL _cmd);</code>  当有一个对象去调用该函数时，比如 <code>[someObj someFunc];</code> 那么等价于 <code>someFunc(a, @selector(someFunc));</code> 会将a自己传入该函数</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super是一个预编译命令，他会先调用父类的方法。比如在init方法中 [super init]; 该方法会先调用父类的init方法 </p>
<h2 id="alloc-amp-amp-init"><a href="#alloc-amp-amp-init" class="headerlink" title="alloc &amp;&amp; init"></a>alloc &amp;&amp; init</h2><h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>alloc方法会生成一个类的对象，并将该类对象的isa变量初始化</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>讲道理，[NSObject init]方法没做啥事</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/15fa5e84c897" target="_blank" rel="external">OC中的self和super</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 应用和示例]]></title>
      <url>/2017/06/10/objective-c-runtime-example/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列第五篇：将展示几个runtime的例子以及runtime的实际应用。这些例子包括：</p>
<ol>
<li>动态<strong>添加属性</strong>以及添加用来存储属性对应的实例变量的<strong>关联对象</strong></li>
<li>方法决议：父类实<code>resolveInstanceMethod</code>，然后在子类中添加方法</li>
<li>消息转发示例：<ol>
<li><code>forwardingTargetForSelector</code></li>
<li><code>forwardInvocation</code></li>
</ol>
</li>
</ol>
<p>本文的demo代码可以在<a href="https://github.com/vanney9/runtime" target="_blank" rel="external">我的github</a>上找到</p>
<a id="more"></a>
<h2 id="几个有趣的示例"><a href="#几个有趣的示例" class="headerlink" title="几个有趣的示例"></a>几个有趣的示例</h2><h3 id="动态添加任意属性"><a href="#动态添加任意属性" class="headerlink" title="动态添加任意属性"></a>动态添加任意属性</h3><blockquote>
<p><code>class_addProperty</code> runtime添加属性API</p>
<p><code>class_addMethod</code> runtime添加方法API</p>
</blockquote>
<p>仅仅添加属性是没什么用的，因为还需要添加属性对应的实例变量。</p>
<p><strong>虽然runtime提供了<code>class_addIvar</code>方法来给类添加实例变量，但是注意，该方法只能在创建新的类的时候才能使用；对于已经存在的类，是不允许添加实例变量的</strong></p>
<p>鉴于上述原因，所以可以采用动态添加关联对象来存储属性对应的实例变量。</p>
<h4 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h4><p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)</code></p>
<ol>
<li><code>cls</code> : 要添加属性的类</li>
<li><code>name</code> : 添加属性的名字</li>
<li><code>attributes</code> : 属性的特性</li>
<li><code>attributeCount</code> : 属性特性数量</li>
</ol>
<pre><code class="objective-c">// runtime add property
objc_property_attribute_t attribute1 = {&quot;T&quot;, @encode(NSString *)};
objc_property_attribute_t attribute2 = {&quot;N&quot;, &quot;&quot;};
objc_property_attribute_t attribute3 = {&quot;&amp;&quot;, &quot;&quot;};
objc_property_attribute_t attribute[] = {attribute1, attribute2, attribute3};
class_addProperty([HCBase class], &quot;sb&quot;, attribute, 3);
</code></pre>
<p>如上代码，添加了一个属性<code>sb</code>，该属性有3个特性：1. NSString类型 2. nonatomic 3. strong</p>
<h4 id="添加关联对象"><a href="#添加关联对象" class="headerlink" title="添加关联对象"></a>添加关联对象</h4><p>为了向正常属性那样访问，给该类添加<code>sb</code>属性的存取方法<code>sb</code> 和 <code>setSb:</code></p>
<pre><code class="objective-c">// add property getter and setter
//class_addMethod([HCBase class], @selector(sb), (IMP) sb, &quot;@@:&quot;);
class_addMethod([HCBase class], NSSelectorFromString(@&quot;sb&quot;), (IMP) customGetter, &quot;@@:&quot;);
//class_addMethod([HCBase class], @selector(setSb:), (IMP) setSb, &quot;v@:@&quot;);
class_addMethod([HCBase class], NSSelectorFromString(@&quot;setSb:&quot;), (IMP) customSetter, &quot;v@:@&quot;);
</code></pre>
<p>注意该方法的最后一个参数是添加的方法的签名：<code>返回类型 + self + selector + 参数</code> 的字符串：</p>
<ol>
<li><code>sb</code>方法，返回类型为id(<strong>@</strong>)，self为id(<strong>@</strong>)，选择子(<strong>:</strong>)，参数为空 =&gt; @@:</li>
<li><code>setSb:</code>方法，返回类型为void(<strong>v</strong>)，self为id(<strong>@</strong>)，选择子(<strong>:</strong>)，参数为id(<strong>@</strong>) =&gt;  v@:@</li>
</ol>
<p>现在来看看setter和getter的通用实现方法</p>
<pre><code class="objective-c">// custom getter &amp;&amp; setter

void customSetter(id self, SEL _cmd, id value) {
    NSString *propertyStr = NSStringFromSelector(_cmd);
    // divide set
    NSString *realProperty = [propertyStr substringFromIndex:3];
    realProperty = [realProperty substringToIndex:realProperty.length - 1];
    realProperty = [realProperty lowercaseString];
    //const NSString *key = [realProperty copy];
    objc_setAssociatedObject(self, NSSelectorFromString(realProperty), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    //objc_setAssociatedObject(self, &quot;sb&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

id customGetter(id self, SEL _cmd) {
    id result = objc_getAssociatedObject(self, _cmd);
    //id result = objc_getAssociatedObject(self, &quot;sb&quot;);
    return result;
}
</code></pre>
<p>这两个方法通过判断selector来判断要添加的是哪一个属性的关联对象，也就是说这个方法是对任何属性通用的（之后新添加其他的属性，也可以使用该实现）</p>
<p>注意：<code>objc_setAssociationObject</code> 和 <code>objc_getAssociationObject</code>方法中的第二个参数，也就是对象的key是一个 <code>const void *</code> 类型：常量指针；正好@selector也是常量指针。</p>
<h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><pre><code class="objective-c">// new HCBase and set &amp;&amp; printf sb
HCBase *baseOBJ = [[HCBase alloc] init];
//[baseOBJ performSelector:@selector(setSb:) withObject:@&quot;sb&quot;];
[baseOBJ performSelector:NSSelectorFromString(@&quot;setSb:&quot;) withObject:@&quot;sb&quot;];
//NSLog(@&quot;vanney code log : new property is %@&quot;, [baseOBJ performSelector:@selector(sb)]);
NSLog(@&quot;vanney code log : new property is %@&quot;, [baseOBJ performSelector:NSSelectorFromString(@&quot;sb&quot;)]);
</code></pre>
<p>已经添加了属性，并添加了存取方法。现在可以使用<code>performSelector</code>方法来执行存取方法</p>
<h3 id="方法决议"><a href="#方法决议" class="headerlink" title="方法决议"></a>方法决议</h3><blockquote>
<pre><code class="objective-c">+ (BOOL)resolveInstanceMethod:(SEL)sel;
</code></pre>
</blockquote>
<p>当没有找到方法的实现时，会执行该方法，可以在该方法里面动态添加缺失的方法的实现。</p>
<p>来看看两个类的声明：</p>
<pre><code class="objective-c">/*--------- HCBase -----------*/
#import &quot;runtime.h&quot;
#import &lt;Foundation/Foundation.h&gt;

@interface HCBase : NSObject

//@property (nonatomic, strong) NSString *curry;
//@property (nonatomic, copy) NSString *kd;
//@property (nonatomic, assign) int kt;

- (void)needResolve;

- (void)needForwardTarget;

- (void)needFinalForward;

@end

/*----------- HCSon -----------*/
#import &quot;HCBase.h&quot;

@interface HCSon : HCBase

@end
</code></pre>
<p><code>HCSon</code> 继承自 <code>HCBase</code> 类，另外<code>HCBase</code>中声明了一个方法<code>needResolve</code>，但是没有提供实现。</p>
<p>那么当一个<code>HCSon</code>对象调用<code>needResolve</code>方法时，无法找到实现；接着会去寻找<code>resolveInstanceMethod:</code>，并执行该方法。但是该<code>resolveInstanceMethod</code>方法定义在父类<code>HCBase</code>里面</p>
<pre><code class="objective-c">void resolveImp(id self, SEL _cmd) {
    NSLog(@&quot;vanney code log : resolved function&quot;);
}

@implementation HCBase
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if ([NSStringFromSelector(sel) isEqualToString:@&quot;needResolve&quot;]) {
        class_addMethod(self, @selector(needResolve), (IMP) resolveImp, &quot;v@:&quot;);
        return YES;
    } else {
        return [[self superclass] resolveInstanceMethod:sel];
    }
}
@end
</code></pre>
<p>该方法给self类添加一个<code>needResolve</code>方法，之后会重新执行<code>needResolve</code>方法。</p>
<p>现在来看看一个HCSon对象调用<code>needResolve</code>的过程</p>
<pre><code class="objective-c">// resolve

// print method
int methodCount;
Method *methodList = class_copyMethodList([HCBase class], &amp;methodCount);
for (int j = 0; j &lt; methodCount; ++j) {
Method curMethod = methodList[j];
printf(&quot;before HCBase method name is %s, and type encoding is %s\n&quot;, method_getName(curMethod), method_getTypeEncoding(curMethod));
}

int methodCountS;
Method *methodListS = class_copyMethodList([HCSon class], &amp;methodCountS);
for (int j = 0; j &lt; methodCountS; ++j) {
Method curMethod = methodListS[j];
printf(&quot;before HCSon method name is %s, and type encoding is %s\n&quot;, method_getName(curMethod), method_getTypeEncoding(curMethod));
}

HCSon *son = [[HCSon alloc] init];
//[baseOBJ needResolve];
[son needResolve];

Method *newMethodList = class_copyMethodList([HCBase class], &amp;methodCount);
for (int j = 0; j &lt; methodCount; ++j) {
Method curMethod = newMethodList[j];
printf(&quot;new HCBase method name is %s, and type encoding is %s\n&quot;, method_getName(curMethod), method_getTypeEncoding(curMethod));
}

Method *newMethodListS = class_copyMethodList([HCSon class], &amp;methodCountS);
for (int j = 0; j &lt; methodCountS; ++j) {
Method curMethod = newMethodListS[j];
printf(&quot;new HCSon method name is %s, and type encoding is %s\n&quot;, method_getName(curMethod), method_getTypeEncoding(curMethod));
}
</code></pre>
<p>在执行<code>[son needResolve]</code>之前，先打印父类和子类的方法，可以发现都没有<code>needResolve</code>方法；执行之后再次打印，发现<code>HCSon</code>里面增加了<code>needResolve</code>方法。</p>
<p><strong>因为执行<code>resolveInstanceMethod</code>方法时，传入的<code>self</code>是<code>HCSon</code>，所以方法就添加在<code>HCSon</code>里面</strong></p>
<p><img src="/lionheart/1706/resolve.png" alt="resolve"></p>
<p><strong>注意图片的最后一行</strong></p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h4 id="备援对象"><a href="#备援对象" class="headerlink" title="备援对象"></a>备援对象</h4><blockquote>
<p><code>- (id)forwardingTargetForSelector:(SEL)selector;</code></p>
</blockquote>
<p><code>HCBase</code>声明了<code>needForwardTarget</code>方法，但是没有实现；但是<code>HCBeitai</code>类有该方法。可以使用<code>forwardingTargetForSelector</code>方法，返回一个<code>HCBeitai</code>对象，让该对象来执行<code>needForwardTarget</code>方法。</p>
<pre><code class="objective-c">/*------------ HCBeiTai -----------*/
#import &lt;Foundation/Foundation.h&gt;

@interface HCBeiTai : NSObject

- (void)needForwardTarget;

- (void)beitaiForwarding:(int)index;

@end

@implementation HCBeiTai

- (void)needForwardTarget {
    NSLog(@&quot;bei tai 作用了&quot;);
}

- (void)beitaiForwarding:(int)index {
    NSLog(@&quot;vanney code log : bei tai 终极forwarding起作用了 : index is %d&quot;, index);
}

@end

/*-------------- HCBase ------------*/
- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(needForwardTarget)) {
        NSLog(@&quot;vanney code log : forwarding Target start&quot;);
        HCBeiTai *beitai = [[HCBeiTai alloc] init];
        return beitai;
    } else {
        return [super forwardingTargetForSelector:aSelector];
    }
}
</code></pre>
<p>这么一来，就好像<code>HCBase</code>继承了<code>HCBeitai</code>一样，可以用来模拟多重继承。来看看运行的结果：</p>
<pre><code class="objective-c">// forwardingTarget
[baseOBJ needForwardTarget];
</code></pre>
<p><img src="/lionheart/1706/forwarding1.png" alt="forwarding1"></p>
<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4><blockquote>
<p><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</code></p>
<p><code>- (void)forwardInvocation:(NSInvocation *)invocation;</code></p>
</blockquote>
<p>当所有的手段都无法处理该方法时，就开启了完整的消息转发。先调用<code>methodSignatureForSelector</code>方法，给该未知方法签名— 类似<strong>@@:</strong> 。当签名不为空时，调用<code>forwardInvocation</code>，将位置方法的所有信息存放在<code>NSInvocation</code>对象中；这时可以更改方法的信息，比如selector，signature等等，然后交由其他对象来执行更改之后的方法。</p>
<p>来看看一个示例：<code>HCBase</code>声明了<code>needFinalForward</code>方法，但是没有提供实现；<code>HCBeitai</code>实现了<code>beitaiForwarding:</code>方法。消息转发，将给<code>HCBase</code>对象的<code>needFinalForward</code>方法 转发给了 <code>HCBeitai</code>对象的<code>beitaiForwarding:</code>方法。<strong>注意：这两个方法的selector和signature都不一样</strong></p>
<pre><code class="objective-c">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSLog(@&quot;vanney code log : selector is %@&quot;, NSStringFromSelector(aSelector));
    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];
    if (!methodSignature) {
        NSLog(@&quot;vanney code log : inside create method signature&quot;);
        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;];
    }

    return methodSignature;
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    NSLog(@&quot;vanney code log : forwarding invocation selector is %@&quot;, NSStringFromSelector(anInvocation.selector));
    NSLog(@&quot;vanney code log : invocation is %@, and method signature is %@&quot;, anInvocation, anInvocation.methodSignature);

    if (anInvocation.selector == @selector(needFinalForward)) {
        NSLog(@&quot;vanney code log : inside forwarding&quot;);
        anInvocation.selector = NSSelectorFromString(@&quot;beitaiForwarding:&quot;);
        int *a;
        *a = 99;
        [anInvocation setArgument:a atIndex:2];
        HCBeiTai *beiTai = [[HCBeiTai alloc] init];
        [anInvocation invokeWithTarget:beiTai];
    } else {
        NSLog(@&quot;vanney code log : else forwarding&quot;);
        [super forwardInvocation:anInvocation];
    }

}
</code></pre>
<p>转发的同时，还可以设置参数。把99传递给新的方法。来看看运行结果：</p>
<pre><code class="objective-c">// final forwarding
[baseOBJ needFinalForward];
</code></pre>
<p><img src="/lionheart/1706/forwarding2.png" alt="forwarding2"></p>
<h2 id="runtime应用"><a href="#runtime应用" class="headerlink" title="runtime应用"></a>runtime应用</h2><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>可以在类的<code>load</code>方法中，通过<code>class_addMethod</code> <code>class_replaceMethod</code>来改变方法的默认实现方式。因为<code>load</code>方法执行时，所有类的方法都有了，但都还没有执行过一次</p>
<h3 id="JSON-gt-Model"><a href="#JSON-gt-Model" class="headerlink" title="JSON -&gt; Model"></a>JSON -&gt; Model</h3><pre><code class="objective-c">- (instancetype)initWithDict:(NSDictionary *)dict {

    if (self = [self init]) {
        //(1)获取类的属性及属性对应的类型
        NSMutableArray * keys = [NSMutableArray array];
        NSMutableArray * attributes = [NSMutableArray array];
        /*
         * 例子
         * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3
         * name = value4 attribute = T^i,N,V_value4
         */
        unsigned int outCount;
        objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);
        for (int i = 0; i &lt; outCount; i ++) {
            objc_property_t property = properties[i];
            //通过property_getName函数获得属性的名字
            NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
            [keys addObject:propertyName];
            //通过property_getAttributes函数可以获得属性的名字和@encode编码
            NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];
            [attributes addObject:propertyAttribute];
        }
        //立即释放properties指向的内存
        free(properties);

        //(2)根据类型给属性赋值
        for (NSString * key in keys) {
            if ([dict valueForKey:key] == nil) continue;
            [self setValue:[dict valueForKey:key] forKey:key];
        }
    }
    return self;

}
</code></pre>
<p>该方法参考自<a href="http://www.jianshu.com/p/07b6c4a40a90" target="_blank" rel="external">[iOS] runtime 的使用场景–实战篇</a></p>
<h3 id="KVO-KVC"><a href="#KVO-KVC" class="headerlink" title="KVO, KVC"></a>KVO, KVC</h3><p>海带学习</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/07b6c4a40a90" target="_blank" rel="external">[iOS] runtime 的使用场景–实战篇</a></li>
<li><a href="https://github.com/vanney9/runtime" target="_blank" rel="external">我的github</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - API]]></title>
      <url>/2017/06/09/objective-c-runtime-api/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列第四篇：前面3篇，主要从对象，属性，方法等方面分析了runtime的源码。这一篇，来看看runtime提供的API。这些API可以用来操作类，对象，属性，方法等等。了解了这些底层的实现，API的工作只是对这些底层操作做了个封装。</p>
<p><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc" target="_blank" rel="external">官方runtimeAPI文档</a></p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>runtime的API全部定义在<code>runtime.h</code> 头文件中，该API作用与以下几个方面：(<strong>API的开头都是以以下几个方面命名的</strong>)</p>
<ol>
<li>类</li>
<li>实例对象</li>
<li>实例变量</li>
<li>关联对象</li>
<li>消息发送</li>
<li>方法</li>
<li>选择子</li>
<li>协议</li>
<li>属性</li>
</ol>
<p>具体的可以参考官方文档</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc" target="_blank" rel="external">官方runtimeAPI文档</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 消息]]></title>
      <url>/2017/06/08/objective-c-runtime-message/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列第三篇：来看看OC的消息。包括<strong>方法查找、缓存、方法决议以及消息转发</strong></p>
<a id="more"></a>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><blockquote>
<p><code>objc_msgSend</code> 函数的原型为 <code>void objc_msgSend(id self, SEL cmd, ...)</code></p>
</blockquote>
<p>给一个对象发送消息：</p>
<pre><code class="objective-c">id returnValue = [someObject messageName:parameter];
</code></pre>
<p>编译器会将该OC语句转换成<code>objc_msgSend</code>函数:</p>
<pre><code class="c++">id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter);
</code></pre>
<p>其中的SEL选择子可以理解成方法的名字。</p>
<p><strong>从这里可以看出，给OC对象发送消息，其实就是调用<code>objc_msgSend</code>函数，所有这篇文章的重点也是该函数的具体实现过程</strong></p>
<h2 id="OC方法本质"><a href="#OC方法本质" class="headerlink" title="OC方法本质"></a>OC方法本质</h2><pre><code class="c++">- (void)hello:(int)a;

// 该方法编译的时候会被转化成：

void hello(id self, SEL _cmd, int a);
</code></pre>
<p>当有一个对象调用该方法时：</p>
<pre><code class="c++">[someObj hello:2];

// 编译之后就是
objc_msgSend(someObj, @selector(hello:), 2);

// 当objc_msgSend找到方法的实现，也就是hello方法时，相当于调用：
hello(someObj, @selector(hello:), 2);
</code></pre>
<h2 id="方法查找-amp-amp-缓存"><a href="#方法查找-amp-amp-缓存" class="headerlink" title="方法查找 &amp;&amp; 缓存"></a>方法查找 &amp;&amp; 缓存</h2><p>回忆一下<code>objc_class</code>结构体</p>
<p><img src="/lionheart/1706/bits.png" alt="objc_class"></p>
<p>类的方法都存放在<code>bits</code>成员变量中，而方法的缓存则是存放在<code>cache</code>成员变量中。</p>
<p><code>objc_msgSend</code>函数通过调用<code>lookUpImpOrForward</code>函数来查找方法的实现</p>
<h3 id="当前类查询"><a href="#当前类查询" class="headerlink" title="当前类查询"></a>当前类查询</h3><p><code>objc_msgSend</code>函数查询方法的实现，先会在当前类中查询。</p>
<ol>
<li>先在缓存<code>cache</code>中寻找是否存在该方法，找到就去执行</li>
<li>如果没在缓存中找到该方法，就到<code>bits</code>中寻找方法。如果找到，会先写入缓存<code>cache</code>，再去执行方法；如果没找到，就会去<code>super_class</code>里面寻找</li>
</ol>
<h2 id="沿着类继承关系查询"><a href="#沿着类继承关系查询" class="headerlink" title="沿着类继承关系查询"></a>沿着类继承关系查询</h2><p>每个<code>objc_class</code>都会有指向父类的指针。当子类无法提供方法的实现时，会跑到父类来寻找该实现，过程相似：</p>
<ol>
<li>在父类的缓存<code>cache</code>中寻找。如果找到，写到调用该方法的类的<code>cache</code>中，再执行</li>
<li>在缓存中没找到，就继续在父类的<code>bits</code>中查找，找到，写入缓存并执行</li>
<li>如果还是没找到，继续沿着类继承关系寻找方法的实现</li>
</ol>
<h2 id="方法决议"><a href="#方法决议" class="headerlink" title="方法决议"></a>方法决议</h2><blockquote>
<p><code>+ (BOOL)resolveInstanceMethod:(SEL)selector</code> </p>
<p><code>+ (BOOL)resolveClassMethod:(SEL)selector</code></p>
</blockquote>
<p>如果在当前类以及所有父类之中都无法找到方法的实现的话，就进入了方法决议的阶段。来看看方法决议的过程：(<strong>该过程的源码也在<code>lookUpImpOrForward</code>方法中</strong>)</p>
<ol>
<li><p>查看当前类是否实现了resolve方法。如果没有，决议直接失败</p>
</li>
<li><p>如果存在resolve方法，那么执行该方法。这个方法里面一般会动态给当前类添加方法，是的之前没有找到实现的方法可以实现。例如，来实现@dynamic的属性的存取方法</p>
</li>
</ol>
<pre><code class="objective-c">// 注意：以下两方法的相关实现代码已经写好
id autoDictionaryGetter(id self, SEL _cmd);
void autoDictionarySetter(id self, SEL _cmd, id value);

+ (BOOL)resolveInstanceMethod:(SEL)selector {
    NSString *selectorString = NSStringFromSelector(selector);
    if ([selectorString hasPrefix:@&quot;set&quot;]) {
        class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;);
    } else {
        class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;);
    }

    return YES;
}
</code></pre>
<p>   在这一个resolve方法里面，给类新增加了一个方法。</p>
<ol>
<li>执行完resolve方法之后，会重新进行一次方法的查找。如果找到方法了，执行</li>
</ol>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>如果方法决议也没有用的话，会给这个方法最后一个机会：消息转发</p>
<h3 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h3><blockquote>
<p><code>- (id)forwardingTargetForSelector:(SEL)selector;</code></p>
</blockquote>
<p>执行该函数，看能否返回一个新的对象，这个对象可以处理该方法。具体参见<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector" target="_blank" rel="external">官方文档</a></p>
<h3 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h3><p>如果无法找到备胎的话，就要进行完整的消息转发了。将未处理的消息封装成<code>NSInvocation</code>对象，然后调用<code>- (void)forwardInvocation:(NSInvocation *)invocation;</code> 方法。</p>
<p>这个转发的方法属于 <code>NSObject</code>，需要子类重写该方法。具体参见<a href="https://developer.apple.com/documentation/objectivec/nsobject/1571955-forwardinvocation" target="_blank" rel="external">官方文档</a></p>
<h3 id="完整的消息转发图示"><a href="#完整的消息转发图示" class="headerlink" title="完整的消息转发图示"></a>完整的消息转发图示</h3><p><img src="/lionheart/1706/forward.JPG" alt="forwarding"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>在后续的一片文章中会有详细的示例来说明消息决议和转发</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://draveness.me/message.html" target="_blank" rel="external">从源代码看 ObjC 中消息的发送</a></li>
<li>Effective Objective-C 2.0</li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector" target="_blank" rel="external">forwardingTargetForSelector:</a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1571955-forwardinvocation" target="_blank" rel="external">forwardInvocation:</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 分类与关联对象]]></title>
      <url>/2017/06/07/objective-c-runtime-category/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列第三篇：深入分析OC中的分类 - <strong>Category</strong> 以及在分类里面会涉及到了 <strong>关联对象</strong></p>
<a id="more"></a>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><h3 id="category-t"><a href="#category-t" class="headerlink" title="category_t"></a>category_t</h3><p>先来看看category的真面目：<strong>category_t</strong></p>
<pre><code class="c++">struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>
<p><code>category_t</code>结构体定义在<code>objc-runtime-new.h</code>中，可以看出该结构体中含有：实例方法列表、类方法列表、协议列表、属性列表。</p>
<h3 id="编译之后，runtime之前"><a href="#编译之后，runtime之前" class="headerlink" title="编译之后，runtime之前"></a>编译之后，runtime之前</h3><p>来看看NSObject的分类：</p>
<pre><code class="objective-c">#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (vc)

- (void)test;

@end
</code></pre>
<p>在编译结束之后，runtime运行之前。NSObject被编译成一个<code>objc_class</code> 结构体；而NSObject (vc) 被编译成一个<code>category_t</code> 结构体。</p>
<p>打印出这个结构体：(在<code>attachCategories</code>方法中判断当前的category位vc，并进入断点)</p>
<p><img src="/lionheart/1706/breakpoint.png" alt="break point"></p>
<p>打印出的category结果如下：</p>
<p><img src="/lionheart/1706/category.png" alt="category"></p>
<h3 id="runtime之后"><a href="#runtime之后" class="headerlink" title="runtime之后"></a>runtime之后</h3><p>运行<code>attachCategories</code> 方法之后，会将category中的所有方法、属性、协议添加到类的<code>class_rw_t</code>中。</p>
<p>我们以添加方法为例，在添加任何的分类方法之前，NSObject的<code>class_rw_t</code>中的<code>methods</code>数组只有一个元素，也就是<code>class_ro_t</code>中的<code>baseMethodList</code>列表。添加一个分类之后，会往<code>methods</code>数组中添加一个元素，该元素的类型是<code>entsize_list_tt</code>。</p>
<p>使用lldb查看，发现在添加vc分类后，NSObject里面已经添加了64个分类了；加上<code>baseMethodList</code>，<code>methods</code>数组已经有65个元素。（<strong>后添加的分类在数组中的位置靠前，baseMethodList元素在最后面</strong>）</p>
<p><img src="/lionheart/1706/nsobject.png" alt="category"></p>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p><strong>对于系统自带的类，才会在runtime时加载分类；但是对于自己创建的类，在编译结束之后就直接将分类的方法添加到<code>baseMethodList</code>中了，就好像没有分类一说。。</strong></p>
<pre><code class="objective-c">// TestOBJ
@interface TestOBJ : NSObject {
    NSInteger ivatInt;
}
@property (nonatomic, assign) NSInteger propertyInt;
- (void)test;
@end

// TestOBJ+vc
#import &quot;TestOBJ.h&quot;
@interface TestOBJ (vc)
@property (nonatomic, assign) NSInteger vc;
- (void)test;
@end
</code></pre>
<p>在<code>_objc_init</code>里面打上断点，这个方法是runtime的入口函数。在这个时候使用lldb，就发现在TestOBJ的<code>baseMethodList</code>里面有2个test方法了，当然分类的test方法在前面，也就是会被先检索到。</p>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>观察发现，category里面有属性，但是没有实例变量。在系列上一篇<a href="http://vanney9.com/2017/06/05/objective-c-runtime-property-method/" target="_blank" rel="external">Objective-C runtime - 属性与方法</a>了解到，属性没什么用，真正存放的还是实例变量。</p>
<p><strong>那么为什么不能添加实例变量呢？</strong> 因为实例变量在每个对象中都有一份。对于使用分类之前，对象的内存是如此分布的；如果添加了分类，那么每个对象的内存结构都需要改变。而对于方法来说，只需要类的结构体来存储方法，类的结构体也就只有一个，就可以随意更改。</p>
<p><strong>那么为什么可以添加属性呢？</strong> 只添加属性不添加实例变量，毫无意义。正是因为<strong>关联对象</strong>的引入，使得这个做法有意义起来。因为<strong>关联对象的作用和实例变量相似</strong>。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>关联对象相关的源码全部放在<code>objc-reference.h</code> 和 <code>objc-reference.mm</code> 两个文件中。</p>
<p><strong>关联对象和对象是一一对应的，而不是和类一一对应的</strong></p>
<ol>
<li>所有的关联对象都由一个<strong>AssociationsManager</strong>对象来管理，这个对象里面有一个<strong>AssociationsHashMap</strong>。</li>
<li><strong>AssociationsHashMap</strong>由许多key-value构成。key是对象的地址；value是一个<strong>ObjectAssociationMap</strong>，也就是所谓的关联对象。</li>
<li><strong>ObjectAssociationMap</strong>就是关联对象，每个关联对象里面包含多个key-value对。key是属性名；value是<strong>ObjcAssociation</strong>，也就是相当于属性对应的实例变量。</li>
<li><strong>ObjcAssociation</strong>相当于实例变量，该结构体有两个成员：<strong>_policy</strong> 属性的内存管理语义；<strong>_value</strong> 属性的值</li>
</ol>
<p><img src="/lionheart/1706/association.png" alt="association"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>category可以给既有类添加属性、方法、协议，但是不能添加实例变量</li>
<li>添加属性对应的实例变量可以使用关联对象来实现</li>
<li>category里面的方法不会覆盖原有的同名方法，只是会被提前检索到。所以感官上觉得被覆盖掉了</li>
<li>对于系统自带的类，在runtime时才会加载category；但是自定义类的分类在编译期就已经全部加载了，就像不存在分类，但是存在一个大大的自定义类一样。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/de95ff8230bd" target="_blank" rel="external">Runtime源码 —— Associated Object</a></li>
<li><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></li>
<li><a href="http://www.jianshu.com/p/7ff34885999f" target="_blank" rel="external">Runtime源码 —— 关于category的一个问题</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 属性与方法]]></title>
      <url>/2017/06/05/objective-c-runtime-property-method/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系列第二篇：深入分析OC中的属性与方法的本质。通过上一篇<a href="http://vanney9.com/2017/06/03/objective-c-runtime-class-object/" target="_blank" rel="external">Objective-C runtime - 类和对象</a>，我们了解了objc_class中的 <strong>isa</strong> 成员变量；在这篇文章中，则会详细介绍objc_class的另一成员变量 <strong>bits</strong>。</p>
<a id="more"></a>
<h2 id="bits"><a href="#bits" class="headerlink" title="bits"></a>bits</h2><p>先回忆一下objc_class的结构</p>
<p><img src="/lionheart/1706/bits.png" alt="objc_class"></p>
<p><code>bits</code> 用来存储类的属性，方法，协议等信息。它是一个<code>class_data_bits_t</code>类型</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><pre><code class="c++">struct class_data_bits_t {
    uintptr_t bits;
    // method here
}
</code></pre>
<p>这个结构体只有一个64bit的成员变量<code>bits</code>，先来看看这64bit分别存放的什么信息：</p>
<p><img src="/lionheart/1706/class_bits.png" alt="class_data_bits_t"></p>
<p><code>is_swift</code> : 第一个bit，判断类是否是Swift类</p>
<p><code>has_default_rr</code> ：第二个bit，判断当前类或者父类含有默认的<code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</p>
<p><code>require_raw_isa</code> ：第三个bit， 判断当前类的实例是否需要raw_isa (不是很懂)</p>
<p><code>data</code> ：第4-48位，存放一个指向class_rw_t结构体的指针，该结构体包含了该类的属性，方法，协议等信息。至于为何只用44bit来存放地址，可以参考<a href="http://vanney9.com/2017/06/03/objective-c-runtime-class-object/" target="_blank" rel="external">Objective-C runtime - 类和对象</a></p>
<h3 id="class-rw-t-和-class-ro-t"><a href="#class-rw-t-和-class-ro-t" class="headerlink" title="class_rw_t 和 class_ro_t"></a>class_rw_t 和 class_ro_t</h3><p>先来看看两个结构体的内部成员变量</p>
<pre><code class="c++">struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;
};

struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
};
</code></pre>
<p>可以看出，class_rw_t结构体内有一个指向class_ro_t结构体的指针。</p>
<p>每个类都对应有一个class_ro_t结构体和一个class_rw_t结构体。在编译期间，class_ro_t结构体就已经确定，objc_class中的bits的data部分存放着该结构体的地址。在runtime运行之后，具体说来是在运行runtime的<code>realizeClass</code> 方法时，会生成class_rw_t结构体，该结构体包含了class_ro_t，并且更新data部分，换成class_rw_t结构体的地址。</p>
<p>用两张图来说明这个过程：</p>
<p>类的<code>realizeClass</code>运行之前：</p>
<p><img src="/lionheart/1706/before_bits.png" alt="before runtime"></p>
<p>类的<code>realizeClass</code>运行之后：</p>
<p><img src="/lionheart/1706/after_bits.png" alt="before runtime"></p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，<strong>当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容</strong></p>
<h2 id="属性和实例变量"><a href="#属性和实例变量" class="headerlink" title="属性和实例变量"></a>属性和实例变量</h2><p>现在知道了属性(<strong>property</strong>)存放在class_rw_t中，实例变量(<strong>ivar</strong>)存放在class_ro_t中。下面来看看他们的真实面目。</p>
<p>先看一段代码：</p>
<pre><code class="objective-c">@interface TestOBJ : NSObject {
      NSInteger ivarInt;
}
@property (nonatomic, assign) NSInteger propertyInt;
</code></pre>
<p>这个TestOBJ类有一个实例变量<code>ivarInt</code> 和 一个属性<code>propertyInt</code> 。使用lldb打印出class_ro_t的ivars：</p>
<p><img src="/lionheart/1706/ivars.png" alt="ivars list"></p>
<p>再使用lldb打印出class_ro_t的baseProperties:</p>
<p><img src="/lionheart/1706/properties.png" alt="properties list"></p>
<p>顺便也把class_ro_t的baseMethodList打印出来吧：</p>
<p><img src="/lionheart/1706/methods.png" alt="methods list"></p>
<p>从上面三张lldb的结果可以看出：<strong>TestOBJ类含有2个实例变量，1个属性和2个方法</strong>。但是代码里只有一个实例变量一个属性和0个方法。原因就是声明一个属性的同时，会同时生成一个实例变量和该实例变量的存取方法。</p>
<p>以<code>propertyInt</code>为例：生成了 <code>_propertyInt</code> 实例变量和 <code>- (NSInteger)propertyInt;</code> 以及 <code>- (void)setPropertyInt:(NSInteger)propertyInt</code> 两个存取方法</p>
<h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><p><em>class_ro_t</em>中<em>的baseProperties</em>是一个存放<em>property_t</em>结构体的list。<strong>property_t</strong>结构体用来存放属性的信息</p>
<pre><code class="c++">struct property_t {
    const char *name;
    const char *attributes;
};
</code></pre>
<p>该结构体保存了属性的名字和type encoding。</p>
<h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><p>其实到这里你就会发现<em>property_t</em>结构体中存放的信息没啥用，真正有用的还是存放实例变量的结构体<strong>ivar_t</strong></p>
<pre><code class="c++">struct ivar_t {
    int32_t *offset;
    const char *name;
    const char *type;
    // alignment is sometimes -1; use alignment() instead
    uint32_t alignment_raw;
    uint32_t size;

    uint32_t alignment() const {
        if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT;
        return 1 &lt;&lt; alignment_raw;
    }
};
</code></pre>
<p>以<em>TestOBJ</em>中的 <strong>ivarInt</strong> 实例变量为例来说明，先使用lldb打印该实例变量的详细信息：</p>
<p><img src="/lionheart/1706/ivar_t.png" alt="ivar_t"></p>
<p><code>name</code> : <strong>实例变量的名字</strong> -&gt; ivarInt</p>
<p><code>type</code> : <strong>实例变量的类型，type encoding</strong> -&gt; q 表示int类型 </p>
<p><code>size</code> : <strong>实例变量的内存大小</strong> -&gt; 8 因为int类型占8个字节</p>
<p><code>offset</code> : <strong>实例变量距离对象的首地址的偏移量</strong> -&gt; offset是一个指向int的指针，取出offset指向的int，发现偏移量为8</p>
<p>上图还打印了class_ro_t，里面有2个变量需要注意一下：</p>
<p><code>instanceStart</code> : <strong>对象开始存放实例变量的地址的偏移量</strong> -&gt; 8 因为对象的前8字节存放的是<code>isa_t</code>结构体</p>
<p><code>instanceSize</code> : <strong>对象的大小</strong> -&gt; 24 = isa_t + ivarInt + _propertyInt</p>
<p><strong>所以：获取TestOBJ实例a的ivarInt的过程：取出 对象首地址加ivarInt的偏移量 的内存空间的int</strong></p>
<p><img src="/lionheart/1706/get_ivar.png" alt="get ivar"></p>
<h3 id="类继承关系中的对象的内存空间结构"><a href="#类继承关系中的对象的内存空间结构" class="headerlink" title="类继承关系中的对象的内存空间结构"></a>类继承关系中的对象的内存空间结构</h3><p>先看看没有继承关系的类 TestOBJ：</p>
<p><img src="/lionheart/1706/testObj.png" alt="testObj"></p>
<p>再看看继承TestOBJ的Son类：</p>
<pre><code class="objective-c">@interface Son : TestOBJ
@property (nonatomic, strong) NSString *sonStr
@end
</code></pre>
<p>它的对象既存储了TestOBJ的实例变量，也存放了Son自己的实例变量</p>
<p><img src="/lionheart/1706/son.png" alt="son"></p>
<p>使用lldb打印son的class_ro_t:</p>
<p><img src="/lionheart/1706/super.png" alt="super"></p>
<p>可以发现Son类的 <code>instanceStart</code> 为24，因为Son的实例的前8字节存放isa，后面16字节存放父类的ivarInt和_propertyInt两个int型实例变量。Son类的 <code>instanceSize</code>为32字节，因为他还有自己的一个指向NSString结构体的指针 <strong>_sonStr</strong> ，这个指针也占8字节。</p>
<p>另外<strong>_sonStr</strong> 这一个ivar_t的offset是24，也符合分析</p>
<p>注意Son类的class_ro_t在<code>realizeClass</code>方法完成后就确定下来了</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>编译结束之后，类的方法就已经存储在class_ro_t里面的baseMethodList变量中了；当运行完runtime的<code>realizeClass</code>方法之后，会将baseMethodList拷贝到class_rw_t的<code>methods</code>变量中，并将各种分类的方法拷贝到<code>methods</code>中。<strong>这样类的所有方法就都聚集在class_rw_t的methods变量中了。</strong></p>
<p>使用lldb打印出class_rw_t中的methods:</p>
<p><img src="/lionheart/1706/realmethods.png" alt="methods"></p>
<p>可以看到这里的<code>methods</code>和上面打印出来的class_ro_t中的<code>baseMethodList</code>一模一样。这是因为这个类没有分类，只是简单的将baseMethodList的内容拷贝过去。</p>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>runtime使用<code>method_t</code>结构体来存放方法：</p>
<pre><code class="c++">struct method_t {
    SEL name;
    const char *types;
    IMP imp;

    struct SortBySELAddress :
        public std::binary_function&lt;const method_t&amp;,
                                    const method_t&amp;, bool&gt;
    {
        bool operator() (const method_t&amp; lhs,
                         const method_t&amp; rhs)
        { return lhs.name &lt; rhs.name; }
    };
};
</code></pre>
<p><code>name</code> : 方法名，类型为<code>SEL</code>选择子，可以简单地理解成方法的id，字符串类型</p>
<p><code>types</code> : 方法的type encoding</p>
<p><code>imp</code> : 方法的实现，类型为<code>IMP</code>。IMP是函数指针，指向方法的实现，也就是指向实现该方法的代码区</p>
<h2 id="底层存储方式"><a href="#底层存储方式" class="headerlink" title="底层存储方式"></a>底层存储方式</h2><pre><code class="c++">struct class_rw_t {
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;
};

struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
};
</code></pre>
<p>class_ro_t里面的<code>method_list_t</code> 和 <code>ivar_list_t</code> 都是 <code>entsize_list_tt</code> 的结构体；class_rw_t里面的 <code>method_array_t</code> 和 <code>property_array_t</code> 都是 <code>list_array_tt</code> 的结构体。来看看这个底层存储方式</p>
<h3 id="entsize-list-tt"><a href="#entsize-list-tt" class="headerlink" title="entsize_list_tt"></a>entsize_list_tt</h3><pre><code class="c++">template &lt;typename Element, typename List, uint32_t FlagMask&gt;
struct entsize_list_tt {
    uint32_t entsizeAndFlags;
    uint32_t count;
    Element first;
      // other code
}
</code></pre>
<p>一个存储Element的序列，可以使用<code>get(index)</code>方法获取特定index的Element；它也提供了iterator遍历器，具体实现细节可以查看代码。<code>objc-runtime-new.h</code></p>
<h3 id="list-array-tt"><a href="#list-array-tt" class="headerlink" title="list_array_tt"></a>list_array_tt</h3><pre><code class="c++">template &lt;typename Element, typename List&gt;
class list_array_tt {
    private:
    union {
        List* list;
        uintptr_t arrayAndFlag;
    };
}
</code></pre>
<p>简单来说是一个存放<code>entsize_list_tt</code>的数组。也提供了iterator遍历器。也定义在<code>objc-runtime-new.h</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这篇文章就是👇两篇参考文章的一个合体。总结来说：objc_class结构体中的bits成员变量存放着类的属性、方法、协议等信息。这一些信息，有的是在编译期间就确定的；另外一些则是在运行runtime的<code>realizeClass</code>的方法时添加上去的。</p>
<p>那么当runtime将类初始化之后，所有的类所需的信息都存放在了<strong>class_rw_t</strong>结构体中</p>
<h2 id="fixme"><a href="#fixme" class="headerlink" title="fixme"></a>fixme</h2><p><strong>在这里做个更正：</strong>在<code>realizeClass</code>方法中，并不是将<code>class_ro_t</code>中的属性、方法的list拷贝到<code>class_rw_t</code>中；而只是通过<code>class_rw_t</code>来操作<code>class_ro_t</code>中的各种list。<code>class_rw_t</code>中的<code>list_array_tt</code> 有指向 <code>class_ro_t</code>中的 <code>entsize_list_tt</code> 的指针。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/89ac27684693" target="_blank" rel="external">Runtime源码 —— property和ivar</a></li>
<li><a href="http://draveness.me/method-struct.html" target="_blank" rel="external">深入解析 ObjC 中方法的结构</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 类和对象]]></title>
      <url>/2017/06/03/objective-c-runtime-class-object/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OC是一门面向对象的语言，这篇文章先来看看OC的类和对象(<strong>Class &amp;&amp; Object</strong>)</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol>
<li>OC中的对象本质上是一个<strong>objc_object</strong>结构体</li>
<li>OC中的类本质上是一个<strong>objc_class</strong>结构体</li>
<li><strong>id</strong>：指向objc_object的结构体指针</li>
<li><strong>Class</strong>：指向objc_class的结构体指针</li>
</ol>
<h3 id="objc-class-和-objc-object"><a href="#objc-class-和-objc-object" class="headerlink" title="objc_class 和 objc_object"></a>objc_class 和 objc_object</h3><p>先来看看两个结构体的结构（先只考虑结构体的成员变量，不考虑它的成员函数）</p>
<pre><code class="c++">struct objc_object {
private:
    isa_t isa;
public:
    // function here
}

struct objc_class : objc_object {
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;
      // method here
}
</code></pre>
<p><strong>objc_struct</strong> 定义在 <code>objc-private.h</code> 里面，该结构体只包含一个叫做 isa 的isa_t类型的变量</p>
<p><strong>objc_class</strong> 定义在 <code>objc-runtime-new.h</code> 里面，它继承自objc_object，所以除了isa成员变量之外，它还有：</p>
<ol>
<li>指向另一个objc_class结构体的指针 <strong>super_class</strong>；这一个objc_class包含了父类的信息</li>
<li>一个包含函数缓存的cache_t类型变量 <strong>cache</strong></li>
<li>一个包含类的方法，属性等信息的class_data_bits_t类型的变量 <strong>bits</strong></li>
</ol>
<p>编译结束之后，OC的每个类都是以objc_class的结构体形式存在于内存之中，而且在内存中的位置已经固定。运行期间，创建新的对象的时候，也是创建objc_object的结构体</p>
<h3 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h3><p>成员变量isa包含了该对象，或者该类的信息。isa变量的类型是<strong>isa_t</strong>，定义在<code>objc_private.h</code></p>
<pre><code class="c++">union isa_t 
{
    Class cls;
    uintptr_t bits;

#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x001f800000000001ULL
#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
    struct {
        uintptr_t nonpointer        : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 8;
#       define RC_ONE   (1ULL&lt;&lt;56)
#       define RC_HALF  (1ULL&lt;&lt;7)
    };
}
</code></pre>
<p>ps ： 以上代码是在x86_64上的实现（Mac上面）；iPhone（arm64等）上面的实现大同小异。具体实现可以参见runtime源码</p>
<h4 id="has-assoc"><a href="#has-assoc" class="headerlink" title="has_assoc"></a>has_assoc</h4><p>表示该对象是否有关联对象</p>
<h4 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a>has_cxx_dtor</h4><p>表示是否有析构函数</p>
<h4 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a>shiftcls</h4><p>表示对象所属的类或者类所属的元类(meta class)的地址，也就是指向一个objc_class的指针，不过该指针只有44位。</p>
<p>64位系统的指针占用64bit的内存，但是使用整个指针大小来存储地址有点浪费。在mac的64位系统上面，使用47位作为指针，其他的17位用于其他目的（iPhone上面只使用33位）。又由于所有对象按照字节（8bit）对齐，所以指针都是能被8整除的，也就是后3bit均为0；所以类指针的实际有效位数为 <code>47 - 3 = 44</code> 位。这也是shiftcls只有44位的原因</p>
<h4 id="isa初始化"><a href="#isa初始化" class="headerlink" title="isa初始化"></a>isa初始化</h4><p>在创建新的objc_object的时候，会使用objc_object的成员函数<code>initIsa</code>来初始化isa变量</p>
<pre><code class="c++">inline void 
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
    initIsa(cls, true, hasCxxDtor);
}

inline void 
objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) 
{ 
    if (!indexed) {
        isa.cls = cls;
    } else {
        isa.bits = ISA_MAGIC_VALUE;
        isa.has_cxx_dtor = hasCxxDtor;
        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
    }
}
</code></pre>
<p>这里的<strong>indexed</strong>用来标记isa是否有结构体部分：</p>
<ol>
<li>如果indexed为0，没有结构体部分，直接将对象所属的类的地址赋予cls变量</li>
<li>如果indexed为1，有结构体部分，先使用<code>ISA_MAGIC_VALUE</code> 给isa这个64位union初始化，然后在对64位上的每一位单独设置。比如设置是否含有析构函数(<em>has_cxx_dtor</em>)，设置对象所属类的地址(<em>shiftcls</em>)。注意这里设置类地址的时候是将cls右移3位，再赋值给shiftcls的，原因就是类地址的最后3bit没有实际作用</li>
</ol>
<h4 id="isa-方法"><a href="#isa-方法" class="headerlink" title="isa()方法"></a>isa()方法</h4><p>该方法用来获取对象所属的类的指针，也就是表示该对象是一个什么类</p>
<pre><code class="c++">inline Class 
objc_object::ISA() 
{
    return (Class)(isa.bits &amp; ISA_MASK);
}
// #define ISA_MASK 0x00007ffffffffff8ULL
</code></pre>
<p>返回的是一个64位的指向objc_class结构体的指针，其中的4-47bit为shiftcls的值，其他bit都是0</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OC的对象和类在内存中都是以结构体的形式存在的，类对应objc_class结构体，对象对应objc_object结构体。</p>
<p>在创建这两种结构体的过程中都会初始化isa变量。isa变量存放着对象所属的类的信息，或者类所属的元类的信息。关于元类的相关内容，可自行google。</p>
<p>另外，在创建objc_class的结构体的时候还会初始化相应的cache和bits变量，在后续的章节中将会说道</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://draveness.me/isa.html" target="_blank" rel="external">从 NSObject 的初始化了解 isa</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C runtime - 系列开始]]></title>
      <url>/2017/06/03/objective-c-runtime-summarize/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习OC的runtime也有一段时间了，是时候写个runtime的系列来做个总结了。大体按照以下几个主题：</p>
<ol>
<li><a href="http://vanney9.com/2017/06/03/objective-c-runtime-class-object/" target="_blank" rel="external">Class &amp;&amp; Object</a></li>
<li><a href="http://vanney9.com/2017/06/05/objective-c-runtime-property-method/" target="_blank" rel="external">Property &amp;&amp; Method</a></li>
<li><a href="http://vanney9.com/2017/06/07/objective-c-runtime-category/" target="_blank" rel="external">Category &amp;&amp; Association Object</a></li>
<li><a href="http://vanney9.com/2017/06/08/objective-c-runtime-message/" target="_blank" rel="external">Message</a></li>
<li><a href="http://vanney9.com/2017/06/09/objective-c-runtime-api/" target="_blank" rel="external">上层API</a></li>
<li><a href="http://vanney9.com/2017/06/10/objective-c-runtime-example/" target="_blank" rel="external">runtime应用示例 &amp;&amp; 奇奇怪怪的例子</a></li>
<li><a href="http://vanney9.com/2017/06/10/objective-c-runtime-other/" target="_blank" rel="external">如果还有其他的话</a></li>
</ol>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说是概述，其实是我学习runtime的过程。</p>
<ol>
<li><p>苹果官方的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">runtime文档</a>，对runtime是什么，用来做什么了解个大概</p>
</li>
<li><p>拿到了runtime的源码，<a href="http://blog.csdn.net/wotors/article/details/54426316" target="_blank" rel="external">据说能编译成objc的动态库</a>，并且新建一个使用自己编译的runtime的mac的工程</p>
</li>
<li><p>按原计划，到了这一步就该自己对着runtime的源码，修修改改，看看能弄出什么奇怪的效果。但是这才发现，要是重头开始一行一行的看runtime源码，是多么浩大的一项工程。。</p>
</li>
<li><p>改变策略，抓住runtime的重点，从博客看起，逐个弄懂。在这一过程中发现了2个人的博客</p>
<ol>
<li><a href="http://www.jianshu.com/u/43bb8b1a9d39" target="_blank" rel="external">Haven_ZN</a></li>
<li><a href="http://draveness.me/" target="_blank" rel="external">Draveness</a></li>
</ol>
<p>这两位大神的博客里面都有一系列的关于runtime的源码的详解，受益匪浅。</p>
</li>
<li><p>在研究runtime源码的时候还需要使用lldb进行debug，<a href="https://objccn.io/issue-19-2/" target="_blank" rel="external">与调试器共舞 - LLDB 的华尔兹</a> 这篇文章介绍了lldb的debug方法</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">runtime官方文档</a></li>
<li><a href="http://blog.csdn.net/wotors/article/details/54426316" target="_blank" rel="external">objc - 编译Runtime源码objc4-706</a></li>
<li><a href="http://draveness.me/" target="_blank" rel="external">Draveness的主页</a></li>
<li><a href="http://www.jianshu.com/u/43bb8b1a9d39" target="_blank" rel="external">Haven_ZN的主页</a></li>
<li><a href="https://objccn.io/issue-19-2/" target="_blank" rel="external">与调试器共舞 - LLDB 的华尔兹</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 对象、消息、运行期]]></title>
      <url>/2017/04/13/effective-objective-c-reading-note-six/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Effective Objective-C 2.0</strong> 系列读书笔记最后一篇</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="理解“属性”这一概念"><a href="#理解“属性”这一概念" class="headerlink" title="理解“属性”这一概念"></a>理解“属性”这一概念</h3><ol>
<li><p>下面两部分代码等效</p>
<pre><code class="objective-c">@interface EOCPerson : NSObject
@property NSString *firstName;
@end

@interface EOCPerson : NSObject {
      NSString *_firstName;
}
- (NSString *)firstName;
- (void)setFirstName:(NSString *)firstName;
@end
</code></pre>
<p>可以理解成：属性 = 实例变量 + 存取方法</p>
</li>
<li><p>可以改变属性生成的实例变量的名字：</p>
<pre><code class="objective-c">@implementation EOCPerson
@synthesize firstName = _myFirstName;
@end
</code></pre>
<p>将实例变量命名成<code>_myFirstName</code> ，不再使用默认的名字</p>
</li>
<li><p>当然还可以不让编译器自动生成存取方法，就是使用dynamic</p>
<pre><code class="objective-c">@implementation EOCPerson
@dynamic firstName;
@end
</code></pre>
<p>此时不会自动生成存取方法，也不会自动创建实例变量。在编译访问属性的代码时，也不会出错，因为编译器相信能在运行期找到对应的方法</p>
</li>
<li><p>具备<strong>readonly</strong>特性的属性仅拥有获取方法，只有当该属性由<code>@synthesize</code>实现时，编译器才会为其合成获取方法</p>
</li>
<li><p><strong>拥有与非拥有</strong> 是针对指针与内存空间来说的：</p>
<pre><code class="objective-c">@property (nonatomic, strong) NSString *strPointer;
</code></pre>
<p>上面的语句说明：有一个NSString指针，如果他指向一块存放NSString的内存，那么strPointer指针拥有该内存。该内存的reference count加1</p>
</li>
<li><p><strong>copy</strong> 对于NSString来说特别有用，特别是在NSString和NSMutableString之间转换的时候。需要注意的是在初始化方法中，初始化该属性也要使用copy方法</p>
<pre><code class="objective-c">- (id)initWithFirstName:(NSString *)firstName {
      if (self = [super init]) {
          _firstName = [firstName copy];
      }
      return self;
}
</code></pre>
</li>
<li><p>不应该在init方法中调用存取方法。</p>
</li>
<li><p>iOS中的同步锁性能开销较严重，所以一般使用的<strong>nonatomic</strong>属性</p>
</li>
</ol>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><ol>
<li>直接访问实例变量和通过存取方法来访问的区别<ol>
<li>直接访问不经过方法派发，速度更快</li>
<li>直接访问时不会经过设置方法，绕过了内存管理语义。例如：在ARC下直接方法一个copy属性，那么不会拷贝该值，只会retain</li>
<li>直接访问不会触发KVO</li>
</ol>
</li>
<li>折中的方案：设置时使用设置方法，读取时直接访问</li>
</ol>
<h3 id="理解“对象等同性”这一概念"><a href="#理解“对象等同性”这一概念" class="headerlink" title="理解“对象等同性”这一概念"></a>理解“对象等同性”这一概念</h3><ol>
<li>应该使用NSObject协议中的<code>isEqual</code>方法来判断对象的等同性。可以对象自己实现<code>isEqual</code>来精确判断</li>
<li>当然对于特殊的对象可以使用更精确的方法</li>
</ol>
<h3 id="以“类族模式”隐藏实现细节"><a href="#以“类族模式”隐藏实现细节" class="headerlink" title="以“类族模式”隐藏实现细节"></a>以“类族模式”隐藏实现细节</h3><ol>
<li>UIButton有一个类方法：<code>+ (UIButton *)buttonWithType:(UIButtonType)type;</code> 该方法返回的对象类型根据type不同而不同，但是基类都是UIButton</li>
<li>类族的基类一般没有 init 方法，提示用户：这种类不需要用户自己去创建。</li>
<li>调用<code>isMemberOfClass:</code>的时候不会返回YES，因为不是UIButton，只是它的子类</li>
<li>NSArray就是类族</li>
</ol>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3>]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 系统框架]]></title>
      <url>/2017/04/11/effective-objective-c-reading-note-five/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>NSObject</strong> 属于 <strong>Foundation</strong> 框架，我们写的OC代码全部都是基于这些基本系统框架之上的</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="熟悉系统框架"><a href="#熟悉系统框架" class="headerlink" title="熟悉系统框架"></a>熟悉系统框架</h3><ol>
<li>将一系列代码封装为动态库，并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。所有iOS平台的系统框架都是动态库</li>
<li>NS开头的基本都是Foundation框架，与Foundation框架对应的一个CoreFoundation框架，他是C语言的API</li>
<li>使用toll-free bridging可以实现Foundation的OC对象和CoreFoundation的C数据结构互相转换</li>
<li>使用C语言的API可以绕过OC的runtime机制，加快运行速度；但是使用C语言的API时，需要注意内存管理的问题</li>
</ol>
<h3 id="多用块枚举，少用for循环"><a href="#多用块枚举，少用for循环" class="headerlink" title="多用块枚举，少用for循环"></a>多用块枚举，少用for循环</h3><ol>
<li><p>使用OC1.0的 <strong>NSEnumerator</strong> 来遍历</p>
<pre><code class="objective-c">NSArray *array = /*...*/;
NSEnumerator *enumerator = [array objectEnumerator];
id object;
while ((object = [enumerator nextObject]) != nil) {
      // do something
}

NSDictionary *dict = /*...*/;
NSEnumerator *enum = [dict keyEnumerator];
id key;
while ((key = [enum nextObject]) != nil) {
      id value = dict[key];
      // do something
}
</code></pre>
</li>
<li><p>框架还提供反向遍历的enum接口</p>
</li>
<li><p>使用OC2.0的 <strong>快速遍历</strong> ，也就是<strong>for in</strong></p>
</li>
<li><p>基于块的遍历方式，对于NSArray有<code>-(void)enumerateObjectsUsingBlock:(void(^)(id object, NSUinteger idx, BOOL *stop))block;</code> ；其他的collection也有相对应的方法。使用block方法，可以获取更多的信息</p>
</li>
</ol>
<h3 id="对自定义其内存管理语义的collection使用无缝桥接"><a href="#对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="对自定义其内存管理语义的collection使用无缝桥接"></a>对自定义其内存管理语义的collection使用无缝桥接</h3><ol>
<li><p>使用无缝桥接来转换Foundation和CoreFoundation</p>
<pre><code class="objective-c">NSArray *array = @[@1， @2， @3]；
CFArrayRef aCFArray = (__bridge CFArrayRef)array;
</code></pre>
</li>
<li><p>__bridge 还有疑问</p>
</li>
<li><p>NSDictionary 对于key是copy，对于value则是retain。要想改变期内存语义的话呢，只能使用CoreFoundation了，具体的看书~</p>
</li>
</ol>
<h3 id="构建缓存时选用NSCache而非NSDictionary"><a href="#构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="构建缓存时选用NSCache而非NSDictionary"></a>构建缓存时选用NSCache而非NSDictionary</h3><ol>
<li>NSCache在系统低内存时会自动删减缓存，而且优先删减的是最长时间没有使用过的缓存</li>
<li>NSCache的key是retain的，不是copy的。因为很多时候，这个key的对象不支持copy</li>
<li>线程安全，这点对于缓存来说很关键</li>
</ol>
<h3 id="精简initialize与load的实现代码"><a href="#精简initialize与load的实现代码" class="headerlink" title="精简initialize与load的实现代码"></a>精简initialize与load的实现代码</h3><ol>
<li><code>+ (void)load;</code> 每个类必定会调用该方法，而且仅调用一次。当包含类的程序库载入系统时，就会执行此方法，也就是<strong>程序启动</strong>的时候</li>
<li>如果分类和类都定义了load方法，那么先调用类的，再调用分类的</li>
<li>在执行类的的load之前，会先执行多有超类的load方法</li>
<li>load方法和其他不一样，如果子类没有实现的话，不管超类有没有，他都不会继承该方法</li>
<li>load方法要精简，程序在执行没有load方法的时候都会阻塞</li>
<li>尽量不要使用load方法</li>
<li><code>+ (void)initialize;</code> 在程序第一次使用这个类的时候，会调用该方法。它也只会运行一次。不应该由代码来显式调用。</li>
<li>initialize只有在程序用到该类的时候才会调用，属于惰性调用；它由运行期系统来调用。调用它的时候，系统中的个各类都是可以正常使用的，这一点和load方法不同</li>
</ol>
<h3 id="别忘了NSTimer会保留其目标对象"><a href="#别忘了NSTimer会保留其目标对象" class="headerlink" title="别忘了NSTimer会保留其目标对象"></a>别忘了NSTimer会保留其目标对象</h3>]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 块与大中枢派发]]></title>
      <url>/2017/04/04/effective-objective-c-reading-note-four/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Effective Objective C</strong> 读书笔记 - 块与大中枢派发</p>
<p><strong>多线程的两大核心：block，GCD</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="理解“块”这以概念"><a href="#理解“块”这以概念" class="headerlink" title="理解“块”这以概念"></a>理解“块”这以概念</h3><ol>
<li><p>block其实也是一个数据类型，块也是对象类型</p>
<pre><code class="objective-c">void (^someBlock)() = ^{
      // do something here
}
</code></pre>
</li>
<li><p>块的强大之处在于：在声明块的范围里面，所有的变量都可以为其所捕获，在快内可以使用这些变量</p>
</li>
<li><p>在Block之前，只能使用函数指针或者是selector</p>
</li>
<li><p>每个OC对象都占有一个内存区域，块也是对象，下图就是块的内存区域：</p>
<p><img src="/lionheart/1704/blockmemory.JPG" alt="block memory"></p>
<ol>
<li><strong>invoke</strong> 是函数指针，指向块的实现代码</li>
<li><strong>descriptor</strong> 是一个结构体指针，每个block都有这么一个变量，该结构体包含了块的详细信息：大小等等</li>
<li>块还会把 <strong>捕获到的变量</strong> 拷贝一份，注意这里拷贝的是指针</li>
</ol>
</li>
<li><p>定义块的时候，块所占的内存是分配在栈中的，来看看下面的例子</p>
<pre><code class="objective-c">void (^block)(); // 声明一个block，是一个指针
if (/* some condition */) {
      block = ^{
          // do something
      }
} else {
      block = ^{
          // do something
      }
}
block();
</code></pre>
<p>注释：在if和else中，分别创建了block，这个block是一个栈对象，也就是他们的内存是在栈上面的；然后<strong>将该栈内存的首地址赋予block</strong>。但是这个对象出了<code>{}</code> ，其内存可能被覆写，那么block变量指向的就不是一个真正的块了</p>
<p><strong>注意，这里的block是一个指针；和一般的int理解上有所不同</strong></p>
<pre><code class="objective-c">int a;
if (/* some condition */) {
      int tmp = 2;
      a = tmp;
} else {
      int tmp = 3;
      a = tmp;
}
</code></pre>
<p>这里tmp的内存在出了<code>{}</code>之后也是会被覆写的，但是在<code>{}</code>里面，直接将tmp的内存中的值写到了a的内存中，所以a还是可以使用的。<strong>但是，写到block内存中的是这个栈对象的地址，地址还是可以使用的，但是地址里面的内容就不一定是原来的块对象了</strong></p>
<p>至于，栈和堆的区别可以看看 <a href="http://ios.jobbole.com/81900/" target="_blank" rel="external">Objective-C 拾遗：从Heap and Stack到Block</a> 这篇文章</p>
</li>
<li><p>所以为了避免在栈上的块对象被销毁，就得使用<code>copy</code>方法了。block的<code>copy</code>方法将block从栈拷贝到堆上面，那么这个时候的block就和正常的OC对象一样了，具备引用计数，可以使用ARC来管理了</p>
</li>
<li><p>5和6分别讲述了 <strong>栈块</strong> 和 <strong>堆块</strong> 的区别，还有一种块，叫做 <strong>全局块</strong> 。这种block不会捕捉外部变量，它的内存在全局内存中，而且对他执行copy操作也只是空操作，类似一个函数</p>
</li>
</ol>
<h3 id="为常用的块类型创建typedef"><a href="#为常用的块类型创建typedef" class="headerlink" title="为常用的块类型创建typedef"></a>为常用的块类型创建typedef</h3><ol>
<li><p>定义块变量是非常不符合常理，不好记住，所以要使用 <strong>typedef</strong></p>
<pre><code class="objective-c">typedef int (^EOCSomeBlock)(BOOL flag, int value);
EOCSomeBlock block = ^(BOOL flag, int value) {
      // block implememtation
};
</code></pre>
<p>上面的EOCSomeBlock表示 <strong>接受2个参数，并返回int的block类型</strong></p>
</li>
</ol>
<h3 id="用handler块降低代码分散程度"><a href="#用handler块降低代码分散程度" class="headerlink" title="用handler块降低代码分散程度"></a>用handler块降低代码分散程度</h3><ol>
<li>也就是使用block来代替delegate</li>
<li>还可以同时使用多个block，来处理success或者fail的情况</li>
</ol>
<h3 id="用块引用其所属对象时不要出现保留环"><a href="#用块引用其所属对象时不要出现保留环" class="headerlink" title="用块引用其所属对象时不要出现保留环"></a>用块引用其所属对象时不要出现保留环</h3><h3 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h3><ol>
<li><p><code>dispatch_sync(queue, block);</code> 等待block执行完，再执行后面的语句；<code>dispatch_async(queue, block);</code> 不等待block执行完，立刻执行后续语句。具体参考<a href="http://blog.csdn.net/zhangping871/article/details/44098773" target="_blank" rel="external">dispatch_async 和 dispatch_sync 的区别</a></p>
</li>
<li><p>来个例子说明一下：</p>
<pre><code class="objective-c">_syncQueue = dispatch_queue_create(&quot;com.vanney9.queue&quot;, NULL);

- (NSString *)someString {
      __block NSString *localSomeString;
      dispatch_sync(_syncQueue, ^{      // 1
          localSomeThing = _someString;
      });
      return localSomeString;   // 2
}

- (void)setSomeString:(NSString *)someString {
      dispatch_async(_syncQueue, ^{    // 3
          _someString = someString;
      });
      return;    // 4
}
</code></pre>
<ol>
<li>get方法使用同步派发(<strong>dispatch_sync</strong>)：因为必须等待block执行完，才能返回localString，如果使用异步派发(<strong>dispatch_async</strong>)的话，block还没有执行，也就是localString还没有设置，就返回了，那么就返回空值了。。</li>
<li>set方法使用异步派发，因为不需要等待block执行完</li>
</ol>
</li>
<li><p>上面的例子使用的queue都是串行队列，也就是必须等待注册到该序列中的前面的block执行完了，才能执行自己的bloc；但是对于读操作来说是可以并行的，只要写操作和其他的操作串行化就可以了。所以可以使用 <strong>并行序列+栅栏</strong> 来实现</p>
<pre><code class="objective-c">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 1
- (NSString *)someString {
      __block NSString *localSomeString;
      dispatch_sync(_syncQueue, ^{  // 2
          localSomeString = _someString;
      });
      return localSomeString;
}

- (void)setSomeString:(NSString *)someString {
      dispatch_barrier_async(_syncQueue, ^{  // 3
          _someString = somString;
      });
}
</code></pre>
<p>注释1：创建了一个并发队列</p>
<p>注释2：使用并发队列，可以同时执行get方法</p>
<p>注释3：使用栅栏技术，让写操作执行的时候，队列中的其他操作无法执行</p>
</li>
</ol>
<h3 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h3><ol>
<li><p>先来说说<code>performSelector</code>方法</p>
<pre><code class="objective-c">SEL selector;
if (/* some condition*/) {
      selector = @selector(foo);
}  else {
      selector = @selector(bar);
}
[object performSelector:selector];
</code></pre>
<p>动态绑定之上再动态绑定</p>
</li>
<li><p>为什么不推荐使用呢？因为该方法返回的是id类型，也就是一个指向任意OC对象的指针（在32位架构上占32位，4字节；在64位架构上占64位，8字节）。但是如果selector方法返回int，float等类型时就不好转换了</p>
</li>
<li><p>使用GCD可以实现：延迟执行，选择特定线程执行</p>
</li>
</ol>
<h3 id="掌握GCD及操作队列的使用时机"><a href="#掌握GCD及操作队列的使用时机" class="headerlink" title="掌握GCD及操作队列的使用时机"></a>掌握GCD及操作队列的使用时机</h3><ol>
<li>还有一整多线程机制：<strong>NSOperationQueue + NSOperation</strong> 也就是<strong>操作队列</strong>， 它也可以实现和GCD相同的功能。其中NSOperationQueue类似GCD；而NSOperation类似block</li>
<li>操作队列对比GCD的优点：<ol>
<li>可以取消尚未开始执行的NSOperation</li>
<li>可以指定操作间的依赖关系：可以指定当前的NSOperation在某个NSOperation执行结束后，才开始执行</li>
<li>NSOperation的许多属性适合KVO，通过监听可以更粒子化的监控NSOperation</li>
<li>可以指定NSOperation的优先级：GCD的优先级是针对队列之间的；但是操作队列的优先级是针对NSOperation的，也就是同一队列里面的block的优先级。当然，操作队列也有线程间的优先级</li>
</ol>
</li>
</ol>
<h3 id="通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="通过Dispatch Group机制，根据系统资源状况来执行任务"></a>通过Dispatch Group机制，根据系统资源状况来执行任务</h3><ol>
<li>使用 <strong>dispatch group</strong> 机制可以将任务分组。调用者可以等待这组任务执行完毕；也可以给直接提供回调函数，立刻进行下面的步骤</li>
<li>这个特性最重要的一点用途就是：把将要并发执行的多个任务合并为一组，那么就可以知道这些任务什么时候全部执行完毕</li>
<li><code>dispatch_group_wait</code> 和 <code>dispatch_group_notify</code> 两个函数可以用来执行结束后该做什么，具体参见 <a href="http://vanney9.com/2016/08/02/OC-ARC-GCD-reading-note-three/" target="_blank" rel="external">iOS与OS X多线程和内存管理 - GCD</a></li>
<li>使用并发队列进行多线程任务时，系统会根据当时的情况自动分配线程，无须码农自己来调度</li>
</ol>
<h3 id="使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="使用dispatch_once来执行只需运行一次的线程安全代码"></a>使用dispatch_once来执行只需运行一次的线程安全代码</h3><ol>
<li><p>这个常用于单例模式</p>
</li>
<li><p>example：</p>
<pre><code class="objective-c">+ (id)sharedInstance {
      static ECOClass *sharedInstanced = nil;
      static dispatch_once_t onceToken;
      dispatch_once(&amp;onceToken, ^{
          sharedInstance = [[self alloc] init];
      });
      return sharedInstance;
}
</code></pre>
<p>在函数中的static变量：只在函数中可见，但是其生命期为整个程序。具体见 <a href="http://stackoverflow.com/questions/5033627/static-variable-inside-of-a-function-in-c" target="_blank" rel="external">Static variable inside of a function in C</a></p>
</li>
</ol>
<h3 id="不要使用-dispatch-get-current-queue"><a href="#不要使用-dispatch-get-current-queue" class="headerlink" title="不要使用 dispatch_get_current_queue"></a>不要使用 dispatch_get_current_queue</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://ios.jobbole.com/81900/" target="_blank" rel="external">Objective-C 拾遗：从Heap and Stack到Block</a></li>
<li><a href="http://blog.csdn.net/zhangping871/article/details/44098773" target="_blank" rel="external">dispatch_async 和 dispatch_sync 的区别</a></li>
<li><a href="http://vanney9.com/2016/08/02/OC-ARC-GCD-reading-note-three/" target="_blank" rel="external">iOS与OS X多线程和内存管理 - GCD</a></li>
<li><a href="http://stackoverflow.com/questions/5033627/static-variable-inside-of-a-function-in-c" target="_blank" rel="external">Static variable inside of a function in C</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Auto Layout 与 CAKeyframeAnimation]]></title>
      <url>/2017/03/30/iOS-Auto-Layout-CAKeyframeAnimation/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近实现了一个基于Auto Layout的CAKeyframeAnimation。先来看一下效果👇</p>
<p><img src="/lionheart/1703/animate.gif" alt="animate.gif"></p>
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>看了效果图，第一反应应该是使用 <strong>CAKeyframeAnimation</strong>，让两个圆型view的position随着图中的贝塞尔曲线(<strong>CGPath</strong>)运动。</p>
<p>那么问题来了：整个视图是使用 <strong>Auto Layout</strong> 来实现的，并没有指定每个视图的frame，我们是否可以使用CAKeyframeAnimation呢？这就引出了下面要讲的几点👇</p>
<ol>
<li><strong>Auto Layout</strong>的本质</li>
<li>普通的基于<strong>Auto Layout</strong> 的动画</li>
<li>在<strong>Auto Layout</strong>视图中获取<strong>frame</strong></li>
<li><strong>CATransaction</strong> 与 <strong>CAKeyframeAnimation</strong></li>
<li><strong>Auto Layout</strong> 百分比布局</li>
</ol>
<h2 id="Auto-Layout-的本质"><a href="#Auto-Layout-的本质" class="headerlink" title="Auto Layout 的本质"></a>Auto Layout 的本质</h2><p><a href="http://vanney9.com/2017/03/24/something-about-iOS-drawing/" target="_blank" rel="external">关于iOS Drawing</a> 这篇文章里面讲述了 <strong>iOS系统将View显示在屏幕上的6个详细步骤</strong>。这里说一下前面3个步骤：</p>
<ol>
<li><strong>Layout</strong>：将一个或者多个UIView（也就是<strong>UIView hierarchy</strong>）显示在屏幕上的第一步就是 <strong>计算每个layer的frame</strong>。无论代码使用<strong>Auto Layout</strong> 还是 <strong>Auto Resizing</strong> 还是直接指定了View的frame，iOS都会计算出每个layer的frame。</li>
<li><strong>Display</strong>：此时已经知道每个Layer的frame，这一步会执行<code>-drawRect:</code>方法，执行custom的绘制，生成layer的backing image。</li>
<li><strong>Prepare</strong>：这一步开始准备每个<strong>Animation</strong>的属性，比如要动画的layer属性，以及终止值等等。</li>
</ol>
<p><strong>划重点啦：</strong></p>
<ol>
<li><strong>Auto Layout虽然没有指定frame，但是iOS会根据这些约束，在内部算出layer的frame。所以Auto Layout的本质也就是指定每个View的frame</strong></li>
<li><strong>在计算出每个layer的frame属性时，才开始准备Animation的参数。所以不存在基于Auto Layout的动画；指定动画属性时，还是指定与view的frame相关的属性</strong></li>
</ol>
<h2 id="普通的基于-Auto-Layout-的动画"><a href="#普通的基于-Auto-Layout-的动画" class="headerlink" title="普通的基于 Auto Layout 的动画"></a>普通的基于 Auto Layout 的动画</h2><p><a href="http://stackoverflow.com/questions/12622424/how-do-i-animate-constraint-changes" target="_blank" rel="external">How do I animate constraint changes?</a> 这个stackoverflow的问题探讨了如何通过改变约束来使视图动画</p>
<pre><code class="objective-c">- (void)moveBannerOffScreen {
      [self.view layoutIfNeeded]; // 0
    _addBannerDistanceFromBottomConstraint.constant = -32;  // 1
      // [sel.view layoutIfNeeded]; // 注释3
    [UIView animateWithDuration:5
        animations:^{
            [self.view layoutIfNeeded]; // 2
        }];
}
</code></pre>
<p>注释0：<strong>先强行计算出每个view的动画开始前的frame</strong></p>
<p>注释1：先更改约束条件，也就是指定动画结束之后，UIView该显示的位置。<strong>但是此时并没有计算出view的最终的frame</strong></p>
<p>注释2：<strong>先记录动画初始位置</strong>；然后在动画中执行<strong>layoutIfNeeded</strong>，强行执行Layout步骤，计算出每个view的结束位置的frame，也就是动画的终止的frame</p>
<p>注释3：如果在这里执行<code>layoutIfNeeded</code>的话，就会强行计算出每个view的最终的frame，那么动画会将该frame记为初始位置。那么<strong>初始位置和结束位置相同，直接跳到最终的位置</strong></p>
<p>可以这么理解：执行完这一个函数后，开始下一帧的绘制；这个时候真实的view已经绘制在最终该显示的位置了，但是被屏幕最上方的Animation的view给遮挡了；这个Animation View从上一帧的状态开始，动画到最终的位置（有待商榷）</p>
<pre><code class="objective-c">// 相对比的UIView animate
{
      view.center = pointA; // 此时已经改变了view的frame，**计算动画的初始位置**
      [UIView animateWithDuration:0.5 animations:^{
          view.center = pointB; // 计算view的最终frame， **计算动画的结束位置**
      }];
}
</code></pre>
<h2 id="在Auto-Layout-视图中获取bound"><a href="#在Auto-Layout-视图中获取bound" class="headerlink" title="在Auto Layout 视图中获取bound"></a>在Auto Layout 视图中获取bound</h2><p>说说方法：</p>
<ol>
<li>设要获取frame的视图为a，新建一个a的子视图b，使用Auto Layout将b的四边与a对齐</li>
<li>重写b的<code>-drawRect:</code>方法，获取rect的宽高，也就是b的bound</li>
<li>调用b的<code>setNeedsDisplay</code>方法，该方法会调用<code>-drawRect:</code>方法，从而获取b的bound</li>
</ol>
<p><strong>因为在调用<code>-drawRect:</code>的时候，每个视图的frame已经确定了，那么方法中的rect也就是该视图的bound</strong></p>
<p><strong>还有一种更简单的方法：调用View的<code>layoutIfNeeded</code>方法，会立即重新计算每个view的frame</strong></p>
<h2 id="CATransaction-与-CAKeyframeAnimation"><a href="#CATransaction-与-CAKeyframeAnimation" class="headerlink" title="CATransaction 与 CAKeyframeAnimation"></a>CATransaction 与 CAKeyframeAnimation</h2><p><strong>在这里详细说一下效果图的实现</strong>：</p>
<ol>
<li><p>图中的曲线使用UIBezier来画，那么就需要确定的坐标点，也就是需要知道曲线所在的视图的View。那么在<code>-drawRect:</code> 中画UIBezierPath，刚好可以知道view的bound</p>
</li>
<li><p>已经得到path之后，使用CAKeyframeAnimation来动画</p>
<pre><code class="objective-c">// 先设定2个CAKeyframeAnimation
CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];
animation1.keyPath = @&quot;position&quot;;
animation1.path = animation1Path.CGPath;
animation1.duration = 0.5f;
animation1.removedOnCompletion = NO;

CAKeyframeAnimation *animation2 = [CAKeyframeAnimation animation];
animation2.keyPath = @&quot;position&quot;;
animation2.path = animation2Path.CGPath;
animation2.duration = 0.5f;
animation2.removedOnCompletion = NO;

// 更新两个circle的约束
[self.circle1 updateConstraint]；
[self.circle2 updateConstraint]；

// 执行动画
[CATransaction begin];
[self.circle1.layer addAnimation:consultationKeyAnimation forKey:@&quot;circle1&quot;];
[self.circle2.layer addAnimation:followupKeyAnimation forKey:@&quot;circle2&quot;];
[CATransaction commit];
</code></pre>
<p>关于CATransaction：在第一次动画没执行完的时候，立刻开始同一个transaction，会强制让第一个transaction的动画立刻结束到终点（也就是去掉Animation View的遮挡），再立刻开始第二个transaction的动画</p>
<h2 id="Auto-Layout-百分比布局"><a href="#Auto-Layout-百分比布局" class="headerlink" title="Auto Layout 百分比布局"></a>Auto Layout 百分比布局</h2><p>这里无主题无关。</p>
<p><a href="http://liumh.com/2015/09/27/ios-autolayout-multiplier/" target="_blank" rel="external">iOS AutoLayout 百分比布局</a> 这边文章谈到了Auto Layout百分比布局的问题，讲的很好。说一个里面的例子：子视图b的leading要与父视图a的leading之间隔20%的宽度</p>
<pre><code class="objective-c">b.leading = a.trailing * 0.2
</code></pre>
<p>使用Masonry</p>
<pre><code class="objective-c">[b mas_makeConstraints:^(MASConstraintMaker *make) {
    make.leading.equalTo(a.mas_trailing).multipliedBy(0.2);
}];
</code></pre>
<p>可以这么理解：</p>
<pre><code class="objective-c">a.leading = 0;
a.trailing = a.width;
a.trailing * 0.2 = a.width * 0.2;
b.leading - a.leading = 0.2 * a.width - 0 = 0.2 * a.width
</code></pre>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://liumh.com/2015/09/27/ios-autolayout-multiplier/" target="_blank" rel="external">iOS AutoLayout 百分比布局</a></li>
<li><a href="http://stackoverflow.com/questions/12622424/how-do-i-animate-constraint-changes" target="_blank" rel="external">How do I animate constraint changes?</a></li>
<li><a href="http://vanney9.com/2017/03/24/something-about-iOS-drawing/" target="_blank" rel="external">关于iOS Drawing</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 内存管理]]></title>
      <url>/2017/03/25/effective-objective-c-reading-note-three/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Effective Objective C</strong> 读书笔记 - 内存管理</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h3><ol>
<li><p>引用关系有一个引用树，在iOS中，这个根引用对象是UIApplication</p>
</li>
<li><p>调用alloc，引用计数加1，表示该对象想存活下去</p>
</li>
<li><p>即使对象的引用计数为0，其占用的内存已经被dealloc了，但是注意：这个时候它的内存只是放回了“可用内存池”，里面的数据不会立即被覆盖</p>
</li>
<li><p>记住一点：在MRC中，将指针指向对象是不会增加reference count的，必须手动加1</p>
</li>
<li><p>看看下面的MRC代码：</p>
<pre><code class="objective-c">- (NSString *)stringValue {
      NSString *str = [[NSString alloc]] initWithFormat:@&quot;vanney&quot;; // 1
      return str;
}

NSString *str = [self stringValue];
[str retain]; // 2
</code></pre>
<p>上面的代码在注释1，和注释2处分别增加了一次reference count，但是讲道理这个时候只需要一个reference count就可以了，所以会出现一些些小问题。这就需要<strong>Auto Release Pool</strong>了</p>
<pre><code class="objective-c">- (NSString *)stringValue {
      NSString *str = [[NSString alloc]] initWithFormat:@&quot;vanney&quot;;
      return [str autorelease];
}

NSString *str = [self stringValue];
[str retain];
</code></pre>
</li>
<li><p>注意retain cycle，也就是相互引用</p>
</li>
</ol>
<h3 id="以ARC简化引用计数"><a href="#以ARC简化引用计数" class="headerlink" title="以ARC简化引用计数"></a>以ARC简化引用计数</h3><ol>
<li>代码中不再需要写：<code>retain</code> 和 <code>release</code>方法，但是这两个方法实际上还是执行了的，他们由ARC帮你执行</li>
<li>ARC中调用这些方法绕过了消息转发，直接调用底层的C函数，更加快速</li>
<li>如果autorelease后面跟上的是retain，那么ARC可以优化这两个操作（因为这两个操作加在一起，什么也没做…）。这种优化通过设置标志位来实现，具体的看书~</li>
<li>CoreFoundation的内容不适合ARC</li>
</ol>
<h3 id="在dealloc方法中只释放引用并解除监听"><a href="#在dealloc方法中只释放引用并解除监听" class="headerlink" title="在dealloc方法中只释放引用并解除监听"></a>在dealloc方法中只释放引用并解除监听</h3><ol>
<li>delloc方法在对象reference count降到0时，会被调用</li>
<li>因为ARC会帮你生成释放对象所拥有的引用，那么你需要做的主要有两点<ol>
<li>释放CoreFoundation对象</li>
<li>解除监听行为</li>
</ol>
</li>
</ol>
<h3 id="以弱引用避免保留环"><a href="#以弱引用避免保留环" class="headerlink" title="以弱引用避免保留环"></a>以弱引用避免保留环</h3><h3 id="以“自动释放池块”降低内存峰值"><a href="#以“自动释放池块”降低内存峰值" class="headerlink" title="以“自动释放池块”降低内存峰值"></a>以“自动释放池块”降低内存峰值</h3><ol>
<li><p>自动释放池还有变量可见范围的限制</p>
<pre><code class="objective-c">@autoreleasepool {
      id object = [self createObject];
}
[self useObject:object]; // 报错，因为object变量已经不可见了
</code></pre>
</li>
</ol>
<h3 id="用“僵尸对象”调试内存管理问题"><a href="#用“僵尸对象”调试内存管理问题" class="headerlink" title="用“僵尸对象”调试内存管理问题"></a>用“僵尸对象”调试内存管理问题</h3><ol>
<li><p>向已经回收的对象发送消息是非常不安全的。如果该内存已经被覆写了，那么程序就会崩溃；如果暂时没有被覆写，那么侥幸可以运行。所以这时候<strong>程序会偶尔报错，难以调试</strong></p>
</li>
<li><p>这个时候就可以使用Cocoa提供的 <strong>僵尸对象</strong> 的调试方法</p>
</li>
<li><p>启用这一项调试功能之后：所有的本要被回收的对象会被转化成特殊的僵尸对象，这些内存不会被覆写；当僵尸对象收到消息后，他会将原本的对象信息打印出来，并提示说，你给一个已经回收的对象发送了信息</p>
<p><img src="/lionheart/1703/zombiefix.png" alt="enable zombie"></p>
</li>
<li><p>至于僵尸对象的工作原理，具体的看书~</p>
</li>
</ol>
<h3 id="不要使用retainCount"><a href="#不要使用retainCount" class="headerlink" title="不要使用retainCount"></a>不要使用retainCount</h3><ol>
<li>ARC已经废弃<code>retainCount</code>方法</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关于iOS Drawing]]></title>
      <url>/2017/03/24/something-about-iOS-drawing/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学了一段时间的OpenGL，这次又重新看了一遍 <strong>iOS Core Animation</strong> 这本书，查看了许多资料。对这个iOS的drawing稍有顿悟=。=</p>
<p>这篇文章里面，我会针对下面几个方面说说我自己的见解：</p>
<ol>
<li>Core Animation，Core Graphic 和 OpenGL ES</li>
<li>Rendering以及Animation的步骤</li>
<li>iOS Drawing中的CPU，GPU</li>
<li>drawRect方法的弊端</li>
<li>影响GPU与CPU绘制的因素</li>
</ol>
<a id="more"></a>
<h2 id="Core-Animation，Core-Graphics-和-OpenGL-ES"><a href="#Core-Animation，Core-Graphics-和-OpenGL-ES" class="headerlink" title="Core Animation，Core Graphics 和 OpenGL ES"></a>Core Animation，Core Graphics 和 OpenGL ES</h2><p>Core Animation，Core Graphics 和 OpenGL ES 三者都是和iOS画图，呈现内容相关的iOS框架。总体来说，Core Animation和UIKit是一个层级的，而他们底层画图的框架就是Core Graphics 和 OpenGL ES。</p>
<ol>
<li><strong>Core Animation</strong> 是iOS用来控制内容的显示和动画的。它的主要功能就是管理<strong>CALayer</strong>。</li>
<li><strong>UIView</strong> 大家都很熟悉。那么UIView底层负责显示内容和动画的就是 <strong>CALayer</strong> 。UIView上和显示以及动画相关的接口，其实也是对CALayer的接口的包装</li>
<li>CALayer的contents最终会显示在屏幕上。而<strong>Core Graphics</strong> 和 <strong>OpenGL ES</strong>就负责在CALayer上面作画，并将其内容显示到屏幕上</li>
<li><strong>Core Graphics</strong>是个2D图形库，一般用来画矢量图，比如UIBezierPath等等。它主要使用CPU来绘制。以绘制一条UIBezierPath为例：通过CPU的计算，生成包含该path路径的bitmap，然后将该bitmap传递给GPU，绘制出来。所以Core Graphics的主要计算压力在CPU上面，而且使用CPU来生成bitmap是很耗时的一个步骤</li>
<li><strong>OpenGL ES</strong> 讲道理是可以画任何的2D、3D图形的。以绘制一个三角形为例，只需要将3个顶点传递给GPU，然后GPU会计算生成包含该三角形的bitmap，最终使用GPU将该bitmap绘制出来。</li>
<li>所以我理解的Core Graphics和OpenGL ES的主要区别就是生成最终的 <strong>bitmap</strong> 的位置。Core Graphics由CPU来生成bitmap；OpenGL ES由GPU来生成bitmap。 最终这个bitmap都要交给GPU来渲染到屏幕上面。</li>
<li>由于CPU生成bitmap较为耗时（这也是Core Graphics性能差的原因），而且CPU还要执行其他的任务，所以不推荐使用Core Graphics来绘制。</li>
<li>Core Animation对绘制过程进行了优化，大多数的UIKit里面的原件(UIView)的底层layer都是硬件加速的，也就是使用GPU来生成bitmap并绘制。</li>
</ol>
<h2 id="Rendering和Animation的步骤"><a href="#Rendering和Animation的步骤" class="headerlink" title="Rendering和Animation的步骤"></a>Rendering和Animation的步骤</h2><p>参考<strong>iOS Core Animation</strong> 一书的第12章</p>
<ol>
<li><strong>Layout</strong>： 设置view/layer树种每个layer的属性(frame, background color, border等等)</li>
<li><strong>Display</strong>： 生成layer的backing image，在这一步涉及到<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>的调用，也就是使用CPU生成bitmap，来填充backing image。也可以使用UIImage来填充backing image。</li>
<li><strong>Prepare</strong>： Core Animation准备好Animation的数据，比如动画的属性，终止值等等</li>
<li><strong>Commit</strong>： Core Animation将所有layer数据和动画数据打包将他们发送给<strong>render server</strong> 进行显示</li>
<li>将layer的属性计算，转化成OpenGL的顶点等属性（提供数据给GPU，计算bitmap，也就是OpenGL中的各个三角形）</li>
<li>GPU组合各个layer的bitmap，将其渲染在屏幕上</li>
</ol>
<h2 id="iOS-Drawing中的CPU和GPU"><a href="#iOS-Drawing中的CPU和GPU" class="headerlink" title="iOS Drawing中的CPU和GPU"></a>iOS Drawing中的CPU和GPU</h2><ol>
<li>Core Graphics使用CPU计算bitmap</li>
<li>OpenGL ES使用GPU计算bitmap</li>
<li>使用GPU将所有的layer的bitmap组合在一起</li>
</ol>
<h2 id="drawRect方法的弊端"><a href="#drawRect方法的弊端" class="headerlink" title="drawRect方法的弊端"></a>drawRect方法的弊端</h2><p>drawRect方法是对drawLayer:inContext:的包装。两个方法如果有实现的话，在重绘layer的时候会调用。他们适合自定义layer内容。但是会影响性能</p>
<p>在每次调用这两个方法的时候，都会新建一个与当前的layer的大小相等的空的context（bitmap），然后使用Core Graphics或者直接UIImage等等将该context填充。这相当与离屏渲染。然后将生成的context再赋给layer的content，再交给GPU渲染出来。</p>
<p>注意：CALayer会cache自己的bitmap，那么每次渲染的时候就不需要重新生成CALayer的bitmap。只需要将bitmap交给GPU，让GPU执行组合工作就可以了。一般来说，生成bitmap（无论在CPU端还是GPU端）都是比组合bitmap耗时的</p>
<h2 id="影响GPU与CPU绘制的因素"><a href="#影响GPU与CPU绘制的因素" class="headerlink" title="影响GPU与CPU绘制的因素"></a>影响GPU与CPU绘制的因素</h2><h3 id="GPU端"><a href="#GPU端" class="headerlink" title="GPU端"></a>GPU端</h3><ol>
<li>太多的重复绘制：一次绘制过程中，在同一个像素点，绘制多遍</li>
<li>离屏渲染：CPU和GPU都会出现离屏渲染的情况，这需要额外的内存来存放渲染的结果</li>
<li>太多的geometry：也就是OpenGL中，太多的三角形</li>
<li>渲染太大的图片：GPU支持的最大的渲染texture是有限的（通常2048*2048，或者retina的4096*4096），图片像素过大的话，要先在CPU端处理之后，才能交给GPU显示</li>
</ol>
<h3 id="CPU端"><a href="#CPU端" class="headerlink" title="CPU端"></a>CPU端</h3><ol>
<li>Layout计算：也就是计算每个layer的frame等等属性，这个在使用autolayout的系统上面更加的费时</li>
<li>Lazy View Loading：只有在view第一次出现在屏幕上时，才会去加载view相关的资源（图片等等），所以如果这个资源很大，或者延迟很大（网络获取）的时候，会延缓CPU的操作。这一步的操作包括Layout，Display等步骤</li>
<li>Core Graphics drawing</li>
<li>图片解压：因为存放的基本都是压缩的图片，但是显示的时候需要全size的图片，所以需要CPU执行图片解压的工作</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/14659563/to-drawrect-or-not-to-drawrect-when-should-one-use-drawrect-core-graphics-vs-su" target="_blank" rel="external">to drawRect or not to drawRect (when should one use drawRect/Core Graphics vs subviews/images and why?)</a></li>
<li><a href="http://stackoverflow.com/questions/7287254/calayer-vs-cgcontext-which-is-a-better-design-approach" target="_blank" rel="external">CALayer vs CGContext, which is a better design approach?</a></li>
<li><a href="http://floriankugler.com/2013/05/24/layer-trees-vs-flat-drawing-graphics-performance-across-ios-device-generations/" target="_blank" rel="external">Layer Trees vs. Flat Drawing – Graphics Performance Across iOS Device Generations</a></li>
<li><a href="http://vanney9.com/2016/07/01/iOS-Core-Animation-reading-note-one/" target="_blank" rel="external">iOS Core Animation - The Layer Beneath</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 协议与分类]]></title>
      <url>/2017/03/23/effective-objective-c-reading-note-two/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Effective Objective-C</strong> 读书笔记 - 协议与分类</p>
<p>协议（<strong>protocol</strong>）与Java的接口（<strong>interface</strong>）类似，由于OC不支持<strong>多重继承</strong>。通过协议，可以实现类似多重继承的效果。若指定某个类实现了某个协议，那么就表示，该类实现了协议中规定了一些方法。</p>
<p>分类（<strong>category</strong>）是OC的重要的一个语言特性。利用分类机制，无须继承子类即可为当前类添加方法。这也是由于动态runtime系统，才得以实现。</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="通过委托与数据源协议进行对象间通信"><a href="#通过委托与数据源协议进行对象间通信" class="headerlink" title="通过委托与数据源协议进行对象间通信"></a>通过委托与数据源协议进行对象间通信</h3><ol>
<li><p>注意一点，声明delegate的时候，要声明成weak类型的。避免循环引用。</p>
</li>
<li><p>通常将：委托对象是否可以响应协议中的某个方法 这一信息缓存起来。之后就不需要一直查询该对象是否响应该方法了。缓存可以使用<strong>位段</strong>来实现。</p>
<pre><code class="objective-c">@interface Example() {
      struct {
          unsigned int didReceiveData : 1;
          unsigned int didFailWithError : 1;
      } _delegateFlags;
}
@end

@implementation Example
- (void)setDelegate:(id&lt;ExampleDelegate&gt;)delegate {
      _delegate = delegate;
      _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(didReceiveData:)];
      _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(didFailWithError:)];
}
@end
</code></pre>
<p>在调用delegate时，就不需要判断delegate是否响应某方法了，只需要看_delegateFlags里面的字段就可以了</p>
</li>
</ol>
<h3 id="将类的实现代码分散到便于管理的数个分类之中"><a href="#将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="将类的实现代码分散到便于管理的数个分类之中"></a>将类的实现代码分散到便于管理的数个分类之中</h3><ol>
<li>将类的方法分散到几个分类中<ol>
<li>EOCPerson+Friendship(.h/.m)</li>
<li>EOCPerson+Work(.h/.m)</li>
<li>EOCPerson+Play(.h/.m)</li>
</ol>
</li>
<li>可以创建一个Private的分类，将所有的‘私有方法’写在里面，这个private的头文件可以被其他文件所引用，但是发布的时候，不会公布出去。所以只能在程序内部使用，第三方使用者无法使用private分类中的方法。</li>
</ol>
<h3 id="总是为第三方类的分类名称加前缀"><a href="#总是为第三方类的分类名称加前缀" class="headerlink" title="总是为第三方类的分类名称加前缀"></a>总是为第三方类的分类名称加前缀</h3><ol>
<li><p>分类机制通常用于向五元吗的既有类中新增功能。</p>
</li>
<li><p>分类的方法相当于直接添加在既有类中的，他们好比这个类的固有方法</p>
</li>
<li><p>将分类中的方法加入既有类的方法列表是在runtime加载分类的时候。这就有一个问题了，如果分类中的方法名和既有类原始方法同名，那么会覆盖原始方法的实现</p>
</li>
<li><p>基于上述问题，就要加前缀</p>
<pre><code class="objective-c">@interface NSString (ABC_HTTP)
- (NSString *)abc_method;
@end
</code></pre>
</li>
</ol>
<h3 id="勿在分类中声明属性"><a href="#勿在分类中声明属性" class="headerlink" title="勿在分类中声明属性"></a>勿在分类中声明属性</h3><ol>
<li>属性包含实例变量，分类无法自动合成属性的实例变量。</li>
<li>要想硬添加属性也是可以的。手动添加合成实例变量的方法，也就是实现该属性的存取方法，也就是调用 <code>objc_getAssociatedObject</code>和<code>objc_setAssociatedObject</code> 方法</li>
</ol>
<h3 id="使用class-continuation分类隐藏实现细节"><a href="#使用class-continuation分类隐藏实现细节" class="headerlink" title="使用class-continuation分类隐藏实现细节"></a>使用class-continuation分类隐藏实现细节</h3><ol>
<li><p>这种分类与普通的分类不同。其实我们一直在使用这个分类。。。</p>
</li>
<li><p>这个分类是唯一能正常的声明实例变量的分类，他必须写在实现文件中</p>
<pre><code class="objective-c">@interface EOCPerson() {
      NSString *_instanceVariable; // 实例变量
}
@property (nonatomic, strong) NSString *pro; // 属性
- (void)p_someMethod; // 声明私有方法
@end
</code></pre>
</li>
<li><p>虽然不要求声明私有方法，但是最好这样做</p>
</li>
<li><p>如果只是私有的遵循某协议的话，也需放在该分类中</p>
<pre><code class="objective-c">@interface EOCPerson () &lt;EOCSecretDelegate&gt;
@end
</code></pre>
</li>
</ol>
<h3 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h3><ol>
<li><p><code>id&lt;EOCPersonDelegate&gt; delegate;</code> 这个delegate就是匿名对象，不需要关心对象是什么类型，只要他遵循该协议就可以了</p>
</li>
<li><p>使用这个还可以返回多个基类不是相同的类，如下：</p>
<pre><code class="objective-c">@protocal EOCDBConnection
- (void)connect;
- (void)disconnect;
- (BOOL)isConnect;
- (NSArray *)performQuery:(NSString *)query;
@end

@interface EOCManager : NSObject
+ (id)sharedInstance;
- (id&lt;EOCDBConnection&gt;)connectionWithIdentifier:(NSString *)identifier;
@end
</code></pre>
<p>上面这个例子用来实现数据库的连接，不管是连接何种类型的数据库（Mysql，SQLite，PostreSQL）等等，都可以使用<code>connectionWithIdentifier:</code>方法。</p>
<p>这个方法底层的实现：根据不同的identifier，选择性的返回与连接 Mysql或是SQLite或是PostreSQL 相关的对象，可能返回的对象叫做 MySQLManager, SQLiteManager, PostreSQLManager。 这些对象因为可能是来自3种第三方库的，所以不会有相同的基类，但是只要他们实现了delegate的方法，都可以这样返回。</p>
<p>这样做：既保证了接口的简介，又隐藏了底层的实现</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Objective-C - 接口与API设计]]></title>
      <url>/2017/03/21/effective-objective-c-reading-note-one/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Effective Objective-C</strong> 读书笔记 - 接口与API设计</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="用前缀避免命名空间冲突"><a href="#用前缀避免命名空间冲突" class="headerlink" title="用前缀避免命名空间冲突"></a>用前缀避免命名空间冲突</h3><ol>
<li>前缀字母至少3个，两字母的前缀被Apple保留</li>
<li>注意：实现文件中的纯C函数以及全局变量也最好要加前缀，因为他们也是全局可见的。纯C函数，默认是extern的。（<strong>PS</strong> 见参考1）</li>
</ol>
<h3 id="提供全能初始化方法"><a href="#提供全能初始化方法" class="headerlink" title="提供全能初始化方法"></a>提供全能初始化方法</h3><ol>
<li><p>初始化方法以 <strong>init</strong> 开头。</p>
</li>
<li><p>如果一个类有多个初始化方法的话，最好要选定一个方法为全能初始化方法，让其他的初始化方法都来调用这个全能初始化方法。</p>
</li>
<li><p>在全能初始化方法中，才执行数据的存储等等操作；其他方法只是改变调用全能初始化方法的参数而已。这样简单地保证了所有的初始化方法都能正确执行。</p>
</li>
<li><p>全能初始化方法要链式调用：也就是说，子类的全能初始化方法要调用超类的全能初始化方法。</p>
</li>
<li><p>还有子类的全能初始化方法如果与超类的全能初始化方法不重名的话，要覆写该方法</p>
<pre><code class="objective-c">// 超类全能初始化方法(矩形类)
- (id)initWithWidth:(float)width andHeight:(float)height {
      if (self = [super init]) {
          _width = width;
          _height = height;
      }
      return self;
}

// 子类全能初始化方法(正方形类)
- (id)initWithDimension:(float)dimension {
      if (self = [super initWithWidth:dimension andHeight:dimension]) { // 全能初始化方法链式调用

      }
      return self;
}

// 覆写超类方法
- (id)initWithWidth:(float)width andHeight:(float)height {
      float dimension = MAX(width, height);
      return [self initWithDimension:dimension];
}
</code></pre>
<p>这样保证了：</p>
<ol>
<li>子类调用自己的任何初始化方法，都最终会调用自己的全能初始化方法</li>
<li>子类调用超类的任何初始化方法，最终会调用超类的全能初始化方法；但是该方法被覆写，而且覆写时调用了子类自己的全能初始化方法。所以最终还是调用了子类自己的全能初始化方法~~</li>
</ol>
</li>
</ol>
<h3 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h3><ol>
<li>方便调试</li>
<li>除了你想看到的信息之外，还是要将默认的description的信息打印出来：也就是类名字和指针地址</li>
<li>注意NSObject协议中的<code>debugDescription</code>方法，该方法只在 开发者在控制台中打印对象时 才会被调用。它的默认实现是直接调用 description 方法。在LLDB控制台输入 <code>po object</code> 可以打印object对象</li>
</ol>
<h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><ol>
<li>尽量将对外的属性设置为readonly</li>
<li>可以在实现文件里面，将属性重新定义成readwrite</li>
</ol>
<h3 id="使用清晰而协调的命名方式"><a href="#使用清晰而协调的命名方式" class="headerlink" title="使用清晰而协调的命名方式"></a>使用清晰而协调的命名方式</h3><h3 id="为私有方法加前缀"><a href="#为私有方法加前缀" class="headerlink" title="为私有方法加前缀"></a>为私有方法加前缀</h3><ol>
<li>例如 <code>- (void)p_privateMethod;</code></li>
</ol>
<h3 id="理解Objective-C错误模型"><a href="#理解Objective-C错误模型" class="headerlink" title="理解Objective-C错误模型"></a>理解Objective-C错误模型</h3><ol>
<li><p>ARC不是<code>异常安全</code>的，也就是说：如果抛出异常，那么本应在作用域末尾释放的对象现在却不会自动释放了。</p>
</li>
<li><p>基于上述原因，OC代码只会在极其严重的错误发生时，才抛出异常；而且此时应该结束app运行。</p>
</li>
<li><p>除了抛出异常（<strong>NSException</strong>）之外，还可以使用稍微缓和的方法，也就是<strong>NSError</strong> 。用法如下：</p>
<pre><code class="objective-c">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;
</code></pre>
<p>会将错误传到回调delegate中</p>
</li>
</ol>
<h3 id="理解NSCopying协议"><a href="#理解NSCopying协议" class="headerlink" title="理解NSCopying协议"></a>理解NSCopying协议</h3><ol>
<li><p>要让自定义的类的对象，具有拷贝功能，也就是具有正确的<code>[object copy];</code> 方法，该类就必须实现NSCopying协议的 <code>- (id)copyWithZone:(NSZone *)zone</code> 方法。（<strong>PS</strong> 不需要管zone参数）</p>
</li>
<li><p>copy方法定义在NSObject里面，所以所有类都继承了该方法。该方法的默认实现是简单的调用 <code>copyWithZone:</code> 方法</p>
</li>
<li><p>我们只需要实现类的copyWithZone: 方法，然后调用对象的copy方法，就可以实现对象的拷贝。（<strong>PS</strong> 要先声明该类遵循NSCopying协议）</p>
</li>
<li><p>可以使用 -&gt; 访问实例变量，而不是属性。例如：</p>
<pre><code class="objective-c">@implementation EOCPerson {
      NSMutableSet *_friends; // 实例变量，不是属性
}

- (id)copyWithZone:(NSZone *)zone {
      EOCPerson *copy = [[self class] allocWithZone:zone] init];
      copy-&gt;_friends = [_friends mutableCopy]; // -&gt; 访问实例变量
      return copy;
}

@end
</code></pre>
</li>
<li><p>深拷贝和浅拷贝</p>
<ol>
<li>深拷贝：对象里面的底层数据也一并拷贝</li>
<li>浅拷贝：只拷贝对象，对象里面的底层数据公用一份</li>
<li>Foundation框架的collection类（NSArray， NSSet…）的默认拷贝方法都是<strong>浅拷贝</strong></li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/856636/effects-of-the-extern-keyword-on-c-functions" target="_blank" rel="external">Effects of the extern keyword on C functions</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL ES 入门]]></title>
      <url>/2016/10/29/opengl-es-start-up/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习OpenGL ES，跟着教程做了一个Demo，在模拟器下的运行效果如下：</p>
<p><img src="/lionheart/1610/openglesstartup.gif" alt="demo"></p>
<a id="more"></a>
<p>Demo代码在<a href="https://github.com/vanney9/blogDemo/tree/master/blogOpenGLESStartup" target="_blank" rel="external">这里</a></p>
<h2 id="OpenGL和OpenGL-ES"><a href="#OpenGL和OpenGL-ES" class="headerlink" title="OpenGL和OpenGL ES"></a>OpenGL和OpenGL ES</h2><p>OpenGL ES是OpenGL的子集，它主要运行在手机上。推荐一个超棒的OpenGL入门教程：<a href="http://learnopengl.com/" target="_blank" rel="external">Learn OpenGL</a> ；当然也有热心的国人将他翻译过来了，在 <a href="https://learnopengl-cn.github.io/" target="_blank" rel="external">这里</a>。通过这些教程的学习，我也算是入了OpenGL的门。</p>
<p>关于将OpenGL运用于iOS上面，也就是使用OpenGL ES，可以看看Apple的官方文档 <a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793-CH1-SW1" target="_blank" rel="external">OpenGL ES Programming Guide for iOS</a></p>
<h2 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h2><p>demo的实现可以分成2个部分：</p>
<ol>
<li>运用OpenGL ES显示静态的场景</li>
<li>添加手势操作，让场景动起来</li>
</ol>
<h3 id="OpenGL-ES-渲染"><a href="#OpenGL-ES-渲染" class="headerlink" title="OpenGL ES 渲染"></a>OpenGL ES 渲染</h3><p>关于在iOS上使用OpenGL ES渲染，可以借助iOS的GLKit框架。他大大简化了OpenGL ES的使用难度。而渲染的主要步骤分成以下几步：</p>
<h4 id="使用GLKit初始化"><a href="#使用GLKit初始化" class="headerlink" title="使用GLKit初始化"></a>使用GLKit初始化</h4><p>创建GLKViewController和GLKView，OpenGL ES渲染的结果将会显示在GLKView的layer上面。而将GLKViewController设置成GLKView的delegate，他会控制整个的渲染流程，比如每秒渲染多少次，何时开始渲染等等</p>
<h4 id="设置GLKView的context属性"><a href="#设置GLKView的context属性" class="headerlink" title="设置GLKView的context属性"></a>设置GLKView的context属性</h4><p>OpenGL ES渲染的时候需要一个上下文，也就是GLKView的context，对于他的设置如下：</p>
<pre><code class="objective-c">view.context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES3];
[EAGLContext setCurrentContext:view.context];
</code></pre>
<p>这里创建context是使用OpenGL ES的基石，就相当于你使用GLFW和GLEW对整个环境进行初始化，定义viewport之类的</p>
<h4 id="设置OpenGL-ES"><a href="#设置OpenGL-ES" class="headerlink" title="设置OpenGL ES"></a>设置OpenGL ES</h4><p>设置OpenGL ES的代码和OpenGL的基本相似。</p>
<h5 id="创建shader程序"><a href="#创建shader程序" class="headerlink" title="创建shader程序"></a>创建shader程序</h5><p>也就是对你写的glsl文件进行编译链接，最终持有一个Shader programe。代码如下：</p>
<pre><code class="objective-c">// load glsl file
NSString *vertexFile = [[NSBundle mainBundle] pathForResource:vertexPath ofType:@&quot;glsl&quot;];
NSString *fragmentFile = [[NSBundle mainBundle] pathForResource:fragmentPath ofType:@&quot;glsl&quot;];

NSError *error;

NSString *vertexString = [NSString stringWithContentsOfFile:vertexFile encoding:NSUTF8StringEncoding error:&amp;error];
if (!vertexString) {
  NSLog(@&quot;vanney code log : error loading vertex shader : %@&quot;, error.localizedDescription);
  exit(1);
}

NSString *fragmentString = [NSString stringWithContentsOfFile:fragmentFile encoding:NSUTF8StringEncoding error:&amp;error];
if (!fragmentString) {
  NSLog(@&quot;vanney code log : error loading fragment shader : %@&quot;, error.localizedDescription);
  exit(1);
}

// compiler
GLuint vertexShader, fragmentShader;
GLint compilerSuccess, linkSuccess;
GLchar messages[512];

vertexShader = glCreateShader(GL_VERTEX_SHADER);
const GLchar *vertexStringUTF8 = [vertexString UTF8String];
glShaderSource(vertexShader, 1, &amp;vertexStringUTF8, NULL);
glCompileShader(vertexShader);
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;compilerSuccess);
if (compilerSuccess == GL_FALSE) {
  glGetShaderInfoLog(vertexShader, sizeof(messages), NULL, messages);
  NSLog(@&quot;vanney code log : compile vertex shader error : %@&quot;, [NSString     stringWithUTF8String:messages]);
  exit(1);
}

fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
const GLchar *fragmentStringUTF8 = [fragmentString UTF8String];
glShaderSource(fragmentShader, 1, &amp;fragmentStringUTF8, NULL);
glCompileShader(fragmentShader);
glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;compilerSuccess);
if (compilerSuccess == GL_FALSE) {
  glGetShaderInfoLog(fragmentShader, sizeof(messages), NULL, messages);
  NSLog(@&quot;vanney code log : compile fragment shader error : %@&quot;, [NSString stringWithUTF8String:messages]);
  exit(1);
}

// link
self.program = glCreateProgram();
glAttachShader(self.program, vertexShader);
glAttachShader(self.program, fragmentShader);
glLinkProgram(self.program);
glGetProgramiv(self.program, GL_LINK_STATUS, &amp;linkSuccess);
if (linkSuccess == GL_FALSE) {
  glGetProgramInfoLog(self.program, sizeof(messages), NULL, messages);
  NSLog(@&quot;vanney code log : link shader error : %@&quot;, [NSString stringWithUTF8String:messages]);
  exit(1);
}

glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
</code></pre>
<h5 id="设置各种和顶点相关的缓冲"><a href="#设置各种和顶点相关的缓冲" class="headerlink" title="设置各种和顶点相关的缓冲"></a>设置各种和顶点相关的缓冲</h5><p>在缓冲中写入顶点数据，以及定义好GPU如何对这些顶点数据进行读取等等，代码如下：</p>
<pre><code class="objective-c">// initialize vertex data
glGenVertexArrays(1, &amp;VAO);
glGenBuffers(1, &amp;VBO);
//glGenBuffers(1, &amp;VEO);

glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.VEO);
//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid *) 0);
glEnableVertexAttribArray(GLKVertexAttribPosition);
glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid *) (3 * sizeof(GLfloat)));
glEnableVertexAttribArray(GLKVertexAttribTexCoord0);
glBindVertexArray(0);
</code></pre>
<h5 id="设置各种纹理缓冲"><a href="#设置各种纹理缓冲" class="headerlink" title="设置各种纹理缓冲"></a>设置各种纹理缓冲</h5><p>注意这里要使用 <code>GLKit的GLKTextureLoader</code> 和 <code>GLKTextureInfo</code> ，代码如下：</p>
<pre><code class="objective-c">NSError *error;
NSString *containerPath = [[NSBundle mainBundle] pathForResource:@&quot;container&quot; ofType:@&quot;jpg&quot;];
self.containerTexture = [GLKTextureLoader textureWithContentsOfFile:containerPath options:nil error:&amp;error];
glActiveTexture(GL_TEXTURE0);
glBindTexture(self.containerTexture.target, self.containerTexture.name);
</code></pre>
<h5 id="开始渲染"><a href="#开始渲染" class="headerlink" title="开始渲染"></a>开始渲染</h5><p>只需实现GLKView的delegate <code>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect;</code> 就可：</p>
<pre><code class="objective-c">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
  glEnable(GL_DEPTH_TEST);
  glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  //glClear(GL_COLOR_BUFFER_BIT);

  [self.shader use];

  GLKMatrix4 projectionMatrix = GLKMatrix4MakePerspective(M_PI_4, self.view.bounds.size.width / self.view.bounds.size.height, 0.1f, 100.0f);
  glUniformMatrix4fv(glGetUniformLocation(self.shader.program, &quot;projection&quot;), 1, GL_FALSE, projectionMatrix.m);
  GLKMatrix4 viewMatrix = GLKMatrix4MakeLookAt(0.0f, 0.0f, 3.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
  glUniformMatrix4fv(glGetUniformLocation(self.shader.program, &quot;view&quot;), 1, GL_FALSE, viewMatrix.m);

  // bind texture
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(self.containerTexture.target, self.containerTexture.name);
  glUniform1i(glGetUniformLocation(self.shader.program, &quot;ourTexture1&quot;), 0);
  glActiveTexture(GL_TEXTURE1);
  glBindTexture(self.faceTexture.target, self.faceTexture.name);
  glUniform1i(glGetUniformLocation(self.shader.program, &quot;ourTexture2&quot;), 1);

  glBindVertexArray(VAO);
  GLKMatrix4 transModel = [self.transformation getModelViewMatrix];
  for (int i = 0; i &lt; 10; ++i) {
    //GLKMatrix4 modelMatrix = GLKMatrix4TranslateWithVector3(GLKMatrix4Identity, cubePositions[i]);
    GLKMatrix4 modelMatrix = GLKMatrix4TranslateWithVector3(transModel, cubePositions[i]);
    GLfloat radian = (GLfloat) (20.0f * i / 180 * M_PI);
    modelMatrix = GLKMatrix4RotateWithVector3(modelMatrix, radian, GLKVector3Make(1.0f, 0.3f, 0.5f));
    glUniformMatrix4fv(glGetUniformLocation(self.shader.program, &quot;model&quot;), 1, GL_FALSE, modelMatrix.m);
    glDrawArrays(GL_TRIANGLES, 0, 36);
  }
  glBindVertexArray(0);
}
</code></pre>
<h3 id="添加手势"><a href="#添加手势" class="headerlink" title="添加手势"></a>添加手势</h3><p>参看这篇教程 <a href="https://www.raywenderlich.com/50398/opengl-es-transformations-gestures" target="_blank" rel="external">OpenGL ES Transformations with Gestures</a></p>
<p>他的中心思想就是：向整个GLKView添加各种手势，通过手势传递的信息来调整物体的model的matrix，也就是从局部坐标到世界坐标转换的matrix。</p>
<p>具体的代码可以参考Github上的Transformation类</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://learnopengl.com/" target="_blank" rel="external">Learn OpenGL</a></li>
<li><a href="https://learnopengl-cn.github.io/" target="_blank" rel="external">Learn OpenGL中文翻译</a></li>
<li><a href="OpenGL ES Programming Guide for iOS">OpenGL ES苹果官方文档</a></li>
<li><a href="https://www.raywenderlich.com/50398/opengl-es-transformations-gestures" target="_blank" rel="external">OpenGL ES Transformations with Gestures</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次aws-ec2杀毒经历]]></title>
      <url>/2016/10/29/aws-minered-virus/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天aws的ec2服务器被攻击了，被莫名人士植入了一个minerd的恶意程序，下面简单记录一下对这个恶意程序的处理过程</p>
<a id="more"></a>
<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>我们使用一台aws的ec2服务器来托管网站，前几天登录网站界面的时候一直在loading界面，死活无法登录。当我想终端登录ec2的时候也是死活登不上去。当时就有种不翔的预感，要GG。稳下来后，查看aws的CloudWatch监控记录，发现近段时间的ec2的CPU利用率一直很稳定的保持在100%。。。原来CPU被用完了，难怪怎么都登不上去，网站也无法运作。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="登录ec2"><a href="#登录ec2" class="headerlink" title="登录ec2"></a>登录ec2</h3><p>先得想办法登录ec2，看看到底发生了什么。注意：登录不上ec2的时候，千万不能随意的重启或者停止ec2；因为这样的话，存储在上面的数据可能会丢失。</p>
<p>但是cpu占用率始终保持在100%，怎么也登不上ec2。只能使用大招了。使用一下步骤曲线救国：</p>
<ol>
<li>登录aws控制台。对现在的这台ec2（记为ec2one）的系统盘，也就是根卷创建一份快照</li>
<li>根据刚创建的快照创建一个卷（也就是：磁盘），这样就复制了ec2one的系统盘</li>
<li>启用一台全新的ec2（记为ec2two），注意登录密钥和ec2one的相同</li>
<li>停用ec2two，卸载ec2two的根卷；将2中创建的系统盘绑定到ec2two上，作为它的系统盘（注意：指定为/dev/xvda，不然就被认定是一般磁盘；这时ec2two没有系统盘，无法启动）</li>
<li>启动ec2two，并终端登录</li>
</ol>
<p>通过这样的方式就创建了一台和ec2one相同的机器 ec2two，并且登录上去了。</p>
<h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>登录ec2two之后，使用top指令查看cpu的占用情况。过一段时间后，发现一个minerd的进程占用了90多的cpu，并且居高不下。</p>
<p><img src="/lionheart/1610/minerd.png" alt="minerd virus"></p>
<p>google了一下，这是个’挖矿‘的程序，估计是我这台服务器被莫名人士拿来挖比特币了。所以果然是服务器中毒了</p>
<h3 id="解决经过"><a href="#解决经过" class="headerlink" title="解决经过"></a>解决经过</h3><ol>
<li>先kill这个进程，没用，过一会这个进程又出来了</li>
<li>使用 <code>ps aux | grep minerd</code> 查看什么程序在运行这个进程，发现了一个 <code>/opt/minerd</code>的在运行这个进程；进入/opt删掉minerd，没用，多一会，这个minerd的可执行文件又出来了。。。</li>
<li>google，给出的答案居然是安装杀毒软件。还真是头一次在linux上面装杀毒软件。。</li>
<li>下了一个免费的linux杀毒软件：shopos，官网看上去高大上，整个软件也有个500M左右，应该比较靠谱。</li>
<li>安装，按照说明扫描杀毒，结果<code>minerd</code>进程还在不说，还把ps等指令给删除了。。。估计是我的打开方式不对，这时候还是很想念360的。你说他怎么就不出一个linux的360安全卫士呢？</li>
<li>再google，发现一位国内码农遇到的情况和我相同，最后实践下来而确实靠谱，附上链接：<a href="http://www.cnblogs.com/zhouto/p/5680594.html" target="_blank" rel="external">阿里云服务器被挖矿minerd入侵的解决办法</a></li>
<li>说一下这个最终解决方法<ol>
<li>关闭访问挖矿服务器的访问 <code>iptables -A INPUT -s xmr.crypto-pool.fr -j DROP</code>  和  <code>iptables -A OUTPUT -d xmr.crypto-pool.fr -j DROP</code></li>
<li><code>chmod -x minerd</code>  ,取消掉执行权限， 在没有找到根源前，千万不要删除 minerd，因为删除了，过一回会自动有生成一个</li>
<li><code>pkill minerd</code> 杀掉进程</li>
</ol>
</li>
<li>根据这位高人所说，之说以会被入侵，是因为redis服务器的漏洞。在ec2上面安装了redis，但是没有限制ip访问，开放的还是默认的6379端口，而且还不设置访问redis的密码的话，莫名人士就可以通过redis来进入这台服务器。显然我们之前的redis的访问条件就是这么的宽松。。。 看看如何限制redis的访问<ol>
<li>因为我们网站需要使用redis，才安装的。但是这个redis只会由跑在nginx服务器上的php代码来访问，所以说只有ec2自己才会访问redis。</li>
<li>所以登录aws的控制台，在安全组中，将之前开放的6379端口关闭</li>
<li>在redis的配置文件中，限制访问ip只能是 127.0.0.1；并且改变redis的默认的6379的端口号</li>
<li>在redis的配置文件中，设置redis的访问密码（AUTH）</li>
<li>重启redis</li>
</ol>
</li>
<li>为了验证是不是由redis引起的这次事故，进入/opt，root下的~/.ssh文件夹中看看，果然在authorized_keys里面发现了redis的一些相关的东西；而且他的密钥居然跟ec2-user的~/.ssh中的一样。看来果然是通过redis进到了ec2，并且拿到了登录ec2的密钥。删除这些相关的文件</li>
</ol>
<h3 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h3><p>本以为事件就这么顺利的解决了，没想到第二天aws又发来警告，网络输出超过了阈值。。。认真想想，这次的cpu没有报警，但是网络输出报警了。那么应该是挖矿程序没有再跑了，但是还有其他的程序将挖到的数据传输出去。</p>
<p>其实之前的那位高人所说的步骤中的最后一步，我没有去执行，就导致了这个问题。这一步就是使用 <code>service stop crond</code> 或者 <code>crontab -r</code> 删除所有的执行计划，也就是定时计划。</p>
<p>我进入ec2后，切换到root用户，使用 <code>crontab -l</code>查看所有的执行计划，果然有一个是定时执行一个 /tmp文件夹下面的 chongfu.sh 脚本。查看这个脚本，他会定时将所有tmp文件夹里的数据通过wget的方法传输到一个指定ip的机器上面。那么应该就是这个问题了。</p>
<p>先使用 <code>crontab -r</code> 删除这个定时执行 chongfu.sh 脚本的计划，再 <code>pkill chongfu.sh</code> 杀掉所有已经在执行的这个脚本。这个数据传输也就解决了。</p>
<p>查查看这个ip，果然是一个中国的ip，也就不难解释这个脚本为什么叫 chongfu.sh 而不是 repeat.sh。哎，国人何苦为难国人啊</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过这次的事件后，按常理是得总结点什么东西：</p>
<ol>
<li>要对aws进行访问限制，之前就是太宽松才被有机可乘。关掉没必要的访问端口，将ssh的端口设置成本机的ip等等</li>
<li>对aws要做好备份，不然那一天aws又登不上去了。定期对aws的系统盘以及数据盘进行快照备份</li>
<li>对于aws磁盘的选择，也就是卷的选择，最好是ebs。因为其他类型的卷可能在停止或重启ec2时，会丢失数据</li>
<li>使用好aws的CloudWatch，可以实时监控aws，发生问题时可以及时收到通知</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/zhouto/p/5680594.html" target="_blank" rel="external">阿里云服务器被挖矿minerd入侵的解决办法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> server </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C和指针读书笔记]]></title>
      <url>/2016/09/14/Pointers-on-c-reading-note-one/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《C和指针》读书笔记，会按章节排序</p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ol>
<li>函数参数若指定为 <strong>const</strong> ,表示函数不会修改这个参数。</li>
<li>字符串就是一串以 <strong>NUL</strong> 字节结尾的字符，NUL作为字符串终止符，不属于字符串。 NUL也就是 ‘\0’ </li>
<li>字符串常量以双引号起止。比如 “Hello” ，在内存中占据6个字节，分别是：H e l l o 和 NUL</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>代码的翻译阶段：<ol>
<li>程序的各个源代码先被转换成目标代码，也就是 <strong>.o</strong> 文件。编译阶段</li>
<li>然后各个目标代码会被链接器捆绑到一起，并且链接器还会将所需的各种库链接到程序中；这些目标代码和各种库捆绑到一起，形成最终的可执行文件，也就是 <strong>.out</strong> 文件。寻找各种库，会在系统库和用户指定的函数库中寻找。链接阶段</li>
</ol>
</li>
<li>编译阶段：先解析(parse)；若有优化选项的话，还要进行优化(optimizer)</li>
<li>对于字符注意一下 <strong>三字母词</strong> 。这些都以??开头，比如说 <code>??)</code>表示的是<code>]</code>。所以当你打出 <code>??):</code> 的时候，在控制台的输出会是 <code>]:</code> </li>
<li><code>&#39;\100&#39;</code>：这里的100是八进制，表示64。也就是ASCII码值为64的字符，也就是<code>@</code></li>
<li>同4所讲，<code>&#39;\x40&#39;</code>：是用16进制来计算，也表示的是<code>@</code></li>
</ol>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ol>
<li><p>C语言中仅有4种基本类型：整形、浮点型、指针和聚合类型（数组和结构体等）</p>
</li>
<li><p><strong>整形家族</strong> 包括字符、短整型、整形和长整型，他们都有 <strong>有符号</strong> 和 <strong>无符号</strong> 两种版本</p>
</li>
<li><p><strong>指针变量</strong> 也是一个变量，他存储的值是一个内存地址</p>
</li>
<li><p>字符串常量，比如”Hello”，这个常量的值是一个 <strong>指向字符的指针</strong> ，也就是一个地址，所以不能将”Hello”赋值给一个字符数组。</p>
</li>
<li><p><code>int *a;</code> 说明了 <em>a 是一个int型变量，这样才进而说明了a是指向一个int变量的指针。 </em>号表示取地址</p>
</li>
<li><p>看个等价的代码</p>
<pre><code class="c">char *message = &quot;Hallo&quot;;
/* 等价于 */
char *message;
message = &quot;Hallo&quot;; // PS 这里是message，而不是*message
</code></pre>
</li>
<li><p><strong>typeof</strong> ：</p>
<pre><code class="c">typeof char *ptr_to_char; // 这里ptr_to_char就是指向char的指针类型
ptr_to_char a; // 声明了一个指向char的指针变量a
</code></pre>
</li>
<li><p><strong>常量</strong> : 被声明为常量之后，是无法被修改的。比如<code>int const a = 9;</code> 之后无法对这个a再赋新值。</p>
</li>
<li><p>看看常量和指针的结合</p>
<pre><code class="c">int const *pci; // 指向整形常量的指针，可以修改指针的值，但是不能修改指向的int的值
int * const cpi; // 指向整形的常量指针，可以修改指向的int的值，但是不能改变指针让他指向另外的地址
int const * const cpci; // 都不能修改
</code></pre>
</li>
<li><p>编译器可以确认4种不同类型的 <strong>作用域</strong> ：文件作用域、函数作用域、代码块作用域和原型作用域</p>
</li>
<li><p>标识符（变量、函数等等）都有链接属性，三种：<strong>none</strong> 、<strong>internal</strong> 和 <strong>external</strong> PS 不是很懂。。</p>
</li>
<li><p>有3个地方用来存储变量（ <strong>存储类型</strong> ）： <strong>普通内存</strong> 、 <strong>运行时堆栈</strong> 、 <strong>硬件寄存器</strong>。在代码块之外声明的变量称之为静态变量（static），存放在静态内存中，也就是不属于堆栈的内存，这种变量在整个程序执行时都生存着；在代码块内部声明的变量称之为自动变量（auto），存放在堆栈中，当开始执行代码块时生成这种变量，代码块执行结束，变量被销毁。</p>
</li>
<li><p>对于代码块内的变量可以加上<code>static</code>修饰符，强行将它变成静态变量，存放在静态内存中，整个程序运行时间都生存。但是即使这样，它的作用域还是只能在代码块中，在代码块外，它还是无法被使用。</p>
</li>
<li><p>注意：形参不能声明为静态变量</p>
</li>
<li><p>给自动变量加<code>register</code>修饰符，说明该变量存放在寄存器中，寄存器中的访问速度比内存更快。注意：存放在寄存器中的数量是有限的，如果太多的变量声明为register，只有一部分会存放在寄存器中，那么其他的只能按照正常的变量来处理，将其存放在内存中。</p>
</li>
<li><p>关于 <strong>static</strong> 关键字</p>
</li>
<li><p>用于函数定义或用于代码块之外的变量声明时：static用于修改标识符的链接属性，从external改为internal；但是标识符的存储类型和作用域不受影响；说明了该标识符只能在文件内部使用</p>
</li>
<li><p>在代码块内部使用static来声明变量时：static用来修改变量的存储类型，变成了静态变量；但是链接属性和作用域是不变的</p>
</li>
<li><p>注意：函数的代码总是存放在静态内存中。</p>
</li>
<li><p>在代码块中的变量声明成external的话，它是一个在外部被定义的静态变量，存放在静态内存中，不再是一个自动变量</p>
</li>
</ol>
<h3 id="操作符和表达式"><a href="#操作符和表达式" class="headerlink" title="操作符和表达式"></a>操作符和表达式</h3><ol>
<li><p>移位操作符分为逻辑移位和算术移位。逻辑移位插入0，算术移位插入1</p>
</li>
<li><p>位操作符：<strong>AND(&amp;)</strong> 、 <strong>OR(|)</strong> 、 <strong>XOR(^)</strong> 对他们的操作数的各个位分别执行与、或、异或操作</p>
</li>
<li><p><strong>~</strong> 操作符按位取反</p>
</li>
<li><p><strong>&amp;</strong> 操作符获得变量的地址</p>
</li>
<li><p>在mac上 <code>sizeof(int)</code> 是4，<code>sizeof(char)</code>是1，注意<code>getchar()</code>返回的是int， <strong>EOF</strong> 也是int型</p>
</li>
<li><p><code>sizeof(a = b + 1);</code>是对表达式求字节数，这里并没有对a赋值</p>
</li>
<li><p>注意：表达式中的字符型( <strong>char</strong> ) 和短整型( <strong>short int</strong> ) 在使用之前会先被转换成为整形，如下</p>
<pre><code class="c">char a, b, c; // abc都是1个字节
a = b + c; // b和c先被转化成整形，也就是4个字节，在相加；得到结果后再截断成一个字节存储进a中
</code></pre>
<p>这样做是为了提高精度，因为如果涉及到位运算的话，很容易将8位的其中某些位数给删除掉，增加到32位就会减小这种错误的概率</p>
</li>
<li><p>如果操作符的各个操作数不是同样的类型（位数不同），那么位数少的类型会先转化成位数多的类型，再进行运算</p>
</li>
</ol>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ol>
<li><p>内存的地址以字节( <strong>byte</strong> )为单位，每个地址就是一个字节，8位。</p>
</li>
<li><p>为了存储更大的值，经常把2个或更多的字节合并在一起来组成更大的内存单位，也就是 <strong>字</strong> 。字经常由2个或是4个字节组成。所以第一个字的地址为100的话，第二个字的地址可能是102或是104</p>
</li>
<li><p>注意：以4字节的字为例。虽然一个字包含4个字节，但是这个字还是只有一个地址，至于它的地址是最左边字节的地址还是最右边的字节的地址，这由机器来决定。（高位地址和低位地址）</p>
</li>
<li><p>注意一下 * 的使用</p>
<pre><code class="c">int a = 112; // a的值是112，假设a的地址是100
int *b = &amp;a; // 这里是将a的地址100，赋给指针b
printf(&quot;%d&quot;, *b); // 这里是取得b指针指向的地址内的值，也就是 112
</code></pre>
</li>
<li><p>指针变量不是整形变量，所以<code>d = 10 - *d;</code> 这样是错的。不能将一个int型赋值给一个指针变量</p>
</li>
<li><p>表达式是一个值，若这个值的存储位置没有清晰定义的话，这个表达式只能是右值，不能是左值</p>
</li>
<li><p><code>*cp++</code> 这个表达式中 ++ 优先级高于 * 。执行步骤</p>
<ol>
<li>++操作符先生成一份cp的拷贝</li>
<li>对cp执行加一的操作</li>
<li>现在cp++执行完成，他是第一步中cp的拷贝；再执行*操作，取这个拷贝指向的地址的值</li>
</ol>
</li>
<li><p><code>NULL</code> <code>&#39;\0&#39;</code> 的int值都是 0</p>
</li>
<li><p>指针运算很智能。就以指针加一的运算为例。</p>
<ol>
<li>char类型占据一个字节，所以指向char的指针加一，也就是地址加一，指向下一个char</li>
<li>float类型可能占据4个字节，那么指向float的指针加一，其实是地址加4，结果也是指向下一个float</li>
</ol>
</li>
<li><p>两个指针可以相减（这两个指针必须指向同一个数组中的元素），相减的结果的类型是 <strong>ptrdiff_t</strong> ，一种有符号整数类型。结果是两指针在内训中的距离，注意还是以数组元素的长度为单位，不是以字节为单位。</p>
</li>
<li><p>对指针执行<code>&lt; &lt;= &gt; &gt;=</code>操作也是可以的，同样，两指针必须指向同一数组的元素</p>
</li>
<li><p>可以对任意两指针执行相等或不相等的测试，指向同一地址的两指针相等</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>函数原型很重要，如果没有函数原型，就调用函数（ps：函数调用发生在函数定义之前），那么默认的是返回整形。这时举个例子，调用的函数返回的是float，float存放在内存中的是二进制，但是编译器会将他解释成int；如果将这个函数返回值赋给float，这个值也是int型转化的float，不是原来的float。</li>
<li>C函数的参数都是传值调用，就是传递拷贝，不改变原值；传指针的话，可以改变指针指向的值，但是也是传值调用，因为传递的是指针的拷贝</li>
<li><strong>ADT</strong> 抽象数据类型</li>
<li>可变参数列表是通过宏来实现的，这些宏位于 stdrag.h 头文件中。PS 有点不懂</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li><p>数组名是一个指向其他类型的指针常量（比如指向int型的），不能修改它的指向。也就是说数组名是一个指针，但是不能被赋值。</p>
</li>
<li><p>注意，<code>int a[10]; sizeof(a);</code> 使用sizeof时，并不是求指针的长度，而是数组的长度</p>
<pre><code class="c">int a = 10;
int *b = &amp;a；
int c[10];
sizeof(b); // b的大小是8字节，因为他是指针
sizeof(c); // c的大小是40字节，因为他是int型数组，有10个4字节的int
</code></pre>
</li>
<li><p>数组的下标引用和指针操作是一样的。一下几种写法等价</p>
<pre><code class="c">array[2]; 
*(array + 2);
*(2 + array);
2[array];
</code></pre>
</li>
<li><p>指针有时效率比下标引用快</p>
</li>
<li><p>注意，数组和指针还是有区别的，</p>
<pre><code class="c">int a[5]; // 分配了5个int的内存空间，a指向第一个int内存空间，并没有说明a指针存放在哪里
int *b; // 分配了一个指针变量的内存空间，用来存放b指针，但是没有分配int内存空间，也没有说明b指向哪里
</code></pre>
</li>
<li><p>注意，数组名是个指针常量，不能被修改它的指向。但是，当它被当成参数传递给函数时，函数接收到的是一个指向数组第一个元素的指针变量，可以修改它的指向。</p>
<pre><code class="c">int strlen(char *string); // 使用这样的函数声明来传递数组名
</code></pre>
</li>
<li><p>再看看数组和指针的区别</p>
<pre><code class="c">char message1[] = &quot;Hello&quot;;
char *message2 = &quot;Hello&quot;;
</code></pre>
<p><img src="/lionheart/1603/array.JPG" alt="array"></p>
</li>
<li><p>二维数组的数组名是一个指向一维数组的指针，多维依次照推</p>
</li>
<li><p>声明一个指向数组的指针</p>
<pre><code class="c">int matrix[3][10];
int (*p)[10] = matrix; // p指向三维数组的第一行
// ps 要避免下面的声明
int (*p)[]; // 最好要声明长度，因为方便指针的运算
</code></pre>
</li>
<li><p>函数传递多维数组时的声明形式如下：</p>
</li>
</ol>
<pre><code class="c">   int matrix[3][10];
   func(matrix);
   // 一下两种原型声明都可以,记得声明低维的长度
   void func(int (*mat)[10]);
   void func(int mat[][10]);
   // ps 下面这样的声明是不对的
   void func(int **mat); // 这传递的是指向整形指针的指针，而不是指向数组的指针
</code></pre>
<p>1.1111111111111112e+3211111111111111121111111111111111. 指针数组：元素都是指针的数组：<code>int *p[10];</code> p是一个数组，长度为10，元素是int型指针</p>
<p>1.1111111111111112e+3211111111111111121111111111111111. 看看这段代码</p>
<pre><code class="c">   /* size of char is 1, size of char * is 8*/
          char a = &#39;a&#39;;
          char *b = &amp;a;
          printf(&quot;size of char is %ld, and size of char * is %ld\n&quot;, sizeof(a), sizeof(b)); 

          /* size of keyword 36 ,因为有36个char；size of keyp 32，因为有4个char型指针；
             size of keyword[0] 9,因为一维数组有9个char； size of keyp[0] 8,因为是一个char型指针 */
          char const keyword[][9] = {
                  &quot;do&quot;,
                  &quot;haha&quot;,
                  &quot;hehe&quot;,
                  &quot;yeah&quot;
          };

          char const *keyp[] = {
                  &quot;do&quot;,
                  &quot;haha&quot;,
                  &quot;hehe&quot;,
                  &quot;yeah&quot;
          };
          printf(&quot;size of keyword is %ld, and size of keyp is %ld&quot;, sizeof(keyword[0]), sizeof(keyp[0]));
          printf(&quot;size of keyword is %ld, and size of keyp is %ld&quot;, sizeof(keyword[0]), sizeof(keyp[0]));
</code></pre>
<h3 id="字符串、字符和字节"><a href="#字符串、字符和字节" class="headerlink" title="字符串、字符和字节"></a>字符串、字符和字节</h3><ol>
<li><p>字符串以一个位全为0的NUL字节结尾，注意是字节，但是这个字节不属于字符串</p>
</li>
<li><p>字符串长度，就是包含的字符数，不包括NUL结尾字节，使用<code>strlen</code>函数取得</p>
<pre><code class="c">size_t strlen(char const *string); //这里返回的是size_t,无符号整形
</code></pre>
<p>因为无符号整形是不会为负数的，所以注意这两种写法</p>
<pre><code class="c">if (strlen(x) &gt;= strlen(y)) ...  // right
if (strlen(x) - strlen(y) &gt;= 0) ... // wrong
</code></pre>
<p>第一种是对的，但是第二种是错的。因为两个无符号整形相减还是无符号整形，不可能是负数，所以if里面的判断始终正确。无符号整形要和有符号的计算时，最好先强制转化成int型</p>
</li>
<li><p><code>strcpy</code>用拷贝字符串，<code>strcat</code>用于连接字符串；他们返回值都是新的字符串的首地址，也就是指向首字符的指针</p>
</li>
<li><p><code>strcmp</code>用于两字符串比较，a小于b，返回负值；a等于b，返回0；a大于b，返回正值</p>
</li>
<li><p>查找一个字符：区分大小写</p>
<pre><code class="c">char *strchr(char const *str, int ch); // 在str中找第一个ch字符，返回指向ch的指针，若没有返回NULL指针
char *strrchr(char const *str, int ch); // 同上，找的是最后一个ch字符
</code></pre>
</li>
<li><p>查找任意几个字符：区分大小写</p>
<pre><code class="c">char *strpbrk(char const *str, char const *group); // 在str中查找group中的字符，返回第一个找到的字符的指针
</code></pre>
</li>
<li><p>查找一个子串</p>
<pre><code class="c">char *strstr(char const *s1, char const *s2); // 若s2是一个空字符串，就返回s1
</code></pre>
</li>
<li><p>返回错误信息：</p>
<pre><code class="c">char *strerror(int error_number);
</code></pre>
</li>
<li><p><code>memcpy()</code>函数可以将任意字节数的内容复制到另一个地方，和<code>strcpy</code>不同的是，他碰到NUL字节不会停止工作</p>
</li>
</ol>
<h3 id="结构和联合"><a href="#结构和联合" class="headerlink" title="结构和联合"></a>结构和联合</h3><ol>
<li><p>使用结构将不同类型的值存储在一起，显然数组无法完成这个工作</p>
</li>
<li><p>数组元素可以通过下标来访问，因为他们的长度相同；但是结构不行，因为他的成员类型不同</p>
</li>
<li><p>通过 <strong>.</strong> 来访问成，也就是 <code>结构.成员</code></p>
</li>
<li><p>还可以通过 <strong>-&gt;</strong> 来访问成员，但是适用于结构指针，也就是 <code>结构指针-&gt;成员</code></p>
</li>
<li><p>注意结构的自引用：</p>
<ol>
<li>结构体的成员是结构体本身，这是不合法的。不能确定内存大小，无限递归了</li>
<li>结构体的成员是指向结构体本身的指针，这是合法的。可以确定内存大小，因为指针大小是8字节</li>
</ol>
</li>
<li><p>不完整声明，用于处理两个互相引用的结构体：</p>
<pre><code class="c">struct B; // B的不完整声明
struct A {
      struct B *partner;
}
struct B {
      struct A *partner;
}
</code></pre>
</li>
<li><p>假设px是指向结构体的指针，那么<code>px+1</code>是非法的；这里不像数组</p>
</li>
<li><p><code>*px-&gt;c.b</code> 先执行-&gt;，然后执行 . 操作，最后执行 * 操作</p>
</li>
<li><p>关于结构体边界对齐的三个基本原则</p>
<ol>
<li>普通数据成员对齐规则：第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机为４字节，则要从4的整数倍地址开始存储）。</li>
<li>结构体成员对齐规则：如果一个结构里有某些结构体成员，则该结构体成员要从其内部最大元素大小的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储。）</li>
<li>结构体大小对齐规则：结构体大小也就是sizeof的结果，必须是其内部成员中最大的对齐参数的整数倍，不足的要补齐。</li>
</ol>
</li>
<li><p><code>offsetof(struct, member);</code>函数可以求出member的存储首地址和结构体的存储首地址的偏移量，以字节为单位</p>
</li>
<li><p>在函数调用时，传递结构体不是一个好的方案，可以使用下面的传参方是</p>
</li>
</ol>
<pre><code class="c">   void func(register struct const *structP);
</code></pre>
<p>   传递指向结构体的指针可以提高效率，因为指针的size为8，一般来说是比结构体小很多的。另外添加const修饰，可以防止结构体被修改；另外增加register修饰，将这个指针存放在寄存器上面，可以提高指针访问成员（-&gt;）操作的效率。PS，如果想对结构体进行修改的话，去掉const修饰</p>
<p>1.222222222222222e+32. 联合的所有成员引用的是 <strong>内存中的相同位置</strong> ，当你想在 <strong>不同时刻</strong> 将 <strong>不同的东西</strong> 存放在 <strong>相同的位置</strong> 时，就可以使用联合</p>
<pre><code class="c">   union {
         float f;
         int i;
   } fi;

   fi.f = 3.14159;
   printf(&quot;%d\n&quot;, fi.i);
</code></pre>
<p>   float 和 int 都占据32位的数据，上面的代码先将3.14159这一浮点数以二进制的存放在32位的内存上面；然后fi.i会以int的形式读取相同内存位置上的这32位数据</p>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><ol>
<li><p>数组的长度在运行时才可以知道，但是我们却经常给他一个常量，那么在编译时就会分配给数组以长度大小的内存。所以可以使用动态分配内存</p>
</li>
<li><p><code>malloc</code> 和 <code>free</code> 函数用于执行动态内存的分配和释放。他们维护着一块内存池</p>
</li>
<li><p><code>malloc</code>从内存池中取出一块 <strong>连续</strong> 内存，并将指向这块内存的指针返回；当不需要这块内存时，使用<code>free</code>释放，并将该快内存归还给内存池</p>
<pre><code class="c">void *malloc (size_t size); // 参数是字节数
void free(void *pointer); // 参数是malloc返回的指针
</code></pre>
</li>
<li><p>如果 <code>malloc</code> 无法返回指定大小的内存，就会返回一个NULL指针。他返回的内存的起始位置满足边界对齐的要求</p>
</li>
<li><p><code>void *calloc(size_t num_elements, size_t element_size);</code> 函数在返回内存时，会先将这块内存初始化，全部置为0</p>
</li>
<li><p><code>void realloc(void *ptr, size_t new_size);</code> 函数用于扩大或缩小已经分配出来的内存块(ptr)</p>
</li>
<li><p>传递给 <code>free</code> 函数的指针必须是 <code>malloc</code> <code>calloc</code> <code>realloc</code> 函数返回的指针，不然会报错</p>
</li>
<li><p>动态内存不再使用时，却没有释放，会导致内存泄漏。有些OS，所有的执行程序共享一个内存池，持续的内存泄漏会导致内存池被榨干，导致所有的程序瘫痪，这时只能重启OS；对于其他OS，内存泄漏也会导致该程序的内存池被榨干，导致程序崩溃</p>
</li>
</ol>
<h3 id="使用结构和指针"><a href="#使用结构和指针" class="headerlink" title="使用结构和指针"></a>使用结构和指针</h3><ol>
<li>链表的各个节点，在物理内存上并不相邻</li>
<li>关于单链表和双链表的插入操作，没有细看</li>
</ol>
<h3 id="高级指针话题"><a href="#高级指针话题" class="headerlink" title="高级指针话题"></a>高级指针话题</h3><ol>
<li><p>函数指针：指向函数的指针，再取值之前也要先初始化</p>
<pre><code class="c">int f(int);
int (*pf)(int) = &amp;f; // 初始化函数指针，注意这里的 &amp; 是可选的
</code></pre>
</li>
<li><p>函数指针被初始化之后，调用函数方式有如下几种：</p>
<pre><code class="c">int ans;
ans = f(25);
ans = (*pf)(25);
ans = pf(25);
</code></pre>
<ol>
<li>第一种：编译器先将函数名 <strong>隐式</strong> 的转化成函数指针，然后找到内存中函数的位置，开始执行</li>
<li>第二种：先对pf函数指针取地址，获得函数名(f)；再将函数名转化成函数指针。。。多此一举；最后找到内存中的位置，执行函数</li>
<li>第三种：这就很直接了，直接到对应的地址执行函数</li>
</ol>
</li>
<li><p>回调函数：函数指针；转移表：函数指针数组</p>
</li>
<li><p>命令行参数：</p>
<pre><code class="c">int main(int argc, char **argv);
</code></pre>
<p>main函数的2个参数，argc表示命令行参数的数目，argv指向一个指针数组的首地址。这个argv可以认为是指向的一个字符串数组的第一个。这个字符串数组的第一个元素是程序的名称</p>
<p><img src="/lionheart/1609/argv.png" alt="argv.png"></p>
</li>
<li><p>字符串常量出现在表达式中的时候，它的值是一个指针常量</p>
<pre><code class="c">&quot;xyz&quot; + 1; // 对指向x的指针常量加一，也就是这个表达式的值是指向y的指针，因为 &quot;xyz&quot; 表示一个指向char的指针
</code></pre>
</li>
</ol>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ol>
<li><p>编译C程序的第一步称为 <strong>预处理阶段</strong> ，主要任务就是：删除注释、插入被#include指令包含的文件的内容、定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译</p>
</li>
<li><p><code>#define name stuff</code> 每当有符号name出现，预处理器就用stuff将其替换。来几个例子：</p>
<pre><code class="c">#define reg    register
#define do_forever for(;;)
#define CASE break;case
// 一行定义不完，就加反斜杠
#define DEBUG_PRINT printf(&quot;File %s line %d:&quot; \
                    &quot; x=%d, y=%d, z=%d&quot;, \
                    __FILE__, __LINE__, \
                    x, y, z)  // 注意这里使用了 &quot;相邻的两个字符串自动结合成一个字符串的特性&quot;
</code></pre>
</li>
<li><p><code>#define name(paraneter_list) stuff</code>，或称之为宏，本质就是文本的替换</p>
<pre><code class="c">#define SQUARE(x) x * x
</code></pre>
<p>之后使用 <code>SQUARE(5)</code> 就等同于 <code>5 * 5</code> ；文本替换</p>
</li>
<li><p>宏相比与函数，不存在函数调用/返回的额外开销，所以更快</p>
</li>
<li><p>使用 <code>#undef</code> 来移除一个宏定义</p>
</li>
<li><p>条件编译：可以选择代码的一部分是被正常编译还是被完全忽略。用于支持条件编译的基本结构是 <code>#if</code> 和 <code>#endif</code> 指令</p>
<pre><code class="c">#if constant-expression
    statements
#endif
</code></pre>
<p>其中的 constant-expression 是常量表达式，由预处理器进行求值，如果为真，就编译statements，否则就不处理他们。看个例子：</p>
<pre><code class="c">#define DEBUG 1
#if DEBUG
    printf(&quot;x=%d, y=%d&quot;, x, y);
#endif
</code></pre>
</li>
<li><p>条件编译还有 <code>#elif</code> <code>#else</code> 这两条指令</p>
</li>
<li><p>条件编译可以测试符号是否被定义</p>
<pre><code class="c">// 下面两句等价 用于判断一个宏是否被定义
#if defined(OS_UNIX)
#ifdef OS_UNIX

// 下面两句等价 用于判断一个宏是否没被定义
#if !defined(OS_UNIX)
#ifndef OS_UNIX
</code></pre>
</li>
<li><p><code>#include</code> 指令替换文件的内容到这条指令的位置，这样一个头文件被包含到10个源文件中，他就被编译10次；这会涉及一些开销，不过我们不用在意</p>
</li>
<li><p><code>#include &lt;filename&gt;</code> 库文件。编译器会定义一系列的标准位置，这条文件包含指令会在这些标准位置里寻找库文件。例如，UNIX OS里，编译器会在 /usr/include 目录里面查找库文件。编译器有一个命令行选项，可以让你添加目录，那么这个目录也会是搜索的一个target</p>
</li>
<li><p><code>#include &quot;filename&quot;</code> 现在源文件的当前目录下面寻找，没有的话再到库文件里面寻找</p>
</li>
<li><p>一个头文件可能被一个源文件包含几次，也就是多重包含。解决这个问题的方法是在编写头文件时使用如下方法：</p>
</li>
</ol>
<pre><code class="c">   #ifndef _HEADERNAME_H
   #define _HEADERNAME_H 1
   /*
   ** all the statements
   */
   #endif
</code></pre>
<p>   这样，当第一次包含时，正常编译；第二次包含时，由于已经定义了 _HEADERNAME_H 就不再编译了</p>
<h3 id="输入-输出函数"><a href="#输入-输出函数" class="headerlink" title="输入/输出函数"></a>输入/输出函数</h3><ol>
<li><p>对C程序而言，所有的I/O操作只是简单的从程序 <strong>移进或移出字节的事情</strong> 。所有这种字节流被称为 <strong>流</strong> 。程序只需关心 <strong>创建正确的输出字节数据和正确的解释从输入读取的字节数据</strong> 。不需要关心特定的I/O设备</p>
</li>
<li><p>有2种缓冲区(buffer)，输入缓冲区和输出缓冲区。这些缓冲区都是一块内存区域。程序输出数据会先写入输出缓冲区，然后再写入文件或输出给设备；输入数据（文件读取数据，键盘输入数据）也会先写入输入缓冲区，然后再交给程序。</p>
</li>
<li><p>一般来说，这些缓冲区都是要先填满，再给到设备或是程序的。所以使用printf时，先将要print的数据写入缓冲区，不会立即显示在屏幕上，如果这时候程序崩溃了，他可能就永远无法显示出来了</p>
</li>
<li><p>流分为 <strong>文本流</strong> 和 <strong>二进制流</strong> </p>
</li>
<li><p>文本流在不同OS中某些特性会不同：一种是文本行的最大长度；另一种是文本行的结束方式，在MS-DOS系统中使用回车符和换行符表示一行结束，在UNIX中使用换行符表示一行结束。</p>
</li>
<li><p>但是在代码中不必操心，库函数会帮你处理这些差异。比如在MS-DOS上执行c程序，输出时会将文本中的换行符转化成回车符/换行符的形式写入文件；输入时，从文本读取的回车符/换行符也会转化成换行符交给程序</p>
</li>
<li><p>系统运行时至少提供3个流：标准输入(stdin)，标准输出(stdout)和标准错误(stderr)；这些流的名字分别是 <code>stdin</code> <code>stdout</code> <code>stderr</code>；他们都是一个指向FILE结构体的指针。FILE结构体在stdio.h中定义，与物理磁盘上面的文件没有关系。</p>
</li>
<li><p>标准输入默认是键盘，标准输出默认是屏幕。可以修改默认的输入和输出设备，也就是重定向，比如：</p>
<pre><code class="shell">$ ./program &lt; data &gt; answer
</code></pre>
<p>上面的命令将从文件data读取数据，将数据输出到answer文件</p>
</li>
<li><p>关于流的处理流程</p>
<ol>
<li>使用 <code>fopen</code> 函数打开一个流，这里你必须指定需要访问的文件或是设备，以及访问方式：读、写、读写；该函数验证文件或设备的存在性，并初始化与这个流对应的FILE结构体。一个流对应一个FILE结构</li>
<li>根据需要对该文件或设备进行读写</li>
<li>最后使用 <code>fclose</code> 函数关闭流，不再对文件和设备进行操作</li>
<li>注意：标准流的I/O更加的简单，因为他们不需要打开和关闭。标准流就是 stdin, stdout, stderr</li>
</ol>
</li>
<li><p><code>FILE *fopen(char const *name, char const *mode);</code> 函数打开流，name是文件或设备的名称，mode是读写模式。成功返回一个FILE结构指针，这个结构体代表一个新建的流；失败返回NULL指针，errno会提示问题的性质</p>
</li>
</ol>
<pre><code class="c">   FILE *input;
   input = fopen(&quot;data&quot;, &quot;r&quot;); // 以只读打开文件data
   if (input == NULL) { // 打开失败
         perror(&quot;data&quot;);
         exit(EXIT_FAILURE);
   }
</code></pre>
<p>   打开失败的类似输出： <code>data : No such file or directory</code></p>
<ol>
<li><p><code>int fclose(FILE *f);</code> 函数关闭流。对于输出流，在关闭之前，先刷新缓冲区。执行成功，返回0；执行失败，返回EOF</p>
</li>
<li><p>当一个流被打开之后可以用于输入和输出，包括字符，文本行和二进制的输入和输出3种类型</p>
</li>
<li><p>字符I/O</p>
</li>
<li><p>从流中读取字符</p>
<pre><code class="c">      int fgetc(FILE *stream);
      int getc(FILE *stream);
      int getchar(void);
</code></pre>
<pre><code>  getchar从标准输入流中读取，所以不需要指定流。注意：读取字符，但是返回的还是int型；没有更多字符的话返回EOF
</code></pre><ol>
<li><p>向流中写入字符</p>
<pre><code class="c">int fputc(int character, FILE *stream);
int putc(int character, FILE *stream);
int putchar(int character);
</code></pre>
<p>失败返回EOF</p>
</li>
</ol>
</li>
<li><p>未格式化的行I/O：简单读取或写入字符串</p>
</li>
<li><p>从流中读取行</p>
<pre><code class="c">      char *fgets(char *buffer, int buffer_size, FILE *stream);
      char *gets(char *buffer);
</code></pre>
<pre><code>  最好不适用gets。 **这里的buffer就是之前所说的缓冲区，原来这个缓冲区使我们自己建的，还指明了大小** 。fgets可以这样理解：从流中读取最多 buffer_size - 1 个字符到存储到缓冲区，若到了行尾就不读了，返回的是指向缓冲区首地址的指针。这里的 **从流中读取** 可以理解成 **从文件中读取** ；读取完成后，**存放到程序自己制定的buffer缓冲区中** 
</code></pre><ol>
<li><p>向流中写入行</p>
<pre><code class="c">int fputs(char const *buffer, FILE *stream);
int puts(char const *buffer);
</code></pre>
<p>注意：可以写入多行，就是buffer里面有多少写多少 </p>
</li>
</ol>
</li>
<li><p>格式化的行I/O：也就是 <code>scanf</code> <code>printf</code> 家族函数</p>
</li>
<li><p>二进制I/O：效率最高，使用 <code>fread</code> <code>fwrite</code>函数</p>
</li>
</ol>
<pre><code class="c">   size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
   size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream);
</code></pre>
<p>   buffer解释为一个或多个值的数组；count表示数组中有多少个值，也就是要读取或写入的元素个数；size是缓冲区中每个元素的字节数；返回的是实际读取或写入的元素个数，不一定和count相等</p>
<pre><code class="c">   struct VALUE {
         long a;
         float b;
         char c[SIZE];
   } values[ARRAY_SIZE];
   n_values = fread(values, sizeof(struct VALUE), ARRAY_SIZE, input_stream);

   fwrite(values, sizeof(struct VALUE), ARRAY_SIZE, output_stream);
</code></pre>
<ol>
<li><p><code>int fflush(FILE *stream);</code> 函数迫使输出流缓冲区内的数据进行物理写入。可以这样理解，上面几段代码中的buffer是一种缓冲区，对于写入操作而言，buffer缓冲区中的值写入流；流写入一个与之对应的真正的缓冲区，这个缓冲区就是第二点里说道的缓冲区，当该缓冲区满时，将他写入文件。</p>
</li>
<li><p><code>long ftell(FILE *stream);</code> 返回流当前的位置，他的返回值表示距离文件起始的偏移量。在二进制中，这个值就是距离文件起始的字节数</p>
</li>
<li><p><code>int fseek(FILE *stream, long offset, int from);</code> 将流中的当前的‘指针’，从from偏移offset个位置，也就是改变下一次读写的位置。from参数可以是 <code>SEEK_SET(起始位置)</code> <code>SEEK_CUR(当前位置)</code> <code>SEEK_END(结尾位置)</code></p>
<h3 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h3></li>
<li><p><code>int rand(void);</code> 函数返回一个0-RAND_MAX(至少是32767)的整形。为了避免每次运行程序时得到相同的结果，可以使用 <code>void srand(unsigned int seed);</code>设置不同的种子。比如：</p>
<pre><code class="c">srand((unsigned int) time(0)); // 使用现在的时间
</code></pre>
</li>
</ol>
<h3 id="经典抽象数据类型"><a href="#经典抽象数据类型" class="headerlink" title="经典抽象数据类型"></a>经典抽象数据类型</h3><ol>
<li>C语言中创建堆栈(stack)的方式有3种：静态数组，动态分配内存数组，链式堆栈</li>
<li>树的4中常见遍历方式：<ol>
<li>前序遍历：先检查当前节点，在递归遍历左子树和右子树</li>
<li>中序遍历：先遍历左子树，再检查当前节点，再遍历右子树</li>
<li>后序遍历：先遍历右子树，再检查当前节点，再遍历左子树</li>
<li>层次遍历：逐层检查，先根节点，再它的孩子，再它的孙子…</li>
</ol>
</li>
</ol>
<h3 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h3><ol>
<li>程序包括几个区段：数据区(data)、代码段(text)</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/b_h_l/article/details/7738217" target="_blank" rel="external">C结构体边界对齐</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[看YYKit的源码]]></title>
      <url>/2016/08/15/YYKit-source-code-analysis/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>YYKit</strong> 源码分析 之 <strong>YYCache</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><strong>YYCache</strong> 是一个线程安全的 <strong>key-value</strong> 的缓存框架。使用 <strong>YYMemoryCache</strong> 来将对象存放在小且快的内存中；使用 <strong>YYDiskCache</strong> 来将对象存放在较慢的磁盘上。</p>
<h2 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h2><p>先来看看 <strong>YYCache</strong> 的工作流程。</p>
<h3 id="创建Cache-init"><a href="#创建Cache-init" class="headerlink" title="创建Cache(init)"></a>创建Cache(init)</h3><p>使用下面代码可以创建一个叫做vanney的新的cache。</p>
<pre><code class="objective-c">YYCache *newCache = [YYCache alloc] initWithName:@&quot;vanney&quot;];
</code></pre>
<p>这句语句所做的事情如下：</p>
<ol>
<li>物理层面<ol>
<li>在APP的 <strong>Caches</strong> 目录下面新建一个 <strong>vanney</strong> 的子目录，这个目录用来存放所有属于vanney的cache</li>
<li>在vanney目录下面新建一个 <strong>manifest</strong> 的sqlite数据库，这个数据库用来记录属于vanney的所有cache的信息，数据库的每一行记录表示一个cache。每一行的信息包括：<ol>
<li><strong>key</strong> : cache的唯一标识。manifes的主键</li>
<li><strong>filename</strong> : 如果cache的数据大于设置的值的话（默认是20KB），会将cache的二进制数据存放到一个文件中，这个filename就是该cache对应的文件名</li>
<li><strong>size</strong> : cache的大小，单位是byte</li>
<li><strong>inline_data</strong> : cache的二进制数据，如果cache以文件形式存放的话，这里就为空</li>
<li><strong>modification_time</strong> : 上一次对该cache的修改时间</li>
<li><strong>last_access_time</strong> : 上一次使用该cache的时间</li>
<li><strong>extended_data</strong> : 一些额外的数据</li>
</ol>
</li>
<li>在vanney的目录下创建 <strong>data</strong> 的文件夹，用来存放以文件形式存在的cache</li>
<li>在vanney的目录下创建 <strong>trash</strong> 的文件夹，删除cache时会将data中的文件先移到trash中，然后再异步的删除该文件夹里面的文件</li>
</ol>
</li>
<li>程序层面<ol>
<li>创建了一个 <strong>YYDiskCache</strong> 。后面会细说</li>
<li>创建了一个 <strong>YYMemoryCache</strong> 。后面会细说</li>
</ol>
</li>
</ol>
<h3 id="往Cache里面新增记录-set"><a href="#往Cache里面新增记录-set" class="headerlink" title="往Cache里面新增记录(set)"></a>往Cache里面新增记录(set)</h3><p>也就是所谓的 <strong>set</strong> 方法。使用下面代码可以新增一条cache记录</p>
<pre><code class="objective-c">[newCache setObject:@&quot;New Record&quot; forKey:@&quot;New Key&quot;];
</code></pre>
<p>这里newCache做了两件事：</p>
<ol>
<li>往YYMemoryCache里面写入这条数据</li>
<li>往YYDiskCache里面写入这条数据</li>
</ol>
<h3 id="向Cache中读取缓存记录-get"><a href="#向Cache中读取缓存记录-get" class="headerlink" title="向Cache中读取缓存记录(get)"></a>向Cache中读取缓存记录(get)</h3><p>也就是所谓的 <strong>get</strong>  方法。使用下面代码可以读取一条cache记录</p>
<pre><code class="objective-c">NSString *cacheValue = [newCache objectForKey:@&quot;New Key&quot;];
</code></pre>
<ol>
<li>现从memory里面获取这个cache，也就是从YYMemoryCache里面获取</li>
<li>如果没有发现的话，就从YYDiskCache里面获取，再将它存放到YYMemoryCache中</li>
</ol>
<h3 id="从Cache中删除记录-remove"><a href="#从Cache中删除记录-remove" class="headerlink" title="从Cache中删除记录(remove)"></a>从Cache中删除记录(remove)</h3><p>也就是 <strong>remove</strong> 方法。</p>
<pre><code class="objective-c">[newCache removeObjectForKey:@&quot;New Key&quot;];
</code></pre>
<ol>
<li>从YYMemoryCache中删除</li>
<li>从YYDiskCache中删除</li>
</ol>
<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p>YYDiskCache负责将cache存放在物理硬盘中，也就是上面所说的，存放在 <strong>Cache</strong> 目录下面的相应的cacheName下面，（例子中使用的是 <strong>vanney</strong> 目录）。存放的方式是：</p>
<ol>
<li>使用sqlite数据库记录所有的cache的信息</li>
<li>大于某个限额的cache以文件形式存放，在数据库中记录下该cache对应的文件名；而对于小型的cache就直接将二进制的数据存放在数据库里面就好了</li>
</ol>
<h3 id="初始化-init"><a href="#初始化-init" class="headerlink" title="初始化(init)"></a>初始化(init)</h3><p>使用下面的代码初始化一个YYDIskCache，</p>
<pre><code class="objective-c">YYDiskCache *diskCache = [YYDiskCache alloc] iniwtWithPath:path];
</code></pre>
<ol>
<li>有一个全局的存放YYDiskCache的 <strong>NSMapTable</strong> ，以path为 <strong>key</strong> 。这里的path就是上面所说的 <strong>vanney</strong> 目录，以YYDiskCache为 <strong>value</strong> 。</li>
<li>先从这个NSMapTable中找看是否有这个path的YYDiskCache，有就直接返回</li>
<li>没有的话，就开始创建。这个创建过程如下：<ol>
<li>创建 <strong>vanney</strong> 文件夹</li>
<li>创建 <strong>vanney</strong> 文件夹下面的各个部件： <strong>data</strong> ，<strong>trash</strong> 文件夹和 <strong>manifest</strong> 数据库</li>
<li>将创建的YYDiskCache以 <strong>path</strong> ：<strong>YYDiskCache</strong> 的形式存放在全局的NSMapTable中</li>
</ol>
</li>
<li>添加一些观测事件</li>
</ol>
<h3 id="写入缓存-set"><a href="#写入缓存-set" class="headerlink" title="写入缓存(set)"></a>写入缓存(set)</h3><p>使用下面的代码写入Disk缓存：</p>
<pre><code class="objective-c">[diskCache setObject:@&quot;DiskCache&quot; forKey:@&quot;DiskCacheKey&quot;];
</code></pre>
<ol>
<li>先将object，这里就是 <em>DiskCache</em> 字符串压缩，使他变成一个 <strong>NSData</strong></li>
<li>如果NSData大小没超过限制，那么将这条cache以 <strong>key : DiskCacheKey</strong>  <strong>value:NSData</strong> <strong>filename:NULL</strong> 的形式写入manifest数据库</li>
<li>如果NSData的大小超过限制的话，先将NSData写入文件名为 <strong>md5(DiskCacheKey)</strong> 的文件中，文件存放在 <strong>data</strong> 文件夹；然后再将这条cache以 <strong>key:DiskCacheKey</strong> <strong>value:NULL</strong> <strong>filename:md5(DiskCacheKey)</strong> 的形式写入manifest数据库</li>
</ol>
<h3 id="读取缓存-get"><a href="#读取缓存-get" class="headerlink" title="读取缓存(get)"></a>读取缓存(get)</h3><p>使用下面的代码读取Disk缓存:</p>
<pre><code class="objective-c">NSString *diskCacheValue = [diskCache objectForKey:@&quot;DiskCacheKey&quot;];
</code></pre>
<ol>
<li>进入数据库获取key为DiskCacheKey的记录，并且修改这条记录的 <strong>last_access_time</strong> </li>
<li>如果是将cache存放在数据库的话，获取数据库的value字段；如果是以文件形式存在的话，读取存放NSData的文件</li>
<li>将cache的NSData解压，还原成最初的形式，返回</li>
</ol>
<h3 id="删除缓存-remove"><a href="#删除缓存-remove" class="headerlink" title="删除缓存(remove)"></a>删除缓存(remove)</h3><p>使用下面的代码删除Disk的缓存：</p>
<pre><code class="objective-c">[diskCache removeObjectForKey:@&quot;DiskCacheKey&quot;];
</code></pre>
<ol>
<li>删除数据库中key为DiskCacheKey的记录</li>
<li>如果存在文件的话，删除</li>
</ol>
<h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p>YYMemoryCache维护着一个双向链表(<strong>YYLinkedMap</strong>)，链表里面的每一个节点就是一个memory的缓存记录，表头的节点表示最近访问过的，表尾的节点很久没去访问了。每个节点是一个 <strong>YYLinkedMapNode</strong> 对象，这个对象里面有指向前后节点的指针，和包含缓存信息的 <strong>key</strong> 和 <strong>value</strong> 属，以及一些缓存的其他属性：<strong>cost</strong> 和 <strong>time</strong> </p>
<h3 id="初始化-init-1"><a href="#初始化-init-1" class="headerlink" title="初始化(init)"></a>初始化(init)</h3><p>使用下面的代码初始化一个YYMemoryCache：</p>
<pre><code class="objective-c">YYMemoryCache *memoryCache = [YYMemoryCache new];
</code></pre>
<ol>
<li>新建一个YYLinkedMap</li>
<li>添加一些监听事件，设置一些属性等等</li>
</ol>
<h3 id="写入缓存-set-1"><a href="#写入缓存-set-1" class="headerlink" title="写入缓存(set)"></a>写入缓存(set)</h3><p>使用下面的代码写入缓存：</p>
<pre><code class="objective-c">[memoryCache setObject:@&quot;Memory Cache&quot; forKey:@&quot;MemoryCacheKey&quot;];
</code></pre>
<ol>
<li>先在YYLinkedMap中寻找是否有这个key，YYLinkedMap对象中有一个dic属性，它是一个键值对，键就是每个cache的key，值就是每个cache对应的YYLinkedMapNode</li>
<li>如果存在的话，那就修改这个key对应的YYLinkedMapNode的value为<code>@&quot;Memory Cache&quot;</code>，并且修改它的其他属性，将time属性改为现在的时间，并将这个Node放在链表的表头。</li>
<li>如果不存在的话，就直接生成一个YYLinkedMapNode，放在链表的表头</li>
</ol>
<h3 id="读取缓存-get-1"><a href="#读取缓存-get-1" class="headerlink" title="读取缓存(get)"></a>读取缓存(get)</h3><p>使用下面的代码读取缓存：</p>
<pre><code class="objective-c">NSString *cacheValue = [memoryCache objectForKey:@&quot;MemoryCacheKey&quot;];
</code></pre>
<ol>
<li>从YYLinkedMap的dic中获取key为MemoryCacheKey的YYLinkedMapNode，修改node的time，并将这个node放在链表的表头</li>
<li>返回所需的缓存，也就是node的value属性</li>
</ol>
<h3 id="删除缓存-remove-1"><a href="#删除缓存-remove-1" class="headerlink" title="删除缓存(remove)"></a>删除缓存(remove)</h3><p>使用下面的代码删除缓存：</p>
<pre><code class="objective-c">[memoryCache removeObjectForKey:@&quot;MemoryCacheKey&quot;];
</code></pre>
<ol>
<li>删除YYLinkedMap中的dic里面的key为MemoryCacheKey的YYLinkedMapNode</li>
<li>调整双向链表</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关于线程安全"><a href="#关于线程安全" class="headerlink" title="关于线程安全"></a>关于线程安全</h3><h4 id="YYDiskCache-1"><a href="#YYDiskCache-1" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h4><ol>
<li><p>每个YYDiskCache有一个信号量为1的锁 <em>_lock</em> ，使用 <code>dispatch_semaphore_create(1);</code>来创建。当对这个YYDiskCache里面的数据进行操作时，比如添加或者读取缓存时，一次只允许一个操作在进行。</p>
</li>
<li><p>还有一个信号量也为1的全局的锁 <em>_globalInstancesLock</em> ，它用来对存储每个YYDiskCache的NSMapTable进行加锁，对这个NSMapTable进行读写的操作只能同时存在一个。</p>
</li>
<li><p>每一个YYDiskCache有一个并行的queue，这个queue用来执行读写删之后的block。因为有这样的API:</p>
<pre><code class="objective-c">- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id&lt;NSCoding&gt; _Nullable object))block;
</code></pre>
<p>所以这里的block就在这个queue里面执行，达到多线程操作的效果</p>
</li>
</ol>
<h4 id="YYMemoryCache-1"><a href="#YYMemoryCache-1" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h4><ol>
<li>每一个YYMemoryCache都有一个<code>pthread_mutex_t</code>锁，同理，对YYMemoryCache的写入和读取缓存等操作只能同时存在一个。</li>
<li>有一个YYMemoryCacheGetReleaseQueue， 用来释放删除的缓存。 这里还需要细看代码。。。</li>
</ol>
<h3 id="关于各种限制"><a href="#关于各种限制" class="headerlink" title="关于各种限制"></a>关于各种限制</h3><p>YYCache可以设置各种限制，比如缓存的最大数量，最大size以及缓存的生存时间等等。对于YYDiskCache和YYMemoryCache有两套不同的处理方法。当然也有相同的一点就是：他们都会定时清理缓存，在新建一个YYDiskCache或YYMemoryCache时，都会设一个定时事件，按时清理缓存。</p>
<h4 id="YYDiskCache-2"><a href="#YYDiskCache-2" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h4><p>在YYDiskCache里面，每一个cache的大小都在数据库里面的size字段里面有记录，而最近的缓存操作时间也有记录。如果操过某个限制的话，比如总容量限制或总数量限制或者存活时间限制，那么会删掉最长时间没有去使用的缓存。这个操作很简单，只需要对数据库的各个缓存按时间排序就行了。</p>
<h4 id="YYMemoryCache-2"><a href="#YYMemoryCache-2" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h4><p>在YYMemoryCache里面，使用双向链表来记录每个缓存的使用情况。表头的表示刚刚使用过，而表尾的则很久没使用了。每个YYLinkedMapNode都有记录自己的time和cost，而YYLinkedMap则有记录总的cost和总的缓存数量。当超过某个限制的话，就会从表尾开始删除缓存，直到达到要求</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS与OS X多线程和内存管理 - GCD]]></title>
      <url>/2016/08/02/OC-ARC-GCD-reading-note-three/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS与OS X多线程和内存管理 读书笔记（三） <strong>GCD</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h3><ol>
<li><strong>GCD</strong>：Grand Central Dispatch，大中枢派发，很牛逼的名字</li>
</ol>
<h3 id="GCD的API"><a href="#GCD的API" class="headerlink" title="GCD的API"></a>GCD的API</h3><ol>
<li><p><code>dispatch_async(queue, block);</code></p>
<p>将想要执行的任务封装进Block，放他到queue中执行。这里的queue有两种：</p>
<ol>
<li>一种是<strong>Serial Dispatch Queue</strong>，顺序队列，放入这里面的block任务是一个一个执行的，先进先出。</li>
<li>另一种是 <strong>Concurrent Dispatch Queue</strong>，并行队列，意思就是会开多个队列，block一次进入各个队列同时执行；但是队列的数量由系统控制，那些还来不及进入任何一个队列执行的block，只能等某个队列的block执行完了，再进入队列执行了；所以说这里的每个block的执行顺序是不确定的。</li>
</ol>
<p><strong>PS</strong>：当然你也可以同时开多个顺序队列，以达到并行队列的效果；但是不能多开，因为程序在各个队列之间切换，也就是在各个线程之间切换，也就是所谓的上下文切换，需要耗费CPU等资源。当然存放每个线程的状态等信息也需要耗费资源。</p>
</li>
<li><p><code>dispatch_queue_create;</code></p>
<p>这个API用来生成Dispatch Queue。看看下面代码：</p>
<pre><code class="objective-c">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&quot;com.vanney9.serialQueue&quot;, NULL);
</code></pre>
<p>上面的代码用来生成一个Serial dispatch queue，这个函数有两个参数：第一个是queue的名字，最好唯一；第二个是代表生成的queue的类型，若指定为NULL，则生成serial dispatch queue，若指定为<code>DISPATCH_QUEUE_CONCURRENT</code>，则生成concurrent dispatch queue。返回类型是<em>dispatch_queue_t</em>。</p>
<p><strong>PS</strong>：生成的queue，要通过<code>dispatch_release</code>函数手动释放。</p>
</li>
<li><p><code>dispatch_get_main_queue();</code></p>
<p>这个函数用来获取程序的主线程，主线程只有一个，当然是serial dispatch queue。追加到主线程执行的任务会在主线程的Runloop中执行。</p>
</li>
<li><p><code>dispatch_get_global_queue(level, 0);</code></p>
<p>这个函数用来获取Global dispatch queue。它是一个Concurrent dispatch queue。它有4个人优先级：High Priority，Default Priority，Low Priority和Background Priority。</p>
</li>
<li><p><code>dispatch_set_target_queue</code> （有点晕）</p>
<p>该函数用来设置queue的优先级。默认情况下，使用<code>dispatch_queue_create</code>生成的queue都是和Global dispatch queue的默认优先级相同。可以使用该函数来改变优先级：</p>
<pre><code class="objective-c">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.vanney9.serialQueue&quot;, NULL); // 优先级为Default Priority
dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); // 获取Background Priority的queue
dispatch_set_target_queue(mySerialQueue, globalBackgroundQueue); // 设置mySerialQueue的优先级和globalBackgroundQueue的相同
</code></pre>
</li>
<li><p><code>dispatch_after(time, queue, block);</code></p>
<p>该函数表示在time时间之后（比如3s后）将block加到queue中。</p>
</li>
<li><p>Dispatch Group</p>
<p>追加到dispatch queue中的多个处理都结束时，想进行一些处理该如何实现呢？对于serial dispatch queue，这很简单；但是如果是concurrent dispatch queue，这时候就需要<strong>Dispatch Group</strong>。如下：</p>
<pre><code class="objective-c">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //先创建一个concurrent queue
dispatch_group_t group = dispatch_group_create(); // 创建一个group

/* 再将3个Block添加到这个queue中，并且属于同一个group */
dispatch_group_async(group, queue, ^{NSLog(@&quot;blk1&quot;);});
dispatch_group_async(group, queue, ^{NSLog(@&quot;blk2&quot;);});
dispatch_group_async(group, queue, ^{NSLog(@&quot;blk3&quot;);});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{NSLog(@&quot;Done&quot;);}); // 全部结束后通知主线程，将Block追加到主线程中

dispatch_release(group); // 释放group。因为Global dispatch queue不需要我们手动释放
</code></pre>
<p>上面的<code>dispatch_group_notify</code>函数在group中的三个block全部都执行完之后，才会将<code>^{NSLog(@&quot;Done&quot;);}</code>这一个Block追加到主线程中去。还可以使用<code>dispatch_group_wait</code>函数，如下：</p>
<pre><code class="objective-c">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull *NSEC_PER_SEC); // 1s的时间
long result = dispatch_group_wait(group, time); // 表示group经过1s之后，是什么结果
if (result == 0) {
      /* result == 0，那么group中的Block已经全部处理完 */
} else {
      /* result != 0， 那么还没处理完 */
}
</code></pre>
<p><strong>PS</strong>：注意，执行<code>dispatch_gropu_wait</code>的线程是处于停滞状态的，只有当该函数返回后，才会执行之后的操作，所以还是推荐使用<code>dispatch_group_notify;</code>，异步，无阻塞。</p>
</li>
<li><p><code>dispatch_barrier_async</code></p>
<p>该函数和concurrent dispatch queue一起使用，看看例子</p>
<pre><code class="objective-c">dispatch_async(queue, blk_reading1); // 注意这里queue是concurrent dispatch queue 
dispatch_async(queue, blk_reading2);
dispatch_async(queue, blk_reading3);
dispatch_barrier_async(queue, blk_writing);
dispatch_async(queue, blk_reading4);
dispatch_async(queue, blk_reading5);
dispatch_async(queue, blk_reading6);
dispatch_async(queue, blk_reading7);
</code></pre>
<p>上面的代码会同时先执行blk_reading1,blk_reading2和blk_reading3这三个读取操作，然后等执行完后再单独执行blk_writing这一写入操作，最后等写入完成后再开始同时执行之后的4的读取操作。</p>
</li>
<li><p><code>dispatch_sync</code></p>
<p>该函数同步执行block，也就是说block不执行完，就一直停留在这个函数这里，容易导致死锁。看看例子：</p>
<pre><code class="objective-c">dispatch_queue_t queue = dispatch_get_main_queue(); // 注意，这段代码在主线程上执行。获取主线程
dispatch_sync(queue, block); // 死锁
</code></pre>
<p><code>dispatch_sync</code>在主线程上将block追加到主线程去处理，这时候程序一直卡在<code>dispatch_sync</code>这里。因为该函数一直在等待block处理结束；但是block的处理也是在主线程上，需要等当前这些操作结束后，才会去执行block。这样就卡住了，死锁，GG。</p>
</li>
<li><p><code>dispatch_apply</code></p>
<p>该函数同样要等待block执行完，才结束。它可以指定block的执行次数。</p>
</li>
<li><p><code>dispatch_suspend(queue)/dispatch_resume(queue)</code></p>
<ol>
<li><code>dispatch_suspend(queue);</code>：挂起queue，未执行的block暂停</li>
<li><code>dispatch_resume(queue);</code>：恢复queue，继续执行之前没有执行的block</li>
</ol>
</li>
<li><p>一些其他API</p>
<ol>
<li>Dispatch Semaphore：更细粒度的多线程控制，类似于信号量</li>
<li><code>dispatch_once</code>：整个应用程序中只执行一次，多线程安全，单例模式</li>
<li>Dispatch I/O：文件分块读取，提高文件读取效率</li>
</ol>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS与OS X多线程和内存管理 - Blocks]]></title>
      <url>/2016/07/29/OC-ARC-GCD-reading-note-two/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS与OS X多线程和内存管理 读书笔记（二） <strong>Blocks</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Blocks概要"><a href="#Blocks概要" class="headerlink" title="Blocks概要"></a>Blocks概要</h3><ol>
<li><p>Blocks：带有自动变量（局部变量）的匿名函数</p>
</li>
<li><p>完整的Block语法与一般的C语言函数定义相比只有2点不同：</p>
<ol>
<li>开头多了^符号</li>
<li>没有函数名</li>
</ol>
</li>
<li><p>看看如何声明Block类型变量：<code>int (^blk)(int);</code>声明了一个参数类型为int，返回类型为int的Block变量blk。</p>
</li>
<li><p><code>typedef int (^blk_t)(int);</code> 那么blk_t代表一个Block变量</p>
</li>
<li><p>Block会自动截获和保存变量值。但是不能更改保存的变量值，除非你使用__block。如下：</p>
<pre><code class="objective-c">int val = 0;
void (^blk)(void) = ^{val = 1}; // 更改自动保存的变量值 报错
blk();

/* 使用__block之后 */
__block int val = 0;
void (^blk)(void) = ^{val = 1}; // 不报错
blk();
</code></pre>
<p><strong>PS</strong>：如果是截获的OC对象，比如截获了NSMutableArray对象array，可以使用array：<code>[array addObject:obj];</code>；但是不能给array赋值：<code>array = [[NSMutableArray alloc] init];</code>。若要给他赋值，还是得使用__block修饰符。</p>
<p><strong>PS</strong>：不会自动截获C语言数组：<code>char text[] = &quot;hello&quot;;</code>；但是可以截获指针：<code>char *text = &quot;hallo&quot;;</code>。</p>
</li>
</ol>
<h3 id="Blocks的实现"><a href="#Blocks的实现" class="headerlink" title="Blocks的实现"></a>Blocks的实现</h3><ol>
<li><p>Block其实就是Objective-C对象 </p>
</li>
<li><p>来看看具体实现</p>
<pre><code class="objective-c">int main() {
      void (^blk)(void) = ^{printf(&quot;Bolck.../n&quot;);};
      blk();
      return 0;
}

/* 经过编译器转化之后 */

/* 下面的结构体表示的是Block对象 */
struct __main_block_impl_0 {
      void *isa; // OC对象都有一个isa指向它的类，表明这个对象是一个什么类

      /* 无关紧要的一些成员 */
      int Flags;
      int Reserved;
      struct __main_block_desc_0 *Desc; // 一个结构体指针，后面会有定义，大概和系统有关

      void *FuncPtr; // 函数指针，指向这个Block的匿名函数，也就是 {printf(&quot;Block.../n&quot;);}

      /* 结构体的初始化函数 */
      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0) {
          // 传入的参数是匿名函数的函数指针，__main_block_desc_0结构体指针和flags
          isa = &amp;_NSConcreteStackBlock; // 初始化isa
          Flags = flags;
          FuncPtr = fp;
          Desc = desc;
      }
}

/* 下面代码的结构体 就是上面Block结构体中的那个无关理解的结构体指针成员的定义 */
static struct __main_block_desc_0 {
      unsigned long reserved;
      unsigned long Block_size;
} __main_block_desc_0_DATA = {
      0,
      sizeof(struct __main_block_impl_0)
};

/* 匿名函数的定义，传入的参数是Block结构体指针 */
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
      printf(&quot;Block.../n&quot;);
}

/* main函数的实现 */
int main {
      void (*blk)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA); // 初始化Block，其实也就是创建Block结构体
      blk-&gt;FuncPtr(blk); // 执行Block，也就是执行Block结构体中的函数，传入结构体本身
      return 0;
}
</code></pre>
<p>上面这个编译的过程就是：</p>
<ol>
<li>在main函数外面，先对Block做定义：Block是一个结构体，他有一个成员是匿名函数的函数指针；这个结构体的构造函数需要传入匿名函数的函数指针。</li>
<li>在main函数外面再定义匿名函数，匿名函数的参数是Block结构体，该参数在截获自动变量时会有用。</li>
<li>定义main函数，先新建一个Block结构体并初始化；在执行Block，也就是执行Block结构体里面的函数指针指向的函数；再return 0。</li>
</ol>
<p><strong>PS</strong>：结构体的初始化里面的<code>isa = &amp;_NSConcreteStackBlock;</code>就是在将结构体当做OC对象在处理，他将OC对象的信息放在isa里面。</p>
</li>
<li><p>看看如何截获自动变量</p>
<pre><code class="objective-c">int main() {
      int dmy = 256; // 不会被截获的变量
      int val = 10; // 被截获
      const chat *fmt = &quot;val = %d/n&quot;;
      void (^blk)(void) = ^{printf(fmt, val);};
      blk();
      return 0;
}

/* 经过编译之后 */

/* Block结构体定义 */
struct __main_block_impl_0 {
      /* 如前所诉 */
      void *isa;
      int Flags;
      int Reserved;
      void *FuncPtr;
      struct __main_block_desc_0 *Desc;

      /* 截获的自动变量，变成了结构体成员 */
      const char *fmt;
      int val;

      /* 初始化函数，这里会使用截获的自动变量对成员进行赋值 */
      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags = 0) :fmt(_fmt), val(_val) {
          /* 如前所诉,就省略了 */
          //...
      }
}

/* __main_block_desc_0结构体定义，同上，省略 */

/* 匿名函数定义 */
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
      const char *fmt = __cself-&gt;fmt;
      int val = __cself-&gt;val;

      printf(fmt, val);
}

/* main函数实现 */
int main() {
      int dmy = 256;
      int val = 10;
      const char *fmt = &quot;val = %d/n&quot;;

      void (*blk)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;main_block_desc_0_DATA, fmt, val); // 这里进行Block的初始化
       blk-&gt;FuncPtr(blk); // 执行Block

      return 0;
}
</code></pre>
<p>从上面可以看出，在初始化得时候，将自动变量传入了Block结构体的初始化函数，进行保存。所以之后对这些自动变量进行修改，Block结构体里面的这些保存在结构体成员里的变量是不受影响的。</p>
</li>
<li><p><strong>__block</strong>的实现</p>
<p>__block变量也定义在main函数之外，不在只是一个简单的变量，而是变成了结构体：</p>
<pre><code class="objective-c">struct __Block_byref_val_0 {
      void *isa;
      __Block_byref_val_0 *__forwarding; // 指向自己的指针
      int __flags;
      int __size;
      int val; // 原来的自动变量
}

/* Block里面含有__block变量的结构体指针 */
struct __main_block_impl_0 {
      /* 同上的成员省略 */
      __Block_byref_val_0 *val; // 指向val结构体的指针

      /* 结构体初始化函数，使用val结构体的__forwarding成员变量初始化Block结构体的val指针 */
      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags = 0) : val(_val-&gt;forwarding) {
          /* 同上 省略 */
      }
}

/* 匿名函数 */
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
      __Block_byref_val_0 *val = __cself-&gt;val;
      val-&gt;forwarding-&gt;val = 1; // 在这里 val和val-&gt;forwarding其实都指的是自己
}

/* main函数里面 */
int main() {
      int val = 10;
      void (^blk)(void) = ^{val = 1;};
}

/* 转化之后 val变成结构体 */
int main() {
      __Block_byref_val_0 val = {
          0,
          &amp;val, // 指向自身的指针
          0,
          sizeof(__Block_byref_val_0),
          10 // 初始化
      };

      blk = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val); // 初始化Block结构体时将val结构体地址传过去
}
</code></pre>
<p>将val变量变成存放在栈上的结构体，这也就是__block变量</p>
</li>
<li><p>Block存储域</p>
<ol>
<li>_NSConcreteStackBlock将Block存放在栈上</li>
<li>_NSConcreteGlobalBlock将Block存放在数据区域</li>
<li>_NSConcreteMallocBlock将Block存放在堆上</li>
</ol>
<p>存放在数据区域的Block相当于全局变量，不能截获自动变量，全局只有一个实例。所有不需要截获自动变量的Block都是这种类型的。</p>
<p>其他的Block都现在栈上生成，但是当超过这个Block的作用域，但是又要使用该Block时，就会将Block从栈上复制到堆上。例如下面的例子：</p>
<pre><code class="objective-c">typedef int (^blk_t)(int);
blk_t func(int rate) {
      return ^(int count)(return rate *count);
}
</code></pre>
<p>这里Block在函数内生成后，返回时就已经离开Block的作用域了。这时候就需要将他copy到堆上</p>
<pre><code class="objective-c">blkt func(int rate) {
      blkt tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);
      tmp = _Block_copy(tmp); // 将栈上的Block复制到堆上
      return objc_autoreleaseReturnValue(tmp); // 将tmp注册到NSAutoreleasePool，说明Block也是OC对象
}
</code></pre>
<p>出了函数之后，栈上的Block就会被释放，这个时候只能使用在堆上的Block了。很多情况下编译器会帮助我们自动复制的，但是NSArray得<code>initWithObjects</code>方法就不会自动复制：</p>
<pre><code class="objective-c">- (id)getBlockArray {
      int val = 10;
      return [[NSArray alloc] initWithObjects:
           ^{NSLog(@&quot;haha&quot;);},
           ^{NSLog(@&quot;yaya&quot;);}, nil];
}

// 这种情况下返回的NSArray，如果去获取NSArray中的Block对象，是会出错的，因为这些Block在出函数时被废弃了， 这时就需要我们手动复制了，也就是调用copy方法

- (id)getBlockArray {
      int val = 10;
      return [[NSArray alloc] initWithObjects:
           [^{NSLog(@&quot;haha&quot;);} copy],
           [^{NSLog(@&quot;yaya&quot;);} copy], nil];
}
</code></pre>
<p><strong>PS</strong>：当Block被复制到堆上时，它 <strong>使用</strong> 的__block变量也会从栈上被复制到堆上，这个时候该变量会被Block <strong>持有</strong>。如果还有在栈上的其他Block使用block变量的话，block变量还会保留在栈上，但是他的 <strong>forwarding</strong>指针已经指向堆上的block变量了，所以改变block变量的话，始终改变的都是同一个结构体。</p>
</li>
<li><p>看看如何截获OC对象</p>
<pre><code class="objective-c">{
      id array = [[NSMutableArray alloc] init];
      blk = [^(id obj) {
          [array addObject:obj];
      } copy];
}

/* 注意 可以理解成 Block里面的array结构体成员强引用NSMutableArray对象 */
struct __main_block_impl_0 {
      id __strong array; // 强引用
}
</code></pre>
<p>但实际上结构体对__strong是没有概念的，不过此时的结构体会手动加上ARC的概念上去。当Block从栈上复制到堆上时，OC对象被Block持有；当Block从堆上废弃时，OC对象被释放。所以，<strong>很重要的一点</strong>：只有Block被复制到堆上时，OC对象，才能被Block持有；也就是要调用Block的copy函数。</p>
</li>
<li><p>__block类型的OC对象</p>
<pre><code class="objective-c">__block id obj = [[NSObject alloc] init];

/* 编译之后 */
struct __Block_byref_obj_0 {
      void *isa;
      __Block_byref_obj_0 *__forwarding;
      int __flags;
      int __size;

      void (*__Block_byref_id_object_copy)(void*, void*); // 用来使Block持有对象
      void (*__Block_byref_id_object_dispose)(void*); // 用来使Block释放对象

      __strong id obj;
}
</code></pre>
<p>所以__block类型的OC对象也是讲OC对象封装成一个结构体，和之前的block类型的自动变量一样，只不过添加了retain和release的概念而已。</p>
<p><strong>PS</strong>：如果对象是weak类型的，和上一篇里面分析weak和strong的一样。Block也只是含有一个指向对象的指针而已，如果该指针为weak，那么该置成nil，还是要置成nil。</p>
</li>
<li><p>看看使用Block的一个常见问题：<strong>循环引用</strong></p>
<p>最常见的就是在Block中使用self，而这个Block还是self对象的一个变量。那么对象持有Block，Block又持有对象。循环引用。所以在Block中使用self经常需要使用weakself。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS与OS X多线程和内存管理 - 自动引用计数]]></title>
      <url>/2016/07/19/OC-ARC-GCD-reading-note-one/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS与OS X多线程和内存管理 读书笔记（一） <strong>自动引用计数</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理/引用计数"></a>内存管理/引用计数</h3><ol>
<li><p>使用办公室的照明灯来做比喻，对象相当于照明灯，但是会有许多人需要这个照明灯，也就是持有对象。只要有人持有这个对象，就不能释放对象；若没人在需要对象，就释放对象。</p>
</li>
<li><p>例如：a = [class new];  b = a; 那么a生成对象时持有对象，b也持有对象。只有当a和b都不持有对象时，才能释放对象。</p>
</li>
<li><p>对于对象，有4个关键词。<strong>生成</strong>，<strong>持有</strong>，<strong>释放</strong>和<strong>废弃</strong>。</p>
</li>
<li><p>看看对应的操作：（以下的方法均是<strong>NSObject</strong>类的方法）</p>
<ol>
<li>使用<code>alloc/new/copy/mutableCopy</code>开头的方法<strong>生成</strong>并<strong>持有</strong>对象</li>
<li><code>retain</code>方法<strong>持有</strong>对象</li>
<li><code>release</code>方法<strong>释放</strong>对象</li>
<li><code>dealloc</code>方法<strong>废弃</strong>对象</li>
</ol>
</li>
<li><p>自己生成的对象自己持有</p>
<pre><code class="objective-c">id obj = [[NSObject alloc] new]; // alloc方法生成并持有对象
// or
id obj = [NSObject new]; // new 和 alloc + init 一样
</code></pre>
<p>另外<code>copy</code>和<code>mutableCopy</code>也是生成对象的副本，并持有。</p>
</li>
<li><p>非自己生成的对象，自己也能持有</p>
<pre><code class="objective-c">id obj = [NSMutableArray array]; // 对象存在了，但是obj对象不持有对象
[obj retain]; // 现在obj已经持有对象了
</code></pre>
</li>
<li><p>不在需要自己持有的对象时释放</p>
<pre><code class="objective-c">id obj = [NSObject new]; // obj持有对象
[obj release]; // obj不再需要对象时，释放对对象。 对象释放后就不能被访问到了。
</code></pre>
<ol>
<li>不持有可以这样理解：可以使用对象，但是没有强行占用对象。</li>
<li>无法释放非自己持有的对象</li>
</ol>
<pre><code class="objective-c">id obj = [NSMutableArray array]; // obj自己不持有对象
[obj release]; // 程序崩溃，因为不能释放不是自己持有的对象
</code></pre>
</li>
<li><p>来看看如何实现alloc/retain/release/dealloc方法 （<strong>注意：这部分对于理解最为关键</strong>）。</p>
<ol>
<li><p>alloc的实现</p>
<pre><code class="objective-c">   struct obj_layout {
         NSUInteger retained;
   }

+ (id)alloc {
      int size = sizeof(struct obj_layout) + 对象大小;
      struct obj_layout *p = (struct obj_layout *)calloc(1, size); // 分配一个长度为size的连续内存空间 p为该内存空间的第一个地址。这个内存空间的内存计量单位为一个obj_layout struct
      return (id)(p + 1); // 该内存空间的第一个内存单位放的是obj_layout这个结构体，之后是对象的内存空间，已经被置为0。返回的是指向对象内存空间的首地址的指针。
}
</code></pre>
</li>
<li><p>看看retainCount的实现，这个方法用来查看对象的引用计数</p>
<pre><code class="objective-c">- (NSUInteger)retainCount {
      return ((struct obj_layout *) self)[-1].retained + 1;
}
// 因为self指向的是对象内存的首地址。将这个地址看成obj_layout,也就是地址计数以obj_layout结构体的内存大小为单位。-1就指向了对象上方存储obj_layout结构体的首地址。这样就可以取出retained。因为retained默认是0，所以需要加1。
</code></pre>
</li>
<li><p>根据2，可以方便推出<strong>retain</strong>方法是将retained值加一；而<strong>release</strong>方法是将retained值减一。注意当release时发现retained值等于0，那么就不执行减一操作了，直接执行dealloc方法，因为已经没有人只有该对象了。</p>
</li>
<li><p>dealloc的实现</p>
<pre><code class="objective-c">- (void)dealloc {
      struct obj_layout *o = &amp;((struct obj_layout *) self)[-1];
      free(o); // 释放之前由calloc分配的内存空间
}
</code></pre>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><strong>autorelease</strong>：</p>
<p>当变量调用对象的autorelease方法时，说明他已经不持有这个对象了。但是这个对象并没有被释        放，还是可以被取到。</p>
<p>autorelease的使用方法：</p>
<ol>
<li>生成并持有NSAutoreleasePool对象</li>
<li>调用已分配对象的autorelease方法</li>
<li>废弃NSAutoreleasePool对象</li>
</ol>
<p>NSAutoreleasePool对象生成和废弃的这个期间，相当于对象的作用域。当废弃NSAutoreleasePool对象时，自动调用对象的release方法。来看看代码：</p>
<pre><code class="objective-c">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain]; // 这个时候才会release对象
</code></pre>
<p><strong>注意</strong>：使用autorelease时，太多的需要autorelease的对象可能由于没有及时的release，会导致内存不足。<strong>PS</strong>：其实还是在dealloc的时候释放内存，但是因为在release时，若没有变量引用对象的话，会自动调用对象的dealloc方法，所以release也可以说是释放内存吧。</p>
<p>看看下面代码：</p>
<pre><code class="objective-c">id array = [NSMutableArray arrayWithCapacity:1]; // array不持有对象
id array = [[NSMutableArray alloc] initWithCapacity:1] autorelease]; // array也不持有对象
</code></pre>
<p>上面两行代码是等价的。</p>
</li>
<li><p>autorelease的实现</p>
</li>
</ol>
<pre><code class="objective-c">   - (id)autorelease {
         [NSAutoreleasePool addObject:self];
   }

   + (void)addObject:(id)anObj {
         NSAutoreleasePool *pool = 取得正在使用的NSAutoreleasePool对象;
         if (pool != nil) {
             [pool addObject:anObj];
       } else {
             NSLog(@&quot;不存在NSAutoreleasePool&quot;);
       }
   }

   - (void)addObject:(id)anObj {
         [array addObject:anObj]; // NSAutoreleasePool对象里面有一个array数组，用来存储需要autorelease的对象
   }

   - (void)drain {
         [self dealloc]; // 废弃NSAutoreleasePool对象
   }

   - (void)dealloc {
         for (id obj in array) {
             [obj release]; // 释放之前注册到NSAutoreleasePool的对象
       }
       [array release]; // 释放array数组
   }
</code></pre>
<ol>
<li>注意不能autorelease NSAutoreleasePool对象</li>
</ol>
<h3 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h3><ol>
<li><p>引用计数式内存管理的本质并没有改变，只是ARC自动帮我们处理“引用计数”的相关部分。</p>
</li>
<li><p>编译单位可以选择ARC是否有效。一个应用程序可以以混合ARC和非ARC的方式进行编译。</p>
</li>
<li><p><strong>NSObject *</strong>是指向NSObject类的指针。<strong>id</strong>相当于C语言中的<strong>void *</strong>。</p>
</li>
<li><p>在ARC下，类型必须附上所有权修饰符，有一下几种类型</p>
<ol>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
</ol>
</li>
<li><p><strong>__strong</strong>修饰符：是id类型和所有对象类型默认的所有权修饰符。</p>
<pre><code class="objective-c">id obj = [[NSObject alloc] init]; 
// 上面实际的代码如下
id __strong obj = [[NSObject alloc] init];
</code></pre>
<p>再来看看一下代码：</p>
<pre><code class="objective-c">/* ARC下 */
{
      id __strong obj = [[NSObject alloc] init];
} // 出了作用域，obj对象自动被释放

/* 非ARC下的等价代码 */
{
      id obj = [[NSObject alloc] init];
      [obj release]; // 出作用域之前要记得释放obj对象，不然会导致内存泄漏
}
</code></pre>
<p>__strong修饰符表示对对象的强引用。在超出作用域时，强引用变量被废弃(<strong>obj指针被废弃</strong>)，与此同时它引用的对象也会被释放(<strong>对象被释放</strong>)。</p>
<p>看看对于非自己生成的对象：</p>
<pre><code class="objective-c">/* ARC下 */
{
      id __strong obj = [NSMutableArray array]; // 这里的obj是持有对象的
      // do something here
}

/* 非ARC下的等价代码 */
{
      id obj = [NSMutableArray array];
      [obj retain];  // obj要手动持有
      // do something here

      [obj release];  // 出作用域时要手动释放
}
</code></pre>
</li>
<li><p><strong>__weak</strong>修饰符主要是为了防止相互引用。__weak指的是弱引用，也就是变量不能持有对象。</p>
<pre><code class="objective-c">{
      id __strong obj0 = [[NSObject alloc] init]; // obj0强引用对象，持有
      id __weak obj1 = obj0; // obj1弱引用对象，不持有
}
</code></pre>
<p>所以在出作用域时obj0废弃，不在有变量持有对象，对象被释放。可以通过检查附有__weak修饰符的变量是否为nil，来判断对象是否已经被释放。</p>
</li>
<li><p><strong>__unsafe_unretained</strong>作用和__weak一样，但是如名字所言，它是不安全的。当这种变量指向的对象被释放时，weak型的变量就被置成nil(正确的做法)，但是unsafe的变量可能还指向某个地址(不安全的，因为那个地址的对象已经被释放了)。</p>
</li>
<li><p>来看看autorelease，先看段代码：（<strong>PS</strong>：有点迷糊）</p>
<pre><code class="objective-c">/* ARC无效 */
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain];

/* ARC有效 */
@autoreleasepool {
      id __autoreleasing obj = [[NSObject alloc] init];
}
</code></pre>
<p>但是通常不需要再@autorelease里面显式的使用__autoreleasing修饰符。</p>
</li>
<li><p>在ARC有效时有以下规定：</p>
<ol>
<li>不能使用retain/release/retainCount/autorelease方法</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>要遵循方法的命名规则。alloc/new/copy/mutableCopy开头的方法，要返回自己生成并持有的对象。init开头的方法，基本只是对alloc方法返回的对象进行初始化并返回该对象。</li>
<li>不要显式调用dealloc方法。因为在对象需要废弃时，会自动调用该方法。在ARC无效时，要在dealloc方法里面调用<code>[super dealloc];</code>。但是在ARC有效时，不需要这样调用，ARC会自动帮你处理。</li>
<li>使用@autoreleasepool而不是NSAutoreleasePool</li>
<li>结构体中的成员变量不能是Objective-C对象</li>
<li>id 和 void* 不懂，什么东西？这里还和__bridge有点关系</li>
</ol>
</li>
<li><p>在ARC有效时，变量有各种修饰符。当然属性也会有各种修饰符。 </p>
<ol>
<li>assign  == __unsafe_unretained</li>
<li>copy == __strong （但是赋值的是被复制的对象）</li>
<li>retain == __strong</li>
<li>strong == __strong</li>
<li>unsafe_unretained == __unsafe_unretained</li>
<li>weak == __weak</li>
</ol>
</li>
<li><p>数组1.3.6 不懂</p>
</li>
</ol>
<h3 id="ARC的实现"><a href="#ARC的实现" class="headerlink" title="ARC的实现"></a>ARC的实现</h3><ol>
<li><p>ARC由下面两者来实现</p>
<ol>
<li>clang（LLVM编译器）3.0以上</li>
<li>objc4 Objective-C运行时库 493.9以上 （主要是 runtime/objc-arr.mm)</li>
</ol>
</li>
<li><p><strong>__strong</strong>的实现</p>
<pre><code class="objective-c">{
      id __strong obj = [[NSObject alloc] init];
      // do something
}

/* 经过编译之后 */
id obj = objc_msgSend(NSObject, @selector(alloc)); // 执行alloc方法，obj变量持有对象，也就是强引用
objc_msgSend(obj, @selector(init)); // 执行init方法，进行一些初始化操作，无关ARC
// do something
objc_release(obj); // 在变量出作用域时，编译器自动释放对象
</code></pre>
<pre><code class="objective-c">{
      id __strong obj = [NSMutableArray array];  // obj是持有对象的
      // do something
}

/* 经过编译之后 */
id obj objc_msgSend(NSMutableArray, @selector(array)); // 执行array方法，此时对象“照理来说”是已经被注册到NSAutoreleasePool里面，obj变量此时是不持有对象的
objc_retainAutoreleasedReturnValue(obj); // 编译器帮obj持有注册到NSAutoreleasePool中的变量
// do something
objc_release(obj); // 变量要出作用域了，编译器自动释放对象

/* array函数实质 */
+ (id)array {
      return [[NSMutableArray alloc] init];
}

/* 经过编译之后 */
+ (id)array {
      id obj = objc_msgSend(NSMutableArray, @selector(alloc)); // 生成对象，obj持有
      objc_msgSend(obj, @selector(init)); // 初始化，无关ARC
      return objc_autoreleaseReturnValue(obj); // 讲道理，这一步是要将对象注册到NSAutoreleasePool中，obj不再持有对象(可以说是obj将对象持有权转交给了NSAutoreleasePool)
}
</code></pre>
<p>按上面的说法来看，最终持有array对象的有2个：一个是NSAutoreleasePool，一个是obj。但是其实是做了优化的。<code>objc_autoreleaseReturnValue(obj);</code>这个函数观察到紧接着它自己调用的函数如果是<code>objc_retainAutoreleasedReturnValue(obj);</code>的话，就不会将对象注册到NSAutoreleasePool，直接将对象给obj让它持有就行了。这个优化就是因为__strong修饰符要持有对象，与其先将对象注册到NSAutoreleasePool，再从NSAutoreleasePool中拿到这个对象给obj持有一遍；还不如直接跳过注册，直接让obj持有对象。说到底，使用NSAutoreleasePool的原因就是怕没有变量持有对象，那么就取不到这个对象了，所以让NSAutoreleasePool暂时持有对象。</p>
<p><strong>PS</strong>：让NSAutoreleasePool暂时持有对象这个说法不知道靠不靠谱</p>
<p>todo add a picture</p>
</li>
<li><p><strong>__weak</strong>的实现</p>
<pre><code class="objective-c">{
      id __weak obj1 = obj; // 这里obj是强引用
      // do something
}

/* 编译之后 */
id = obj1;
obj1 = 0;
objc_storeWeak(&amp;obj1, obj);
// do something
objc_storeWeak(&amp;obj1, 0);
</code></pre>
<p><code>objc_storeWeak(&amp;obj1, obj);</code>函数将obj指向对象的地址作为key，将obj1变量的地址作为value，注册到weak表中，并将obj1指向对象。因为一个对象可以赋给多个值，所以一个key可以对应多个值。如果第二个参数是0的话，就将obj1这个变量的地址从weak表中删除（删除value为obj1地址的那条记录，废弃obj1对象）。<strong>PS</strong>：这么说的话，其实将obj1变量的地址当成key，更方便理解。</p>
<p><strong>PS</strong>：我们来看看另外一种情况，就是释放对象时，但是weak变量还存在。这个时候会将weak变量置为nil。这是如何实现的呢？</p>
<ol>
<li>先将weak表中key为这个对象的地址的记录找出来</li>
<li>将该地址对应的所有的weak变量找出来，将他们置为nil</li>
<li>删除这条key为对象地址的记录</li>
</ol>
<p>由上面说明可以知道，大量使用weak变量也会消耗相应的CPU资源，所以只在需要避免循环引用时使用。</p>
</li>
<li><p>看看weak和unsafe_unretained的区别</p>
<pre><code class="objective-c">{
      id __weak obj = [[NSObject alloc] init];
      // do something
}
/* 编译之后 */
id = obj;
id tmp = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(tmp, @selector(init));
objc_initWeak(&amp;obj, tmp);  // 在weak表中插入对象，将obj指向对象
objc_release(tmp); // 释放对象后，不在有变量持有对象，这时候会将obj置为nil。安全
// do something
objc_destroyWeak(&amp;obj); // 删除记录（上一步已经做了，这里就不做了），废弃obj变量
</code></pre>
<pre><code class="objective-c">{
      id __unsafe_unretained obj = [[NSObject alloc] init];
      // do something
}

/* 编译之后 */
id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_release(obj); // 因为没有变量持有对象，所以释放对象，但是obj变量还指向了原对象。危险
// do something
</code></pre>
</li>
<li><p>还有就是要注意使用__weak变量时</p>
<pre><code class="objective-c">NSLog(@&quot;%@&quot;, obj); // 假设这里的obj是weak变量
/* 编译之后 */
id tmp = objc_loadWeakRetained(&amp;obj);
objc_autorelease(tmp);  // 这两句说的是将obj弱引用的对象交给NSAutoreleasePool持有，以保证这个对象可以被取到。
NSLog(@&quot;%@&quot;, tmp); // 做正事
</code></pre>
<p>上面说的这个是，当使用weak变量的时候，会先将weak变量指向的对象交给NSAutoreleasePool持有，以保证这个对象万一被强引用它的变量释放的时候，还是可以取到。但是当多次使用weak变量的话，最好先将weak变量的对象给一个变量，让它强引用，这样就不用多次去和NSAutoreleasePool打交道，耗时间了。</p>
<pre><code class="objective-c">id tmp = obj; // 让tmp强引用对象，这里会发生一次和NSAutoreleasePool的交互，因为使用到了obj这个weak变量。这一步过后tmp和NSAutoreleasePool都持有对象
// 使用tmp做正事，而不是频繁使用obj
</code></pre>
</li>
<li><p><strong>__autoreleasing</strong>的实现</p>
<pre><code class="objective-c">@autoreleasepool {
      id __autoreleasing obj = [[NSObject alloc] init];
}

/* 编译之后 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_autorelease(obj); // 交给NSAutoreleasePool持有
objc_autoreleasePoolPop(pool); // 废除NSAutoreleasePool，释放对象
</code></pre>
<p>看看对于非自己生成并持有的对象</p>
<pre><code class="objective-c">@autoreleasepool {
      id __autoreleasing obj = [NSMutableArray array];
}

/* 编译之后 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSMutableAttay, @selector(array)); // 不持有
objc_retainAutoreleasedReturnValue(obj); // 又重新持有对象。。。
objc_autorelease(obj); // 又交给NSAutoreleasePool持有
objc_autoreleasePoolPop(pool); // 废除NSAutoreleasePool，释放对象
</code></pre>
</li>
<li><p><code>uintptr_t _objc_rootRetainCount(id obj);</code>函数可以获得obj对象当前的引用计数，也就是有多少个变量强引用该对象。注意注册到NSAutoreleasePool中的对象也算一次引用计数。也就是如同上面一直说的，可以说是NSAutoreleasePool持有对象。注意，这个函数不一定可信。。。</p>
</li>
</ol>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>呕心沥血啊。看得要吐了。。。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Core Animation - The Performance of a Lifetime]]></title>
      <url>/2016/07/14/iOS-Core-Animation-reading-note-three/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>iOS Core Animation</strong> 读书笔记（三）<strong>The Performance of a Lifetime</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Tuning-for-Speed"><a href="#Tuning-for-Speed" class="headerlink" title="Tuning for Speed"></a>Tuning for Speed</h3><h4 id="CPU-Vs-GPU"><a href="#CPU-Vs-GPU" class="headerlink" title="CPU Vs GPU"></a>CPU Vs GPU</h4><ol>
<li>将各个layer以及layer的动画渲染到屏幕上由系统来控制，这个控制器称为<em>render server</em>。</li>
<li>绘制的过程如下：<ol>
<li><strong>Layout</strong>：这个阶段建立好你的view树和layer树，并给layer设定好各种属性（frame，background color等等）。</li>
<li><strong>Display</strong>：这个阶段在每个layer上面画他们的backing image。这个阶段可能会调用<code>-drawRect:</code>或者<code>-drawLayer:inContext:</code>方法。</li>
<li><strong>Prepare</strong>：这个阶段Core Animation准备好要传递给render server的动画的相关参数。</li>
<li><strong>Commit</strong>：这个阶段Core Animation将所有的layer和动画属性一起打包，传递给render server，让它显示。</li>
<li>render server计算每个layer每个属性以及动画过程的中间值，然后设置OpenGL的各个三角形属性等等</li>
<li>在屏幕上绘制可视化的三角形。</li>
</ol>
</li>
<li>上述的6歌步骤，我们只能控制前两步。前5步由CPU执行，最后一步由GPU执行。</li>
<li>GPU方面有几个影响绘制的性能的因素：<ol>
<li><strong>Too much geometry</strong>：GPU其实一次可以handle百万个三角形，不太可能成为性能瓶颈。但是太多的layer，在渲染前，需要都传递给render server，这一点会影响CPU的速度，成为影响性能的一个原因。</li>
<li><strong>Too much overdraw</strong>：GPU有这有限的像素填充速率。半透明的layer互相堆叠，那么就得渲染多次在同一个像素点。</li>
<li><strong>Offscreen drawing</strong>：</li>
<li><strong>Too-large images</strong>：GPU的最大的texture size是2048x2048/4096x4096。所画的图片超过这，GPU在显示的时候，就得先预处理一遍，这样会减慢速度。</li>
</ol>
</li>
<li>CPU上的操作主要会影响的是动画的开始，他会延迟动画的开始。体现在下面几个方面：<ol>
<li><strong>Layout calculations</strong>：如果layer太复杂的话，计算所有的layer的frame等属性会花较长的时间。这个在使用autolayout的view上面体现的更明显。</li>
<li><strong>Lazy view loading</strong>：iOS只会在view要显示在屏幕上的时候，才会去加载view。这个对内存以及启动时间都很有帮助。但是当一个view显示时需要大量预先计算时，会对响应有很大的影响。</li>
<li><strong>Core Graphics drawing</strong>：也就是自己实现的<code>-drawRect:</code>方法和<code>-drawLayer:inContext:</code>方法会影响性能。</li>
<li><strong>Image decompression</strong>：PNG或是JPEG都是压缩过的图片。一张图片在显示在iOS屏幕之前，都要先解压缩到原来的大小。这个过程也会消耗CPU时间。</li>
</ol>
</li>
</ol>
<h3 id="Efficient-Drawing"><a href="#Efficient-Drawing" class="headerlink" title="Efficient Drawing"></a>Efficient Drawing</h3><ol>
<li>尽量不使用<code>-drawRect;</code>方法。</li>
<li>可以使用CAShapeLayer等来代替<code>-drawRect;</code>方法。</li>
<li>如果非要使用该方法，在重新绘制的时候，不要重新绘制整个View，要绘制那些需要绘制的区域。使用<code>-setNeedsDisplayInRect:</code>等方法。</li>
<li>可以尝试异步绘图，如使用CATiledLayer以及drawsAsynchronously等等。</li>
</ol>
<h3 id="Image-IO"><a href="#Image-IO" class="headerlink" title="Image IO"></a>Image IO</h3><ol>
<li><p>Image的本地加载和网络请求都会造成延迟。</p>
</li>
<li><p>可以尝试异步加载。</p>
</li>
<li><p>PNG相比于JPEG，加载时间较长，但是解压的时间短得多。这时因为JPEG的解压算法相比于基于zip压缩的PNG更加复杂。</p>
</li>
<li><p>UIImage的<code>+imageNamed;</code>方法与其他的方法不同的是，它在加载完图片后就立马开始解压，但是其他的方法会在开始画图时才去解压图片。还有一个方法就是直接将image制定为UIImageView的image属性或是layer的contents属性，但是这样的话只能在主线程中执行。</p>
</li>
<li><p>来看段代码：</p>
<pre><code class="objective-c">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {
    //dequeue cell
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];

    ...
    //switch to background thread
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        //load image
        NSInteger index = indexPath.row;
        NSString *imagePath = self.imagePaths[index];
        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];

        //redraw image using device context
        UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, YES, 0); 
        [image drawInRect:imageView.bounds];
        image = UIGraphicsGetImageFromCurrentImageContext(); 
        UIGraphicsEndImageContext();
        //set image on main thread, but only if index still matches up
        dispatch_async(dispatch_get_main_queue(), ^{
            if (index == imageView.tag) {
                imageView.image = image; 
            }
        }); 
    });
    return cell; 
}
</code></pre>
</li>
<li><p><code>+imageNamed:</code>方法还会缓存解压之后的图片，以供以后使用。无论你是否还有指针指向这个UIImage。</p>
</li>
</ol>
<h3 id="Layer-Performance"><a href="#Layer-Performance" class="headerlink" title="Layer Performance"></a>Layer Performance</h3><ol>
<li>CATextLayer和UILabel都是使用software drawing，所以会比那些使用hardware-accelerated的慢。所以要尽量避免改变有很多text的CATextLayer或是UILabel。</li>
<li>将<strong>shouldRasterize</strong>属性设置成YES，他会先在屏幕外面画好layer的image。然后这个image会被cache，之后会被画在真正的layer的位置上面。多次反复被使用。切记：如果一个layer的contents经常变化，不要使用这个。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Core Animation - Setting Things in Motion]]></title>
      <url>/2016/07/08/iOS-Core-Animation-reading-note-two/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>iOS Core Animation</strong> 读书笔记（二） <strong>Setting Things in Motion</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Implicit-Animations"><a href="#Implicit-Animations" class="headerlink" title="Implicit Animations"></a>Implicit Animations</h3><p>隐式的动画由framework自动执行，除非你叫他不执行。</p>
<h4 id="Transcations"><a href="#Transcations" class="headerlink" title="Transcations"></a>Transcations</h4><ol>
<li><p>Core Animation会去假设你所有创建在屏幕上的东西都会animation。所以animation并不用你刻意的去启动。这也是Core Animation比OpenGL慢的一点，OpenGL不用去考虑这些东西，就不需要花费额外的性能代价。</p>
</li>
<li><p>当你改变一个CALayer的属性时，它会自动平滑的执行动画从当前属性到新的属性，而不是瞬变。不需要你额外的做些什么。这种动画就叫做隐式动画。</p>
</li>
<li><p><strong>Transcations</strong>是Core Animation将一系列动画汇集成一个的机制。一旦transaction提交(committed)之后，这些动画就会开始执行。</p>
</li>
<li><p><strong>CATransaction</strong>类控制着transaction的行为。该类没有alloc init这样的初始化，也并不是如名字那样代表一个transaction，它表示一个transaction的栈。可以使用<code>+begin</code> 和 <code>-commit</code>方法来将一个transaction进栈或者出栈。</p>
</li>
<li><p>使用<code>+setAnimationDuration:</code>方法来设置当前transaction的动画时间。没有指定的话，默认是0.25s。使用该方法时，最好显示的开始一个新的transaction，将其压入栈中，表示只改变这个transaction的duration；不然可能改变同时发生的一些animation，比如旋转屏幕。</p>
</li>
<li><p>看一下代码：</p>
<pre><code class="objective-c">- (IBAction)changeColor {
    //begin a new transaction
    [CATransaction begin];

    //set the animation duration to 1 second
    [CATransaction setAnimationDuration:1.0];

    //randomize the layer background color
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX; 
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;

     //commit the transaction
    [CATransaction commit]; 
}
</code></pre>
<p>这里使用<code>+begin</code>方法，表示显式的开始一个transaction，transaction其实就是一个属性改变的动画的集合；显式开始一个transaction可以精准的控制这一系列动画的执行时间等等，而且不予其他的动画搞混。当执行<code>+commit</code>方法时，这些动画变开始执行。而对于一些没有使用begin,commit的动画，其实他们也是属于不同的transaction，只是这些transaction没有被显式的压入(begin)或推出(commit)transaction的数组而已；他们被隐式的执行罢了。</p>
</li>
<li><p>其实UIView的<code>+animateWithDuration:animations:</code>方法，也是在内部调用上述6中的方法而已。</p>
</li>
<li><p>UIView的<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>和CALayer的<code>+begin</code>以及<code>+commit</code>相同。</p>
</li>
</ol>
<h4 id="Completion-Blocks"><a href="#Completion-Blocks" class="headerlink" title="Completion Blocks"></a>Completion Blocks</h4><ol>
<li>UIView中的animation的completion block实际上就是调用CATransaction的<code>+setCompletionBlock:</code>方法。</li>
</ol>
<h4 id="Layer-Actions"><a href="#Layer-Actions" class="headerlink" title="Layer Actions"></a>Layer Actions</h4><p>CALayer在属性变化时执行的动画叫做<strong>actions</strong>，来看看整个的流程。</p>
<ol>
<li>当CALayer的一个属性变化时，调用<code>-actionsForKey:</code>方法，这里传入的key就是这个属性的名字。</li>
<li>这时layer先查看他是否有delegate，也就是CALayerDelegate；再看看这个delegate里面是否实现了<code>-actionForLayer:forKey:</code>方法。如果实现了这个方法，那么就会调用这个方法并且返回。</li>
<li>如果没有这个delegate或者delegate里面没有实现上述的方法，那么layer就会去检查他的actions属性。这个字典包含了属性名到action的映射。</li>
<li>如果还是没找到这个要动画的属性名的话，就去style字典里面找。</li>
<li>最后的最后，还是没有找到的话，就会调用<code>-defaultActionForKey:</code>方法；这个方法定义了标准的动画为那些已知的属性。</li>
</ol>
<p>如果上述步骤的第二步中的<code>-actionForLayer:forKey:</code>方法返回nil的话就不会有动画发生了；如果返回的是一个符合CAAction协议的对象，比如返回CABasicAnimation，那么就会执行动画。</p>
<p>因为UIView的backing layer的delegate是UIView本身。UIView实现<code>-actionForLayer:forKey:</code>方法的方式就是：如果UIView的属性改变不发生在一个显式的动画工程之中就返回nil；如果在动画过程之中，就返回可动画的对象。测试代码如下：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *layerView; 
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];

    //test layer action when outside of animation block
    NSLog(@&quot;Outside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);

    //begin animation block
    [UIView beginAnimations:nil context:nil];
    //test layer action when inside of animation block
    NSLog(@&quot;Inside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);
    //end animation block
    [UIView commitAnimations]; 
}
@end
</code></pre>
<p>打印的结果如下：</p>
<pre><code>$ LayerTest[21215:c07] Outside: &lt;null&gt;
$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;
</code></pre><p>所以说UIView是disable隐式动画的。</p>
<p><code>[CATransaction setDisableActions:YES];</code>这个方法也可以 禁用动画。</p>
<p>在layer的<strong>actions</strong>字典属性里面设置如下：</p>
<pre><code>CATransition *transition = [CATransition animation]; 
transition.type = kCATransitionPush;
transition.subtype = kCATransitionFromLeft; 
self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
</code></pre><h4 id="Presentation-Versus-Model"><a href="#Presentation-Versus-Model" class="headerlink" title="Presentation Versus Model"></a>Presentation Versus Model</h4><ol>
<li>当你更改一个CALayer的属性时，这个属性是立刻发生改变的，但是并不在屏幕上立即显示出来。</li>
<li>当改变CALayer的属性时，CALayer相当于一个<em>model</em>，用来存储动画结束时该呈现何种状态；而Core Animation则相当于<em>controller</em>，用来控制<em>view</em>的变化。这也是一个MVC结构啊。所以有时候layer tree也叫作model layer tree。</li>
<li>iOS中，屏幕1／60秒重新绘制一次。所以如果动画时间超过这一时长的话，那么Core  Animation就需要从设置动画开始到动画结束内每1／60秒更新一次界面。所以这也需要CALayer能够记住当前的属性值和最终的属性值。</li>
<li>动画过程中，当前显示的layer的属性值，存储在一个<strong>presentation layer</strong>中，它可以通过<code>-presentationLayer;</code>方法取得。这个layer实际上就是<strong>model layer</strong>的复制，唯一的区别就是当前动画的属性值不同。当在presentation layer上调用<code>-modelLayer</code>方法时，返回的是presentation layer的原始的model layer。</li>
</ol>
<h3 id="Explicit-Animations"><a href="#Explicit-Animations" class="headerlink" title="Explicit Animations"></a>Explicit Animations</h3><p>使用显式动画的好处是可以完全控制动画的行为，比如运动轨迹，动画时间等等。</p>
<h4 id="Property-Animations"><a href="#Property-Animations" class="headerlink" title="Property Animations"></a>Property Animations</h4><ol>
<li><p><strong>CAAnimation</strong>类是所有Core Animation支持的动画类的共有的父类；它有一个子类是<strong>CAPropertyAnimation</strong>，也就是属性动画。</p>
</li>
<li><p><strong>CABasicAnimation</strong>是CAPropertyAnimation的一个子类。CAPropertyAnimation指定一个属性通过指定keypath。CABasicAnimation有3个属性：<em>fromValue</em>, <em>toValue</em>, <em>byValue</em>。这三个都是id类型，因为他们可以是数值，颜色，图片等等。当然只需要指定3个中的两个就可以确定一个动画。</p>
</li>
<li><p>使用CABasicAnimation就是显式动画了，来看一个例子：</p>
<pre><code class="objective-c">//create a basic animation
CABasicAnimation *animation = [CABasicAnimation animation]; 
animation.keyPath = @&quot;backgroundColor&quot;;
animation.toValue = (__bridge id)color.CGColor;
//apply animation to layer
[self.colorLayer addAnimation:animation forKey:nil];
</code></pre>
</li>
<li><p>使用上述的代码在动画结束后，颜色还是会回到以前的颜色，是因为动画只是改变了presentation layer，并没有改变model layer。实际上，隐式动画改变属性时，动画使用的也是CABasicAnimation，属性改变时，会在<code>-actionForLayer:forKey:</code>方法中返回一个CABasicAnimation。所以我们可以在动画执行之前改变属性，如下：</p>
<pre><code class="objective-c">animation.fromValue = (__bridge id)self.colorLayer.backgroundColor; self.colorLayer.backgroundColor = color.CGColor;
</code></pre>
</li>
</ol>
<ol>
<li><p>选择在动画之前改变属性值，而不是在动画结束之后。是因为，在动画结束之后，会先跳回原始值，在跳到最终值。</p>
</li>
<li><p>使用CAAnimationDelegate可以解决上述问题。它可以知道动画准确的结束时间。实现<code>-animationDidStop:finished:</code>方法即可。代码如下：</p>
<pre><code class="objective-c">// first specify delegate
animation.delegate = self;

// implement delegate method
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag {
    //set the backgroundColor property to match animation toValue
    [CATransaction begin];
    [CATransaction setDisableActions:YES]; 
      self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;         [CATransaction commit];
}
</code></pre>
</li>
<li><p>CABasicAnimation在使用<code>-addAnimation:forKey:</code>方法添加给CALayer时，可以指定一个NSString类型的Key。这个Key可以唯一的标示一个animation。所以在<code>-animationDidStop:finished:</code>方法中可以使用key来辨别是否是某个特定的animation。</p>
</li>
<li><p>CAAnimation还有一套自己的方法，来标示一个animation。可以使用<code>-setValue:forKey:</code>以及<code>-valueForKey:</code>方法。代码如下：</p>
<pre><code class="objective-c">// when set up animation
[animation setValue:handView forKey:@&quot;handView&quot;];

// when finish animation
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag {
      // get value that set last step
      UIView *handView = [anim valueForKey:@&quot;handView&quot;];
      // do something later
}
</code></pre>
</li>
<li><p>注意：这个动画结束的delegate被调用，可能发生在其值回退之前。所以，为什么要说在动画之前就设置动画结束的值。</p>
</li>
<li><p><strong>CAKeyframeAnimation</strong>很强大，和CABasicAnimation一样，也是CAPropertyAnimation的一个子类。它和CABasicAnimation一样，也只对一个属性进行动画。CAKeyframeAnimation只需要你来提供关键帧，然后Core Animation会自动帮你填充关键帧之间的空白。看一个例子：</p>
</li>
</ol>
<pre><code class="objective-c">   CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @&quot;backgroundColor&quot;;
   animation.duration = 2.0;
   animation.values = @[
                       (__bridge id)[UIColor blueColor].CGColor, 
                         (__bridge id)[UIColor redColor].CGColor, 
                         (__bridge id)[UIColor greenColor].CGColor, 
                         (__bridge id)[UIColor blueColor].CGColor 
                       ];
   //apply animation to layer
   [self.colorLayer addAnimation:animation forKey:nil];
</code></pre>
<p>   通过<strong>values</strong>属性(是一个NSArray)，指定关键帧。必须指定开始和结束的帧，因为CAKeyframeAnimation不会默认使用这个属性当前的值来作为第一帧。</p>
<ol>
<li>CAKeyframeAnimation还可以使用CGPath。来看看例子：</li>
</ol>
<pre><code class="objective-c">   //create a path
   UIBezierPath *bezierPath = [[UIBezierPath alloc] init]; 
   [bezierPath moveToPoint:CGPointMake(0, 150)]; 
   [bezierPath addCurveToPoint:CGPointMake(300, 150)
                 controlPoint1:CGPointMake(75, 0) 
                  controlPoint2:CGPointMake(225, 300)];

   //draw the path using a CAShapeLayer
   CAShapeLayer *pathLayer = [CAShapeLayer layer]; 
   pathLayer.path = bezierPath.CGPath; 
   pathLayer.fillColor = [UIColor clearColor].CGColor; 
   pathLayer.strokeColor = [UIColor redColor].CGColor; 
   pathLayer.lineWidth = 3.0f; 
   [self.containerView.layer addSublayer:pathLayer];

   //add the ship
   CALayer *shipLayer = [CALayer layer];
   shipLayer.frame = CGRectMake(0, 0, 64, 64); 
   shipLayer.position = CGPointMake(0, 150); 
   shipLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Ship.png&quot;].CGImage; [self.containerView.layer addSublayer:shipLayer];

   //create the keyframe animation
   CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @&quot;position&quot;;
   animation.duration = 4.0;
   animation.path = bezierPath.CGPath;
   [shipLayer addAnimation:animation forKey:nil];
</code></pre>
<p>   指定CAKeyframeAnimation的<strong>path</strong>属性为一个CGPath。然后就可以沿着这个path运动。另外，CAKeyframeAnimation还有一个<strong>rotationMode</strong>属性，该属性指定动画的layer的旋转特性。将该属性指定为kCAAnimationRotationAuto的话，上面的shipLayer就会一直旋转，以调整角度去对齐bezierPath的切线方向。</p>
<ol>
<li>CAPropertyAnimation不单单可以作用于实际存在的属性，还可以作用于虚拟的属性。是一个keys path：比如<code>animation.keyPath = @&quot;transform.rotation&quot;;</code>。</li>
</ol>
<h4 id="Animation-Groups"><a href="#Animation-Groups" class="headerlink" title="Animation Groups"></a>Animation Groups</h4><ol>
<li><strong>CAAnimationGroup</strong>是CAAnimation的一个子类，他可以聚集一堆动画。</li>
<li>他有一个<strong>animations</strong>属性，是一个包含CAAnimation的数组。</li>
</ol>
<h4 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h4><p><strong>CATransition</strong>也是CAAnimation的一个子类，它影响整个layer。它会先对原先的layer照个快照，然后创建新的layer。之后以动画的形式，将新的layer快照，替代原先的layer快照，比方说从左向右推入。它主要用来动画一些不可动画的属性，比如UIImage的image属性。看看代码：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIImageView *imageView; 
@property (nonatomic, copy) NSArray *images;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    //set up images
    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;], 
                    [UIImage imageNamed:@&quot;Cone.png&quot;],
                    [UIImage imageNamed:@&quot;Igloo.png&quot;], 
                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];
}

- (IBAction)switchImage {
    //set up crossfade transition
    CATransition *transition = [CATransition animation]; 
      transition.type = kCATransitionFade;
    //apply transition to imageview backing layer
    [self.imageView.layer addAnimation:transition forKey:nil];

      //cycle to next image
    UIImage *currentImage = self.imageView.image;
    NSUInteger index = [self.images indexOfObject:currentImage]; 
      index = (index + 1) % [self.images count]; 
      self.imageView.image = self.images[index];
}
@end
</code></pre>
<p>CALayer的contents属性，自动应用CATransition动画，当改变一个不是backing layer的contents时，会自动应用动画。</p>
<p>自己实现CATransaction效果：</p>
<ol>
<li>CALayer的<code>-renderInContext:</code>方法可以用来获取将当前的layer的contents画到一个context里面，也就实现了获取当前的快照。</li>
<li>将这个快照放在当前屏幕的最上面，掩盖住原来的view；之后就可以在原来的view上面进行变化了。</li>
<li>再使用动画推出这个快照，就完成了transition。</li>
</ol>
<p>看看代码实现：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIView *baseView = [[UIView alloc]initWithFrame:self.view.bounds];
    baseView.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:baseView];

    // preserve the current snapshot
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);
    [baseView.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();

    // insert snapshot view
    UIImageView *coverView = [[UIImageView alloc]initWithImage:coverImage];
    coverView.frame = self.view.bounds;
    [self.view addSubview:coverView];

    // update original view
    baseView.backgroundColor = [UIColor redColor];
    [UIView animateWithDuration:1.0 animations:^{
        CGAffineTransform transform = CGAffineTransformMakeScale(0.1, 0.1);
        transform = CGAffineTransformRotate(transform, M_PI_2);
        coverView.transform = transform;
        coverView.alpha = 0.5;
    } completion:^(BOOL finished) {
        [coverView removeFromSuperview];
    }];
}
</code></pre>
<h4 id="Canceling-an-Animation-in-Progress"><a href="#Canceling-an-Animation-in-Progress" class="headerlink" title="Canceling an Animation in Progress"></a>Canceling an Animation in Progress</h4><ol>
<li>当使用CALayer的<code>-addAnimation:forKey:</code>方法给一个layer添加了动画之后，可以使用<code>-(CAAnimation *)animationForKey:(NSString *)key;</code>方法来根据key重新获取这个animation。</li>
<li>修改正在运行的动画的属性，是没有效果的。</li>
<li>可以使用<code>- (void)removeAnimationForKey:(NSString *)key;</code>方法来删除layer的某个animation。</li>
<li>可以使用<code>- (void)removeAllAnimations;</code>来删除layer的所有动画。</li>
<li>只要一删除动画，屏幕就会根据model layer来重新绘制。</li>
</ol>
<h3 id="Layer-Time"><a href="#Layer-Time" class="headerlink" title="Layer Time"></a>Layer Time</h3><h4 id="The-CAMediaTiming-Protocol"><a href="#The-CAMediaTiming-Protocol" class="headerlink" title="The CAMediaTiming Protocol"></a>The CAMediaTiming Protocol</h4><ol>
<li><p><strong>CAMediaTiming</strong>协议定义了多种属性及方法用来控制动画工程中的时间，CALayer和CAAnimation都符合该协议。</p>
</li>
<li><p><strong>duration</strong>属性：一次动画执行的时间。</p>
</li>
<li><p><strong>repeatCount</strong>属性：动画重复执行的次数。可以是小数，比如3.5次。。</p>
</li>
<li><p>duration和repeatCount的默认值都是0，但不表示0次和0秒。表示的是默认的0.25s和1次。</p>
</li>
<li><p>还可以使用<strong>repeatDuration</strong>属性，指定整个重复动画的时间；<strong>autoreverses</strong>属性指定动画是否要原路径反着来一遍。</p>
</li>
<li><p>每个动画的时间都是各成体系的。每个动画内的时间可以被延迟，加速，减速等等。</p>
</li>
<li><p><strong>beginTime</strong>属性：如果一个animation是在一个animation group中，则beginTime就是其parent object——animation group 开始的一个偏移。如果一个animation 的 beginTime为5，则此动画在group aniamtion开始之后的5s在开始动画。如果一个animation是直接添加在layer上，beginTime同样是是其parent object——layer 开始的一个偏移，但是一个layer的beginning是一个过去的时间（猜想layer的beginning可能是其被添加到layer tree上的时间），因此不能简单的设置beginTime为5去延迟动画5s之后开始，因为有可能layer的beginning加上5s之后也是一个过去的时间（很有可能），因此，当要延迟一个添加到layer上的动画的时候，需要定义一个addTime，因此：</p>
<pre><code class="objective-c">addTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; // 取得layer时间系下的现在时间
animation.beginTime = addTime + delay; // 设置animation的时间系的原点，要参照layer的时间系。
</code></pre>
<p>如果一个layer他自己的beginTime已经设置，则animation的addTime的计算必须在layer的beginTime设置之后，因为要有一个时间的转移，具体看下面的例子：</p>
<pre><code class="objective-c">CFTimeInterval currentTime = CACurrentMediaTime();
CFTimeInterval currentTimeInSuperLayer = [superLayer convertTime:currentTime fromLayer:nil];
layer.beginTime = currentTimeInSuperLayer + 2; // 设置layer的时间系 从layer的superLayer进行设置。也就是说layer的时间系的原点是现在的Global时间在superLayer时间系里面加2s。 但是要把现在的global时间换成superLayer的时间。
CFTimeInterval currentTimeInLayer = [layer convertTime:currentTimeInSuperLayer fromLayer:superLayer];
CFTimeInterval addTime = currentTimeInLayer;
CAAnimationGroup *group = [CAAnimationGroup animation];
group.beginTime = addTime + 1; // 设置groupAnimation的时间系， 是现在时间的Global时间在layer的时间系里面加1s。(若speed都一样的话，那么就是layer时间系的-1s的位置)。
group.animations = [NSArray arrayWithObject:anim];
group.duration = 2;
anim.beginTime = 0.5;
[layer addAnimation:group forKey:nil];
</code></pre>
<p>​</p>
</li>
<li><p><strong>speed</strong>属性：表示的是时间的系数。默认为1，表示1倍速。如果duration是1s，但是speed是2，那么执行时间只有0.5s，也就是2倍速。</p>
</li>
<li><p><strong>timeOffset</strong>属性：表示动画从timeOffset的位置开始，动画到终点结束后回到起点再动画到timeOffset的位置。它计算出来的开始位置不受speed的影响。</p>
</li>
<li><p>当设置<strong>removeOnCompletion</strong>属性为NO时，说明动画完成时，这个动画没有从layer上面删除。这时候可以设置<strong>fillMode</strong>属性。这个属性默认为kCAFillModeRemoved，表示被动画的属性在model layer上面都不曾变化。可以将fillMode属性设置成其他的，那么model layer上面的属性会在动画结束时自动更新将其设置成presentation layer上面一样的值。这个时候要注意，在添加animation的时候要指定一个key，以确保之后可以方便删除这个动画。</p>
</li>
</ol>
<h4 id="Hierarchical-Time"><a href="#Hierarchical-Time" class="headerlink" title="Hierarchical Time"></a>Hierarchical Time</h4><ol>
<li><p>layer的动画时间也是有相对坐标系的，类似layer的位置，时间也是相对于super layer的。</p>
</li>
<li><p>改变CALayer或者CAGroupAnimation的beginTime，timeOffset以及speed属性会影响到sublayer的动画时间。</p>
</li>
<li><p>Core Animation有一个<strong>global time</strong>的概念，也就是一个设备的各个程序间共同的一个时间体系。它是一个<em>mach time</em>，可以通过下列代码获得当前的global time：</p>
<pre><code class="objective-c">CFTimeInterval time = CACurrentMediaTime();
</code></pre>
<p>这个函数返回的值很奇怪，它表示设备从上一次reboot到现在的秒数。</p>
</li>
<li><p>每个CALayer和CAAnimation还有自己的一个<strong>local time</strong>的概念。可以将2个layer之间的时间进行转换：</p>
<pre><code class="objective-c">- (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; 
- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l;
</code></pre>
</li>
<li><p>使用<code>self.window.layer.speed = 100;</code>会使你的整个app以100倍速运行。</p>
</li>
<li><p>来看一个自己写的代码：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIView *baseView1 = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 50, 50)];
    baseView1.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView1];
    UIView *baseView2 = [[UIView alloc]initWithFrame:CGRectMake(50, 250, 50, 50)];
    baseView2.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView2];
    UIView *baseView3 = [[UIView alloc]initWithFrame:CGRectMake(50, 450, 50, 50)];
    baseView3.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView3];
    UIView *baseView = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 50, 50)];
    baseView.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:baseView];

    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.duration = 4;
    //animation.repeatCount = 2;
    //baseView.layer.speed = 0.5;
    animation.keyPath = @&quot;position&quot;;
    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(75, 475)];
    animation.timeOffset = 2;
    //animation.removedOnCompletion = NO;
    //animation.fillMode = kCAFillModeBoth;
    animation.beginTime = [baseView.layer convertTime:CACurrentMediaTime() fromLayer:nil] + 2;
    [baseView.layer addAnimation:animation forKey:@&quot;base&quot;];
}
</code></pre>
</li>
</ol>
<h4 id="Manual-Animation"><a href="#Manual-Animation" class="headerlink" title="Manual Animation"></a>Manual Animation</h4><p>看段代码：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, strong) CALayer *doorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    self.doorLayer = [CALayer layer];
    self.doorLayer.frame = CGRectMake(0, 0, 128, 256);
    self.doorLayer.position = CGPointMake(150 - 64, 150);
    self.doorLayer.anchorPoint = CGPointMake(0, 0.5);
    //self.doorLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Door.png&quot;].CGImage;
    self.doorLayer.backgroundColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:self.doorLayer];

    //apply perspective transform
    CATransform3D perspective = CATransform3DIdentity; perspective.m34 = -1.0 / 500.0;
    self.view.layer.sublayerTransform = perspective;
    //add pan gesture recognizer to handle swipes
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] init];
    [pan addTarget:self action:@selector(pan:)];
    [self.view addGestureRecognizer:pan];
    //pause all layer animations
    self.doorLayer.speed = 0.0;
    //apply swinging animation (which won&#39;t play because layer is paused)
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @&quot;transform.rotation.y&quot;; animation.toValue = @(-M_PI_2);
    animation.duration = 1.0;
    [self.doorLayer addAnimation:animation forKey:nil];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (void)pan:(UIPanGestureRecognizer *)pan {
    //get horizontal component of pan gesture
    CGFloat x = [pan translationInView:self.view].x;
    //convert from points to animation duration //using a reasonable scale factor
    x /= 200.0f;
    //update timeOffset and clamp result
    CFTimeInterval timeOffset = self.doorLayer.timeOffset;
    timeOffset = MIN(0.999, MAX(0.0, timeOffset - x));
    self.doorLayer.timeOffset = timeOffset;
    //reset pan gesture
    [pan setTranslation:CGPointZero inView:self.view];
}

@end
</code></pre>
<p>由于在动画执行过程中无法改变animation的属性，所以可以更改它的上一级，也就是layer的属性。将speed设置成0，所以动画暂停，相当于动画一直在执行却始终是在第一帧上面执行。根据手势来改变layer的timeOffset，那么在下一次动画渲染屏幕的时候（也就是画下一帧presentation layer的时候），动画发现还处在第一帧，但是timeOffset已经变了，所以就跟着手指移动了。</p>
<h3 id="Easing"><a href="#Easing" class="headerlink" title="Easing"></a>Easing</h3><h4 id="Animation-Velocity"><a href="#Animation-Velocity" class="headerlink" title="Animation Velocity"></a>Animation Velocity</h4><ol>
<li>Easing是为了模仿现实中的有加速度的这种运动。</li>
<li>为了使用easing，可以设置CAAnimation的<strong>timingFunction</strong>属性；也可以使用CATransaction的<code>+setAnimationTimingFunction:</code>方法将easing应用到隐式动画上面。这个属性是一个<strong>CAMediaTimingFunction</strong>对象。</li>
<li>创建CAMediaTimingFunction对象的方法很多。简单的就是使用<code>+timingFunctionWithName:</code>方法。在UIView的动画中，kCAMediaTimingFunctionEaseInEaseOut是默认的，但是CAAnimation就要你自己去指定一个。注意隐式动画中的默认值是kCAMediaTimingFunctionDefault，但是显式动画中没有默认的值。</li>
<li>CAKeyframeAnimation有一个<strong>timingFunctions</strong>属性，它是一个数组。数组的长度是<strong>keyframes</strong>数组的长度减一。它表示每个关键帧之间的easing属性。</li>
</ol>
<h4 id="Custom-Easing-Functions"><a href="#Custom-Easing-Functions" class="headerlink" title="Custom Easing Functions"></a>Custom Easing Functions</h4><ol>
<li><p>可以使用CAMediaTimingFunction的<code>+functionWithControlPoints::::</code>方法来创建自定义的easing效果。这个方法的命名不太符合apple的规范。</p>
</li>
<li><p>上面函数的4个点用来构成一个bezierPath，这个bezierPath可以表示这个动画的easing效果。bezierPath的切线就是速度。todo 图片</p>
</li>
<li><p>apple定义的几个easing效果也是这样实现的，可以使用CAMediaTimingFunction的<code>-getControlPointAtIndex:values:</code>方法来获取4个点。第一个点是起点，第四个点是终点，中间两个点是控制点1和控制点2。来看看将几种系统实现的easing效果的bezierPath画出来的代码：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    //create timing function
    CAMediaTimingFunction *function = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
    //get control points
    CGPoint controlPoint1, controlPoint2;
    [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];         [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];
    //create curve
    UIBezierPath *path = [[UIBezierPath alloc] init]; 
      [path moveToPoint:CGPointZero];
    [path addCurveToPoint:CGPointMake(1, 1) controlPoint1:controlPoint1 controlPoint2:controlPoint2];
    //scale the path up to a reasonable size for display
    [path applyTransform:CGAffineTransformMakeScale(200, 200)];
    //create shape layer
    CAShapeLayer *shapeLayer = [CAShapeLayer layer]; 
      shapeLayer.strokeColor = [UIColor redColor].CGColor; 
      shapeLayer.fillColor = [UIColor clearColor].CGColor; 
      shapeLayer.lineWidth = 4.0f;
    shapeLayer.path = path.CGPath; 
      [self.layerView.layer addSublayer:shapeLayer];
    //flip geometry so that 0,0 is in the bottom-left
    self.layerView.layer.geometryFlipped = YES; 
}
</code></pre>
</li>
<li><p>奇怪的是这个函数的调用，它不传CGPoint，而是传递的float。如下：</p>
<pre><code class="objective-c">[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];
</code></pre>
<p>其中（1，0）表示第一个控制点，（0.75， 1）表示第二个控制点。</p>
</li>
<li><p>至于更加复杂的easing效果可以使用Keyframe-Based Easing。就是将复杂的easing分成多个keyframe，每个keyframe之间由一个简单的自定义easing效果来实现。这个方法需要繁琐的计算量。 todo 复杂的bezierPath的图片</p>
</li>
<li><p>还有一个简单的方法就是：每1/60s定义一个keyframe，在每个keyframe之间都是线性变化的。只要求得每个keyframe的位置就可以做出流畅的动画。取1/60s是因为iOS1/60s渲染一次屏幕，这个值已经是最佳的了，每次渲染屏幕的时候都有一个自己设的值，已经是到达最精确的控制了。其实这个时候两个关键帧之间用什么变化都无所谓的，他只是渲染两次而已，不存在什么变化。至于每个关键帧的位置如何求得，可以在<a href="http://robertpenner.com/easing找到算法。" target="_blank" rel="external">http://robertpenner.com/easing找到算法。</a></p>
</li>
</ol>
<h3 id="Timer-Based-Animation"><a href="#Timer-Based-Animation" class="headerlink" title="Timer-Based Animation"></a>Timer-Based Animation</h3><h4 id="Frame-Timing"><a href="#Frame-Timing" class="headerlink" title="Frame Timing"></a>Frame Timing</h4><ol>
<li><p>上面讲到的1/60s定义一个keyframe，其实还可以使用NSTimer来实现。也就是1/60s就执行一次更新属性的操作，然后就会重新绘制出来。但是使用NSTimer会不太精确。</p>
</li>
<li><p>NSTimer和屏幕重新绘制都是主线程的任务，主线程中的任务都要等到之前的任务执行完成后再开始执行。所以当到了执行NSTimer或者当需要开始重新绘制屏幕时，如果这时候之前的任务还没有执行结束，则需要等待。这时无论NSTimer还是重新绘制都会有一些延迟。所以可能出现，需要绘制时，NSTimer还没更新，或者在一次绘制时NSTimer已经更新了多次的情况。这时候就会出现animation的迟滞或者跳帧。看看这个的解决方案。</p>
</li>
<li><p><strong>CADisplayLink</strong>和NSTimer类似，但是他能保证在屏幕重新绘制之前被触发。但是他不是通过指定一个<strong>timeInterval</strong>来触发，而是通过<strong>frameInterval</strong>来指定两次触发之间相隔多少帧。但是它还是无法保证重新绘制屏幕能按时发生。</p>
</li>
<li><p>根据上面的问题，这时就需要精确计算上一帧发生的时间，和当前帧发生的时间。两者相减就可以知道间隔时间，就能算出现在这一帧该动画到什么程度。来看看代码：</p>
<pre><code class="objective-c">- (void)animate {
    //reset ball to top of screen
    self.ballView.center = CGPointMake(150, 32);
    //configure the animation
    self.duration = 1.0;
    self.timeOffset = 0.0;
    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];             self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];
    //stop the timer if it&#39;s already running
    [self.timer invalidate];
    //start the timer
    self.lastStep = CACurrentMediaTime();
    self.timer = [CADisplayLink displayLinkWithTarget:self
    selector:@selector(step:)]; 
      [self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}
- (void)step:(CADisplayLink *)timer {
    //calculate time delta
    CFTimeInterval thisStep = CACurrentMediaTime(); 
      CFTimeInterval stepDuration = thisStep - self.lastStep; self.lastStep = thisStep;
    //update time offset
    self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration);
    //get normalized time offset (in range 0 - 1)
    float time = self.timeOffset / self.duration;
    //apply easing
    time = bounceEaseOut(time);
    //interpolate position
    id position = [self interpolateFromValue:self.fromValue toValue:self.toValue time:time]; 
      self.ballView.center = [position CGPointValue];
    //stop the timer if we&#39;ve reached the end of the animation
    if (self.timeOffset &gt;= self.duration) {
        [self.timer invalidate];
        self.timer = nil; 
    }
}
</code></pre>
</li>
</ol>
<h4 id="Physical-Simulation"><a href="#Physical-Simulation" class="headerlink" title="Physical Simulation"></a>Physical Simulation</h4><p>看的晕头转向。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/yaozhuoyu/article/details/9566511" target="_blank" rel="external">CAMediaTiming 协议属性详解</a></li>
<li><a href="http://robertpenner.com/easing" target="_blank" rel="external">Robert Penner`s Easing Functions</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Core Animation - The Layer Beneath]]></title>
      <url>/2016/07/01/iOS-Core-Animation-reading-note-one/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>iOS Core Animation</strong>  读书笔记（一）<strong>The Layer Beneath</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="The-Layer-Tree"><a href="#The-Layer-Tree" class="headerlink" title="The Layer Tree"></a>The Layer Tree</h3><ol>
<li><strong>Layer Kit</strong>: 高效的，硬件加速的混合框架， 用来替代以Quartz为基础的，相对低效的AppKit框架。它也就是Core Animation的基础。</li>
<li><strong>Core Animation</strong> 不仅仅只和动画有关，它是iOS的核心组件之一，你在屏幕上看到的所有东西都由它来power。</li>
<li><strong>Core Animation</strong>的主要工作是将各个可视化的layer显示在屏幕上面。也就是将layer tree显示出来。</li>
<li><strong>UIView</strong> handles touch events and supports <em>Core Graphics</em>-based drawing, affine transform, and simple animations such as sliding and fading.</li>
<li>但是UIView并不是亲自处理这些任务中的大部分。渲染，布局，动画…这些任务其实都是由<em>Core Animation</em>里面的<strong>CALayer</strong>来完成的。</li>
<li><em>CALayer</em>不负责用户交互(<strong>user interaction</strong>)，和<em>responder chain</em>没有联系。</li>
<li>每一个UIView都有一个layer属性，也就是一个CALayer。实际上，UIView并没有做什么事情，关于在屏幕上的显示和动画基本上都是由CALayer来完成。UIView可以说只是一个CALayer的wrapper，负责一些手势处理，以及一些高层面的对于Core Animation的一些API的封装。</li>
<li>总结来说：UIView主要负责处理事件以及用户交互，而CALayer主要负责显示和动画。</li>
</ol>
<h3 id="The-Backing-Image"><a href="#The-Backing-Image" class="headerlink" title="The Backing Image"></a>The Backing Image</h3><h4 id="The-Contents-Image"><a href="#The-Contents-Image" class="headerlink" title="The Contents Image"></a>The Contents Image</h4><ol>
<li><p>CALayer可以包含一个图片；图片里面，你想显示啥就显示啥。这就是CALayer的<em>backing image</em>。</p>
</li>
<li><p>CALayer有一个<strong>contents</strong>属性，给这个contents属性赋值入锅不是CGImage的话，这个Layer还是什么都没有显示。要这般赋值：</p>
<pre><code class="objective-c">layer.contents = (__bridge id)image.CGImage;
</code></pre>
<p>因为，要真正赋值给contents属性的应该是一个CGImageRef，它是一个指针，指向CGImage的结构体；而UIImage的CGImage属性就是一个CGImageRef，但由于不是一个OC对象，无法赋值给id，所以需要使用(__bridge id)来转换。</p>
</li>
<li><p>CALyer的<strong>contentsGravity</strong>属性类似于UIView的contentMode。</p>
</li>
<li><p>CALayer的<strong>contentsScale</strong>属性与Retina有关。（有点不懂）</p>
</li>
<li><p><strong>contentsRect</strong>属性将backing image限制在当前CALayer矩形的一个子框框里面。它不是按点来计算的；按照统一的标尺，这个Rect的长和宽最小为0，最大为1。</p>
</li>
<li><p>iOS中用到3中坐标类型：</p>
<ol>
<li><p><strong>Points</strong>：最常用的坐标类型，point表示逻辑像素。在标准清晰度的设备中一个point代表一个pixel；在Retina设备中，一个point代表2x2个pixel。</p>
</li>
<li><p><strong>Pixels</strong>: 不常用，一般和使用pixel作为度量的CGImage等一同使用。</p>
</li>
<li><p><strong>Unit</strong>：就是contentsRect属性用到的坐标系。</p>
<p>example： todo 插入例子</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><strong>contentsCenter</strong>:该属性是一个CGRect，它定义了一个可伸缩的区域。具体的见下图：(有点不清楚)</p>
<p>example： todo 插入图片</p>
<p>其中四个黄色区域组合起来是原图。黄色区域内部四个点其实原来是一个点，也就是原图的中心点。</p>
</li>
</ol>
<h4 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h4><p>除了将一个CGImage指派给一个CALayer的contents以外，还可以直接在CALayer的<em>backing image</em>上面绘图。先来看看整个CALayer生成<em>backing image</em>的过程。</p>
<ol>
<li><p>有一个CALayerDelegate的协议，当CALayer需要对它的content进行填充时，会去请求该协议的方法。</p>
</li>
<li><p>CALayer先会请求下列方法：</p>
<pre><code class="objective-c">  - (void)displayLayer:(CALayer *)layer;
</code></pre>
<p>  在这个方法里面可以直接设置CALayer的contents属性。如果实现了这个方法，那么CALayer不会再去请求其他的方法来填充它的内容。</p>
</li>
<li><p>如果上一步未实现该方法，CALayer会去请求下面的方法：</p>
<pre><code class="objective-c">  - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>
<p>  在请求这个方法之前，<strong>CALayer会创建一个空白的backing image</strong>，和一个匹配该backing image的context。然后调用这个方法进行绘图。</p>
</li>
<li><p>只有在调用了<code>[layer display];</code>方法之后，上面说的这些delegate才会被调用。</p>
</li>
</ol>
<p>所以总结一下这个过程，首先可以直接对CALayer的contents进行设置；然后如果发现调用了<code>[layer display];</code>方法，会调用<code>- (void)displayLayer:(CALayer *)layer;</code>方法，在这个方法里面可以直接设置contents，如果没有设置就沿用之前的contents；<strong>但是如果这个方法没有实现的话，display方法会创建一个空白的backing image来取代之前设置的contents</strong>，然后再调用<code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code>方法。在这个方法里面进行绘图。</p>
<p><strong>PS</strong>：CALayer的backgroundColor和contents没有一点关系，该怎么设置就怎么设置。</p>
<p>再<strong>PS</strong>：我们一般是不需要去调用或者实现上面说的所有方法的，如果我们通过直接设置UIView或者是CALayer的属性无法达到我们的目的的时候，我们需要做的是重写UIView的<code>-drawRect:</code>方法。这个方法会帮我们在暗中处理上面说到的各种方法。</p>
<p>再再<strong>PS</strong>：如果不需要调用<code>-drawRect:</code>方法，那么久不要去重写它；因为即使是一个空的<code>-drawRect:</code>方法，程序也会花内存和CPU时间去创建一个新的，空的backing image。</p>
<h3 id="Layer-Geometry"><a href="#Layer-Geometry" class="headerlink" title="Layer Geometry"></a>Layer Geometry</h3><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><ol>
<li>对于设置UIView的<em>frame</em>，<em>bounds</em>以及<em>center</em>，其实就是调用对应CALayer的setter和getter函数，对CALayer的相对应的属性进行设置。</li>
<li>CALayer对应的属性是：<em>frame</em>, <em>bounds</em>, <em>positions</em> 和 <em>anchorPoint</em>。其中frame和bounds好理解。<strong>position</strong>的值是父layer的坐标系中的，它表示layer的旋转中心。<strong>anchorPoint</strong>的值表示position的那个点在自己layer的bounds上的比例。比如position是中点，那么anchorPoint就是(0.5, 0.5)；如果position在左上角，那么anchorPoint就是(0, 0)。</li>
<li>在iOS中，坐标系原点在左上角；在Mac OS中，坐标系原点在左下角。通过设置CALayer的<strong>geometryFlipped</strong>属性，可以改变坐标系从左上变到左下。只需将geometryFlipped设置为YES。</li>
<li>UIView是严格的二维平面；但是，CALayer存在三维空间。CALayer有<strong>zPosition</strong>和<strong>anchorPointZ</strong>属性。除了用在CATransform3D外，比较有用的就是改变layer的现实顺序，zPosition越大，越靠前显示。</li>
</ol>
<h4 id="Hit-Testing"><a href="#Hit-Testing" class="headerlink" title="Hit Testing"></a>Hit Testing</h4><ol>
<li>CALayer不知道responder chain的存在，不能直接处理用户的交互动作。只有几个函数和用户交互有关。比如<code>-hitTest:</code>。</li>
<li><strong><code>-hitTest:</code></strong> 返回CGPoint的点在哪个CALayer。</li>
</ol>
<h4 id="Automatic-Layout"><a href="#Automatic-Layout" class="headerlink" title="Automatic Layout"></a>Automatic Layout</h4><ol>
<li>你可以通过UIVIew的UIViewAutoresizingMask和NSLayoutConstraint相关的API来使用autolayout。但是，如果你想直接通过操作CALayer来使用autolayout，最简单的方法就是使用CALayerDelegate的<code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code>方法。但是它不好用，所以最好是直接操作UIView…</li>
<li>上面是一个佐证：你最好使用带layer的view来组织你的界面，而不是使用单独的layer。</li>
</ol>
<h3 id="Visual-Effects"><a href="#Visual-Effects" class="headerlink" title="Visual Effects"></a>Visual Effects</h3><ol>
<li><strong>cornerRadius</strong>默认的只会影响background color，不对backing image产生影响。但是加上<strong>masksToBounds</strong>之后，layer就确保了又圆角的属性。</li>
<li>CALayer的border是被花在CALayer的内部的，在任何的sublayer的上面。</li>
<li>CALayer的shadow不同于border的是：它是基于backing image的边缘的，而不是bounds的边缘。有点厉害</li>
<li>CALayer的shadow通常是画在bounds的外部的，所以会被masksToBounds给切掉。。。</li>
<li>CALayer的<strong>shadowPath</strong>属性可以强制指定一个shadow的形状。该属性的值是一个CGPathRef。可以使用UIBezierPath。</li>
<li>CALayer的<strong>mask</strong>属性也是一个CALayer。但是它的作用是定义这个父layer的可见的部分。这个mask layer最重要的就是它的轮廓（和上面的shadow的边缘有点类似），它的父layer只会显示轮廓内的部分。</li>
<li>CALayer的<strong>minificationFilter</strong>和<strong>magnificationFilter</strong>属性用于指定图片放大缩小时图片的显示方式。专业一点说就是生成图片像素的算法。他们有3个选项：kCAFilterLinear，kCAFilterNearest和kCAFilterTrilinerar。其中，nearest适合用于小图片以及图片颜色变化很尖锐的；而其他两个用于图片颜色变化比较缓和的，也就是均匀的，不会两个相邻像素之间颜色发生突变。</li>
</ol>
<h3 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h3><h4 id="Affine-Transforms"><a href="#Affine-Transforms" class="headerlink" title="Affine Transforms"></a>Affine Transforms</h4><ol>
<li><p>利用CFAffineTransform的时候，其实可以计算原来view的四个点对应的变化之后的四个点，来确定变化之后的view的形状以及位置。</p>
</li>
<li><p>UIView的<strong>transform</strong>属性是一个CGAffineTransform，CALayer的<strong>transform</strong>属性是一个CATransform3D。CALayer中和UIView的transform等同的一个属性叫做<strong>affineTransform</strong>。其实对UIView的transform属性进行操作，实际上也是对CALayer进行操作，它只是一个向上的包装而已。</p>
</li>
<li><p>通过如下代码：</p>
<pre><code class="objective-c">CGAffineTransform transform = CGAffineTransformIdentity;
transform = CGAffineTransformScale(transform, 0.5, 0.5);
transform = CGAffineTransformRotate(transform, M_PI / 180 * 30);
transform = CGAffineTransformTranslate(transform, 200, 0);
</code></pre>
<p>记住，这里最后一步向右平移200点，其实并没有平移200点。因为，这样连续的变化，向右平移200点的transform受到了之前两步transform的影响。它其实被scale了一半，然后被旋转了30度。可以想象成向右200的向量吧(不确定)。</p>
</li>
<li><p>还有一种变换无法用translate， rotate和scale来表示。那就是：原View是矩形，变换之后了View变成了平行四边形。有点类似投影。那样的话就得直接修改CGAffineTransform矩阵中的值了。如下：</p>
<pre><code class="objective-c">CGAffineTransform transform = CGAffineTransformIdentity;
transform.c = -x;
transform.b = y;
</code></pre>
</li>
</ol>
<h4 id="3D-Transforms"><a href="#3D-Transforms" class="headerlink" title="3D Transforms"></a>3D Transforms</h4><ol>
<li>Core Graphics framework是一个2维的画图的库。而CALayer的transform属性是一个CATransform3D，3D的。所以需要用到Core Animation framework。</li>
<li>控制透视效果，也就是远处的view看上去比近处的小。这个效果可以通过控制CATransform3D的m34值来实现。m34用来表示X，Y轴的放大系数与view距离camera的类似比值的一个东西。m34默认为0，将它定义成 -1.0/d，d表示view到镜头的距离，取500-1000之间的值都可以。d取值越小，透视的效果越明显。todo 来两张图</li>
<li>3D最远端的消失点定义在layer的anchorPoint。</li>
<li>CALayer的sublayerTransform属性可以为sublayer统一指定他们的perspective和vanishing point。</li>
<li>沿Y轴旋转180度，就把layer翻转过来了，呈现镜像。但是如果将CALayer的<strong>doubleSided</strong>设置成NO，那么反面就不会被draw出来。</li>
<li>对于外部的layer外转，内部的layer内转，得分情况来讨论。如果是按照Z轴来旋转，那么内部的layer旋转被抵消，正面显示。但是如果按照Y轴旋转，虽然内部的旋转也被抵消，但是显示在屏幕上的其实是内部layer在外部layer上的投影；此时外部layer已经倾斜了，虽然内部layer很正，但是显示投影上去还是倾斜的。todo 来张图</li>
<li>CATransform3D 先位移再旋转和先旋转再位移是不一样的。要始终找到旋转以及平移的中心点，以该中心点建立三维坐标系。当旋转或平移时，该坐标系也会跟着旋转和平移，那么下一步的选装或平移要以当前最新的坐标系为标准。</li>
<li>UIView的touch event接收顺序与zPosition无关，还是与添加UIView的顺序相关。</li>
</ol>
<h3 id="Specialized-Layers"><a href="#Specialized-Layers" class="headerlink" title="Specialized Layers"></a>Specialized Layers</h3><h4 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h4><ol>
<li><p>CAShapeLayer使用矢量画图，而不是位图(bitmap image)。</p>
</li>
<li><p>相比与普通的CALayer，它更快：硬件加速；内存更高效：不需要创建backing image；不会被边界限制（backing image的context）；放大缩小时不是像素化的：矢量图。</p>
</li>
<li><p>创建CAShapeLayer的CGPath时只能创建一次，不能分开多次创建。也就是说CGPath的路径，颜色，线段粗细等属性只能在创建时一次性全部设置。如果想画多个不同类型(比如：不同颜色，不同粗细等)的shape，那么就得创建多个layer。</p>
</li>
<li><p>CAShapeLayer的<strong>path</strong>属性是一个CGPath，但是使用UIBezierPath，可以简化我们的使用，不用手动去释放CGPath。</p>
</li>
<li><p>创建一个只有3个角的bezierPath：</p>
<pre><code class="objective-c">CGRect rect = CGRectMake(50, 50, 100, 100); CGSize radii = CGSizeMake(20, 20); UIRectCorner corners = UIRectCornerTopRight |
UIRectCornerBottomRight | UIRectCornerBottomLeft;
//create path
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
</code></pre>
<p>可以把这个CGPath构成的CAShapeLayer当做某个CALayer的mask。</p>
</li>
</ol>
<h4 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h4><ol>
<li><p>CATextLayer提供了UILabel的绝大部分功能，以及一些自己的功能，并且比UILabel渲染的更快。</p>
</li>
<li><p>CATextLayer要注意提供<strong>contentsScale</strong>属性，以保证在各种屏幕上显示正确。</p>
</li>
<li><p>它的<strong>font</strong>属性是一个CFTypeRef，所以可以给他CTFontRef或者是CGFontRef；而且这两个和UIFont一样不会压缩point size，也就是字体大小；所以还需要自己指定<strong>fontSize</strong>属性。</p>
</li>
<li><p>CATextLayer在iOS3.2的时候就已经支持attributed string了，比UILabel等UIKit元素更早。</p>
</li>
<li><p>但是它的行间距和字间距比UILabel的表现要差。</p>
</li>
<li><p>CALayer不太支持autolayout和autoresizing…</p>
</li>
<li><p><strong>如何让一个UIView的root layer不是普通的CALayer呢？</strong>UIView通过<code>+ (Class)layerClass;</code>方法来返回root layer的类型；所以只需要在我们自己的View类里面重写该方法就可以。</p>
<pre><code class="objective-c">@implementation LayerLabel  // 自定义的UIView
+ (Class)layerClass {  // override layerClass of UIView
      return [CATextLayer class];
}
</code></pre>
<p>那么这时就不会调用<code>-drawRect:</code>方法来绘图，而是使用CATextLayer自己来渲染文字。将CATextLayer作为UILabel的root layer还有个好处，就是不需要设置contentsScale。因为这个被UIView自己设置了。这也佐证了使用带layer的View比单独使用layer要方便。</p>
</li>
</ol>
<h4 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h4><ol>
<li><p>它的存在解决了之前说的外部layer外转内部layer内转，但是内部layer显示奇怪的问题。这个问题的根本原因就是所有sublayer都被containerLayer给扁平化得显示在它自己的空间内，有点剥夺3d效果的感觉。</p>
</li>
<li><p>CATransformLayer不能用于显示任何内容，它必须包含一些sublayer。它有可以应用于sublayer的transform，可以使sublayer立体化起来。</p>
</li>
<li><p>这个例子很赞：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *containerView; 
@end
@implementation ViewController
- (CALayer *)faceWithTransform:(CATransform3D)transform {
    //create cube face layer
    CALayer *face = [CALayer layer];
    face.frame = CGRectMake(-50, -50, 100, 100);

    //apply a random color
    CGFloat red = (rand() / (double)INT_MAX); 
    CGFloat green = (rand() / (double)INT_MAX); 
    CGFloat blue = (rand() / (double)INT_MAX); 
    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;

     //apply the transform and return
    face.transform = transform;

    return face; 
}

- (CALayer *)cubeWithTransform:(CATransform3D)transform {
    //create cube layer
    CATransformLayer *cube = [CATransformLayer layer];

    //add cube face 1
    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //add cube face 2
    ct = CATransform3DMakeTranslation(50, 0, 0); 
    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //add cube face 3
    ct = CATransform3DMakeTranslation(0, -50, 0); 
    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //add cube face 4
    ct = CATransform3DMakeTranslation(0, 50, 0); 
    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //add cube face 5
    ct = CATransform3DMakeTranslation(-50, 0, 0); 
    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //add cube face 6
    ct = CATransform3DMakeTranslation(0, 0, -50); 
    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0); 
    [cube addSublayer:[self faceWithTransform:ct]];

    //center the cube layer within the container
    CGSize containerSize = self.containerView.bounds.size; 
    cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);

    //apply the transform and return
    cube.transform = transform;
    return cube; 
}

- (void)viewDidLoad { 
    [super viewDidLoad];
    //set up the perspective transform
    CATransform3D pt = CATransform3DIdentity; 
    pt.m34 = -1.0 / 500.0; 
    self.containerView.layer.sublayerTransform = pt;

    //set up the transform for cube 1 and add it
    CATransform3D c1t = CATransform3DIdentity; 
    c1t = CATransform3DTranslate(c1t, -100, 0, 0); 
    CALayer *cube1 = [self cubeWithTransform:c1t]; 
    [self.containerView.layer addSublayer:cube1];

    //set up the transform for cube 2 and add it
    CATransform3D c2t = CATransform3DIdentity;
    c2t = CATransform3DTranslate(c2t, 100, 0, 0); 
    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0); 
    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0); 
    CALayer *cube2 = [self cubeWithTransform:c2t]; 
    [self.containerView.layer addSublayer:cube2];
}
@end
</code></pre>
<p>todo add picture</p>
</li>
</ol>
<h4 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h4><ol>
<li>测试了重写View的layerClass方法之后发现，对于CATextLayer，不会调用<code>-drawRect;</code>方法，但是对于其他种类的layer，还是会调用<code>-drawRect;</code>方法。</li>
<li>硬件加速。</li>
<li><strong>colors</strong>属性是一个数组。里面装的是CGColorRef，不是UIColor。所以还是需要使用<code>(__bridge id)</code>。<strong>startPoint</strong>和<strong>endPoint</strong>指定渐变方向，这两个属性使用的是<em>unit coordinates</em>。</li>
<li>colors属性可以添加任意个颜色，默认的他们是均匀分布的；但是我们可以通过<strong>locations</strong>属性改变他们的分布。<strong>locations</strong>属性是一个装着NSNumber(float value)的数组，从0-1，表示各种color的终区段。</li>
</ol>
<h4 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h4><ol>
<li><p>它是用来高效的生成一系列相似的layer。</p>
</li>
<li><p><strong>instanceCount</strong>属性指定copy的个数，<strong>instanceTransform</strong>属性指定变化，各个变化是叠加的。</p>
</li>
<li><p>说不清楚，直接上代码…</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *containerView; 
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];

    //create a replicator layer and add it to our view
    CAReplicatorLayer *replicator = [CAReplicatorLayer layer]; 
    replicator.frame = self.containerView.bounds; 
    [self.containerView.layer addSublayer:replicator];

    //configure the replicator
    replicator.instanceCount = 10;

    //apply a transform for each instance
    CATransform3D transform = CATransform3DIdentity;
    transform = CATransform3DTranslate(transform, 0, 200, 0); 
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);

    transform = CATransform3DTranslate(transform, 0, -200, 0); 
    replicator.instanceTransform = transform;

    //apply a color shift for each instance
    replicator.instanceBlueOffset = -0.1; 
    replicator.instanceGreenOffset = -0.1;

    //create a sublayer and place it inside the replicator
    CALayer *layer = [CALayer layer];
    layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f); 
    layer.backgroundColor = [UIColor whiteColor].CGColor; 
    [replicator addSublayer:layer];
}
@end
</code></pre>
<p>todo add picture</p>
</li>
</ol>
<h4 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h4><ol>
<li>一个可以scroll的layer，有一个方法<code>-scrollToPoint:</code>。因为CALayer无法处理用户手势操作，所以这个方法也是这个layer所能做的所有事了。。。可以从UIView的层面获取手势所处的point，再将该point传递给CAScrollLayer。</li>
<li>该layer滑动的时候，改变的是layer的bounds。</li>
</ol>
<h4 id="OtherLayer"><a href="#OtherLayer" class="headerlink" title="OtherLayer"></a>OtherLayer</h4><ol>
<li>Core Animation使用CPU来处理图片，而不是更快的GPU。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[卧槽]]></title>
      <url>/2016/06/07/ollie/</url>
      <content type="html"><![CDATA[<p>昨天晚上，也就是2016-6-6这么个666的日子，我ollie过一立了=。=</p>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[弹框按钮视图]]></title>
      <url>/2016/05/19/ios-pop-menu/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间又在忙项目的事，对<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a>源码的学习只能先暂搁一旁。今天抽空来看看一个Coding-iOS中一个有趣的实现。这个和微博里面发送微博时的动效类似。效果如下👇<br><img src="/lionheart/1605/weibo.gif" alt="weibo"></p>
<a id="more"></a>
<h2 id="前言二"><a href="#前言二" class="headerlink" title="前言二"></a>前言二</h2><p>源码在<a href="https://github.com/xhzengAIB/PopMenu" target="_blank" rel="external">这里</a><br>我自己也简单的实现了一遍，看看效果👇<br><img src="/lionheart/1605/weibomy.gif" alt="weibomy"><br>我也把源码上传到<a href="https://github.com/vanney9/blogDemo/tree/master/testweibo" target="_blank" rel="external">github</a>了</p>
<h2 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h2><p>这个PopMenu主要由2部分构成：模糊背景和按钮</p>
<ol>
<li>模糊背景<br>模糊背景直接就是白色半透明的View，它是PopMenu这个View的最底层的子View。这个模糊背景View的透明度从0-&gt;0.5渐变，当这个动画完成之后，开始显示按钮的动画。</li>
<li>按钮<br>说是按钮，其实也是一个自定义的View，它由一个图片(UIImageView)和一个标题(UILabel)构成。这些按钮也是PopMenu这个View的子View。</li>
<li>PopMenu View<br>这个View是主视图，它包括最底层的模糊背景视图和多个按钮视图。在这个视图内部定义了几个重要的方法<ul>
<li>定义每一个按钮视图的其实位置和最终位置</li>
<li>未每个按钮视图添加动画</li>
</ul>
</li>
</ol>
<h2 id="按钮位置"><a href="#按钮位置" class="headerlink" title="按钮位置"></a>按钮位置</h2><p>先来看看按钮视图的最终位置👇<br><img src="/lionheart/1605/finalPosition.png" alt="finalPosition"><br>给每个视图定大小很简单：先定死高度为110，再根据每行放置几个按钮定义按钮的宽度(例如本文每行3个按钮，那就屏幕宽度除以3)；最后定义按钮在PopMenu视图中的位置，也就是它的左上角相对于主视图的坐标，这个稍加计算就可得出。<br>而每个按钮其实开始的位置是在屏幕上方的，那么每个按钮的起始位置也就是最终位置向上平移一个相同的量，直至移出屏幕上方为止。</p>
<h2 id="下落动画"><a href="#下落动画" class="headerlink" title="下落动画"></a>下落动画</h2><p>仔细瞧瞧，每个按钮的下落动画是一样的，只是开始时间不同而已。所以这些按钮动画的设置只需用开始时间进行区分即可。这里的动画使用了<a href="https://github.com/facebook/pop" target="_blank" rel="external">POPAnimation</a>，它是Facebook的一个著名的开源库。<br>来看看动画的源代码👇</p>
<pre><code>        - (void)startAnimationFromPosition:(CGRect)from toPosition:(CGRect)to atView:(UIView *)view beginTime:(CFTimeInterval)beginTime {
            POPSpringAnimation *springAnimation = [POPSpringAnimation animation]; // 新建一个弹簧动画
            springAnimation.property = [POPAnimatableProperty propertyWithName:kPOPViewFrame]; // 这个动画作用于View的Frame
            springAnimation.removedOnCompletion = YES; // 动画执行结束后删除该动画
            springAnimation.beginTime = beginTime + CACurrentMediaTime(); // 定义动画开始时间， 现在时间加上一个动画执行延迟
            springAnimation.springBounciness = 6; // 定义弹簧动画弹动程度
            springAnimation.springSpeed = 2; // 定义动画的速度

            springAnimation.fromValue = [NSValue valueWithCGRect:from]; // 定义动画开始位置
            springAnimation.toValue = [NSValue valueWithCGRect:to]; // 定义动画结束位置

            [view pop_addAnimation:springAnimation forKey:@&quot;vanney9&quot;]; // 给视图添加该动画，这个视图就是上面的按钮视图
        }

        // 按钮调用动画
        [self startAnimationFromPosition:from toPosition:to atView:button beginTime:0.1 * index];
</code></pre><p>POPAnimation的使用很简单，首先定义动画要做什么，什么时候开始执行，动画的起始和结束位置等等。。。动画定义完成之后，将该动画附加到一个视图上面，这里就是将弹簧动画赋予按钮视图；然后每个按钮视图的动画的执行时间都是按一定间隔隔开的。这样就完成了上图所展示的效果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/xhzengAIB/PopMenu" target="_blank" rel="external">PopMenu</a></li>
<li><a href="https://github.com/facebook/pop" target="_blank" rel="external">Facebook POP开源库</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS关于文件上传与下载]]></title>
      <url>/2016/05/12/app-download-uoload-manager/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近还在跟着<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS源码</a>学习iOS开发，现在来介绍一下Coding-iOS的文件下载和上传机制。其实说实话，在写这文章的时候我对这个机制的总体把握也不是很全面；下面我将通过源码再来熟悉一遍这个全过程。这篇文章主要介绍的是下载流程。</p>
<a id="more"></a>
<h2 id="源码先行"><a href="#源码先行" class="headerlink" title="源码先行"></a>源码先行</h2><h3 id="Coding-FileManager"><a href="#Coding-FileManager" class="headerlink" title="Coding_FileManager"></a><code>Coding_FileManager</code></h3><p>Coding-iOS中将文件下载与上传有关的方法都封装在<code>Coding_FileManager.h</code>和<code>Coding_FileManager.m</code>文件里面。先来看看其中的主要代码👇<br><code>Coding_FileManager</code>里面包含3个类：<code>Coding_FileManager</code>类，<code>Coding_DownloadTask</code>类和<code>Coding_UploadTask</code>类。其中的Coding_UploadTask类与上传有关，这里不做介绍。</p>
<h4 id="Coding-DownloadTask类"><a href="#Coding-DownloadTask类" class="headerlink" title="Coding_DownloadTask类"></a><code>Coding_DownloadTask</code>类</h4><p>Coding_DownloadTask类用来封装每一个下载任务，它包含一个下载任务，下载进度和当前下载的文件名，代码如下👇</p>
<pre><code>        @interface Coding_DownloadTask : NSObject
        @property (nonatomic, strong) NSURLSessionDownloadTask *task;  // 下载任务
        @property (nonatomic, strong) NSProgress *progress;  // 下载进度
        @property (nonatomic, strong) NSString *fileName;  // 下载文件名

        + (Coding_DownloadTask *)cDownloadTaskWith:(NSURLSessionDownloadTask *)task progress:(NSProgress *)progress fileName:(NSString *)fileName;  // 初始化函数
        - (void)cancel;  // 取消当前下载函数
        @end
</code></pre><p>他的两个方法的实现也很简单：👇</p>
<pre><code>        + (Coding_DownloadTask *)cDownloadTaskWith:(NSURLSessionDownloadTask *)task progress:(NSProgress *)progress fileName:(NSString *)fileName {
            Coding_DownloadTask *cDownloadTask = [Coding_DownloadTask alloc] init];
            cDownloadTask.task = task;
            cDownloadTask.progress = progress;
            cDownloadTask.fileName = fileName;

            return cDownloadTask;
        }

        - (void)cancel {
            if (_task &amp;&amp; (_task.state == NSURLSessionTaskStateRunning || _task.state == NSURLSessionTaskStateSuspended)) {
                [_task cancel];  // 先判断task的state， 如果可以取消， 那就取消
            }
        }
</code></pre><h4 id="Coding-FileManager类"><a href="#Coding-FileManager类" class="headerlink" title="Coding_FileManager类"></a><code>Coding_FileManager</code>类</h4><p>这个类是文件下载上传机制里面的最最最核心的类，好好来看看👇</p>
<ol>
<li><p>类的声明</p>
<pre><code>     @interface Coding_FileManager : NSObject
     + (Coding_FileManager *)sharedManager;  // 单例模式
     + (AFURLSessionManager *)af_manager;
     - (AFURLSessionManager *)af_manager;

     + (Coding_DownloadTask *)cDownloadTaskForKey:(NSString *)storage_key;  // 根据特定的key获取特定的Coding_DownloadTask
     + (NSURL *)diskDownloadUrlForKey:(NSString *)storage_key;  // 暂时不明
     - (Coding_DownloadTask *)addDownloadTaskForObj:(id)obj completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler;  // 对于新文件，新建下载任务
     @end
</code></pre></li>
<li>类的实现</li>
</ol>
<ul>
<li><code>属性</code><ol>
<li>1个监控文件夹变化的属性：docDownloadWatcher，它是一个<code>DirectoryWatcher</code>对象，用来监控APP下载文件存放的文件夹的动态</li>
<li>2个字典，downloadDict和diskDownloadDict。downloadDict用来存放当前的下载任务(Coding_DownloadTask)，它的key是storage_key；diskDownloadDict用来存放下载的文件的路径URL，它的key也是storage_key</li>
<li>1个NSURL，downloadDirectory, 用来存放下载文件的文件夹的路径URL</li>
</ol>
</li>
<li><p><code>方法</code></p>
<ol>
<li><p><code>sharedManager</code></p>
<pre><code>       // 单例模式初始化Coding_FileManager
       + (Coding_FileManager *)sharedManager {
           static Coding_FileManager *manager = nil;
           static dispatch_once_t onceToken;
           dispatch_once(&amp;onceToken, ^{
               manager = [Coding_FileManager alloc] init];
               // 创建存放下载文件的文件夹
               [manager urlForDownloadFolder];
           });

           return manager;
       }
</code></pre></li>
<li><p><code>init</code></p>
<pre><code>       // 初始化
       - (instancetype)init {
           self = [super init];
           if (self) {
               [[self class] createFolder:[[self class] downloadPath]]; // 创建下载目录
               _downloadDict = [NSMutableDictionary alloc] init]; // 初始化存放下载任务的字典
               _diskDownloadDict = [NSMutableDictionary alloc] init]; //
               _downloadDirectoryURL = nil; //初始化下载目录的文件夹URL
               _docDownloadWatcher = [DirectoryWatcher watchFolderWithPath:[[self class] downloadPath] delegate:self]; // 添加文件夹状态监控器
               [self directoryDidChange:_docDownloadWatcher]; // 初始化的时候先来之行一遍监控程序
           }

           return self;
       }
</code></pre></li>
<li><p><code>urlForDownloadFolder</code></p>
<pre><code>       // 创建存放下载图片的文件夹
       - (NSURL *)urlForDownloadFolder {
           if (!_downloadDirectoryURL) {
               if ([self class] createFolder:[[self class] downloadPath]) { // 创建存放下载文件的文件夹
                   // 文件夹创建成功
                   _downloadDirectoryURL = [NSURL fileURLWithPath:[[self class] downloadPath] isDirectory:YES];
               } else {
                   // alert create folder error
               }
           }

           return _downloadDirectoryURL;
       }
</code></pre></li>
<li><code>downloadPath</code><pre><code>       // 得到下载目录文件夹的路径, 该APP的Document目录下面的Coding_Download文件夹
       + (NSString *)downloadPath {
           NSString *documentPath = [NSSearchPathForDirecrotiesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
           NSString *downloadPath = [documentPath stringByAppendingPathComponent:@&quot;Coding_Download&quot;];
           return downloadPath;
       }
</code></pre></li>
<li><p><code>createFolder</code></p>
<pre><code>       // 创建文件夹
       + (BOOL) createFolder:(NSString *)path {
           BOOL isDir = NO;
           NSFileManager *fileManager = [NSFileManager defaultManager];
           BOOL existed = [fileManager fileExistsAtPath:path isDirectory:&amp;isDir];
           BOOL isCreated = NO;
           if (!(isDir == YES &amp;&amp; existed == YES)) {
               isCreated = [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil];
           } else {
               isCreated = YES;
           }

           return isCreated;
       }
</code></pre></li>
<li><p><code>cDownloadTaskForKey</code></p>
<pre><code>       + (Coding_DownloadTask *)cDownloadTaskForKey:(NSString *)storage_key {
           if (!storage_key) {
               return nil;
           }

           // 当前的每个下载任务 Coding_DownloadTask 都存放在 _downloadDict 里面，对应的key是storage_key
           return [self sharedManager].downloadDict objectForKey:storage_key];
       }
</code></pre></li>
<li><p><code>directoryDidChange:(DirectoryWatcher *)folderWatcher</code></p>
<pre><code>       // DirectoryWatcher的delegate， 当文件夹里面的文件变动时触发
       - (void)directoryDidChange:(DirectoryWatcher *)folderWatcher {
           NSMutableDictionary *diskDict = _diskDownloadDict;
           NSString *path = [[self class] downloadPath];
           BOOL isDownload = YES;

           /* 先移除diskDict里面的所有文件URL，再将当前下载目录里面的所有文件URL添加到diskDict里面 */
           [diskDict removeAllObjects];
           NSArray *fileContents = [NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:NULL]; // 获取path文件夹下面的所有内容，将所有文件名存放在fileContents数组里面
           for (NSString *curFileName in [fileContents objectEnumerator]) { // 遍历文件名
               NSString *filePath = [path stringByAppendingPathComponent:curFileName]; // 当前文件的完整的路径
               NSURL *fileUrl = [NSURL fileURLWithPath:filePath]; // 当前文件的URL
               BOOL isDirectory;
               [NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&amp;isDirectory]; // 判断当前文件是否是文件夹
               if (!isDirectory) { // 如果不是文件夹， 存入diskDict
                   NSString *keyStr = [curFileName componentsSeparatedByString:@&quot;|&quot;].lastObject; // 因为下载文件名命名为&#39;IMG_0002.JPG|||264314|||QiniuStorage|c09bd7ea-6be9-431c-afc1-884293895719.JPG&#39;， 最后的|后面是storage_key
                   [diskDict setObject:fileUrl forKey:keyStr];
               }
           }
       }
</code></pre></li>
<li><p><code>addDownloadTaskForObj:completionHandler</code></p>
<pre><code>       // 新建下载任务
       - (void)addDownloadTaskForObj:(id)obj completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler {
           Coding_DownloadTask *cTask = nil;
           ProjectFile *file = (ProjectFile *)obj; // Coding-iOS中的一个model
           cTask = [self addDownloadTaskWithPath:file.downloadPath diskFileName:fileDiskFileName storage_key:file.storage_key completionHandler:completionHandler];

           return cTask;
       }
</code></pre></li>
<li><p><code>addDownloadTaskWithPath:diskFileName:storage_key:completionHandler</code></p>
<pre><code>       // 新建下载任务 具体的
       - (void)addDownloadTaskWithPath:(NSString *)downloadPath diskFileName:(NSString *)diskFileName storage_key:(NSString)storage_key completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler {
           NSProgress *progress;
           NSURL *downloadPath = [NSURL URLWithString:downloadPath];
           NSURLRequest *request = [NSURLRequest requestWithURL:downloadPath];
           NSURLSessionDownloadTask *downloadTask = [self.af_manager downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
               NSURL *downloadURL = [Coding_FileManager sharedManager] urlForDownloadFolder];
               Coding_DownloadTask *cDownloadTask = [Coding_FileManager cDownloadTaskForResponse:response];
               if (cDownloadTask) {
                   downloadUrl = [downloadUrl URLByAppendingPathComponent:cDownloadTask.diskFileName];
               } else {
                   downloadUrl = [downloadUrl URLByAppendingPathComponent:[response suggestedFileName]];
               }

               return downloadUrl; // 返回存储的目标位置
           } completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
               if (error) {
                   [Coding_FileManager cancelCDownloadTaskForKey:storage_key];
               } else {
                   [Coding_FileManager cancelCDownloadTaskForResponse:response];
               }
           }];

           Coding_DownloadTask *cDownloadTask = [Coding_DownloadTask cDownloadTaskWithTask:downloadTask progress:progress fileName:diskFileName];

           [self.downloadDict setObject:cDownloadTask forKey:storage_key];
           [downloadTask resume];
           return cDownloadTask;
       }
</code></pre></li>
</ol>
</li>
</ul>
<h2 id="实力分析"><a href="#实力分析" class="headerlink" title="实力分析"></a>实力分析</h2><p>源码已经介绍完了，来分析一波。注意下面几个要点👇</p>
<ol>
<li>每个下载任务都是一个<code>Coding_DownloadTask</code>类的实例，这个类里面有个NSURLSessionDownloadTask属性</li>
<li>所有下载有关的操作都会涉及到一个类<code>Coding_FileManager</code>，Coding会创建一个<code>Coding_FileManager</code>的单例类（既：APP生命周期内只会有一个这个类的实例）。该实例有两个字典：1个负责存储已经下载下来的文件的文件URL，另一个负责存储当前还在进行的下载任务(Coding_DownloadTask)。这两个字典的key由后台定义，每个文件／任务对应唯一的一个storage_key</li>
<li>所有下载的文件存放在APP的Document文件夹下面的Coding_Download文件夹下面，在创建单例类Coding_FileManager的时候检测该文件夹是否存在，不存在就创建。</li>
<li>开始一个新的下载任务其实就是创建一个NSURLSessionDownloadTask，然后再将该NSURLSessionDownloadTask封装进Coding_DownloadTask。而创建该NSURLSessionDownloadTask用的是AFURLSessionManager的downloadTaskWithRequest方法。</li>
<li>有一个监控下载文件夹内容变化的监控器，每当文件夹内容变化时（文件被删除或文件下载完成）它会自动更新存放下载文件路径URL的字典，也就是更新当前APP下载了哪些文件</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来用精炼的语言来总结一番：</p>
<ol>
<li>每个下载任务／文件都有唯一与之对应的storage_key。每当新来一个下载任务时，先查看已经完成的文件里面是否包括了该文件(即：查看存放已下载文件的字典是否有该storage_key)。若已经下载，则完成下载任务；还未下载，进行第二步。</li>
<li>判断该任务是否存在(即：查看存储下载任务的字典，看是否有该storage_key)。若该任务存在，说明之前这个任务可能被暂停了，那么继续该下载任务，并跳过步骤3；若该任务不存在，那么进行第三步。</li>
<li>根据任务的storage_key，文件的url创建Coding_DownloadTask，其实主要的是创建一个NSURLSessionDownloadTask，然后将该Coding_DownloadTask存放到存储下载任务的字典中，并开始下载文件。</li>
<li>当文件下载完成时候，从存储下载任务的字典中将这个任务删除；并且文件会被存放到相应的文件夹，触发文件夹监控器的函数，将该文件的文件URL添加到存储已经下载完成的文件URL的字典中。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></li>
</ul>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h2><p>已经过了2个大冰红茶了，一立还会远嘛～～～</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[NSObject+ObjectMap 源码分析]]></title>
      <url>/2016/05/07/NSObject-ObjectMap/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS应用从API获得的数据有很重要的一部分是以JSON格式返回的，通过AFNetworking，这种JSON格式会被转换成NSDictionary或者NSArray，从而被APP所接收。<br>这时，如果能将这些NSDictionary/NSArray转化成APP中已经封装好的各种Model，将极大的简化APP的开发。<br>有很多第三方库已经实现了这个功能，比较知名的就有<a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">MJExtension</a></p>
<blockquote>
<p>MJExtension: A fast, convenient and nonintrusive conversion between JSON and model. Your model class don’t need to extend another base class. You don’t need to modify any model file.</p>
</blockquote>
<p>嗯，这个第三方库很有名，功能强大，使用也方便，但是本文并不介绍它。在这篇文章里面，我将介绍一个小的从JSON到Model进行转换的第三方库，这个库小到没有一个像样的名字，我在github上也只找到了一个模糊的地址：<a href="https://github.com/uacaps/NSObject-ObjectMap" target="_blank" rel="external">uacaps/NSObject-ObjectMap</a> (<em>注</em> 不能确认是否是本文所介绍的)。<br>另外，我也将本文所介绍的这个第三方库上传到我的<a href="https://github.com/vanney9/blogDemo/tree/master/NSObject%2BObjectMap" target="_blank" rel="external">github</a>上去了。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>说正事，这个第三方库只包含2个文件，<code>NSObject+ObjectMap.h</code>和<code>NSObject+ObjectMap.m</code>。从名字可以看出，它应该是实现了NSObject类的一个category，的确也是如此的。用下面几张图来说说这个库具体干了些什么。</p>
<ol>
<li>APP通过API获得Server提供的数据是JSON格式的，如下👇<br><img src="/lionheart/1605/json.png" alt="JSON"></li>
<li>该JSON格式的数据经过AFNetworking返回给APP的数据形式是<code>NSDictionary</code>({…})或者<code>NSArray</code>([…])</li>
<li>这些数据经过<code>NSObject+ObjectMap</code>转化成最终的model对象，如下👇<br><img src="/lionheart/1605/model.png" alt="Model"></li>
</ol>
<h2 id="正经的源码分析"><a href="#正经的源码分析" class="headerlink" title="正经的源码分析"></a>正经的源码分析</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>从Network Request中得到的数据如下👇<br><img src="/lionheart/1605/json.png" alt="JSON"><br>调用NSObject+ObjectMap中的函数，将JSON-&gt;Model</p>
<pre><code>        id resultData = [data valueForKeyPath:@&quot;data&quot;];
        ProjectTopics *resultT = [NSObject objectOfClass:@&quot;ProjectTopics&quot; fromJSON:resultData];
</code></pre><h3 id="正经实现"><a href="#正经实现" class="headerlink" title="正经实现"></a>正经实现</h3><p><code>+(id)objectOfClass:(NSString *)object fromJSON:(NSDictionary *)dict;</code><br>该函数是本文分析的核心，它实现了将JSON-&gt;Model，来看看它具体是如何实现的。</p>
<h4 id="初始化Model对象-例子中使用的是ProjectTopics对象-，借助NSClassFromString的帮助"><a href="#初始化Model对象-例子中使用的是ProjectTopics对象-，借助NSClassFromString的帮助" class="headerlink" title="初始化Model对象(例子中使用的是ProjectTopics对象)，借助NSClassFromString的帮助"></a>初始化Model对象(例子中使用的是<code>ProjectTopics</code>对象)，借助<code>NSClassFromString</code>的帮助</h4><pre><code>        id newObject = [[NSClassFromString(object) alloc] init];
</code></pre><h4 id="获取ProjectTopics对象的全部属性"><a href="#获取ProjectTopics对象的全部属性" class="headerlink" title="获取ProjectTopics对象的全部属性"></a>获取<code>ProjectTopics</code>对象的全部属性</h4><pre><code>        [newObject propertyDictionary];
</code></pre><p>具体看看如何实现</p>
<pre><code>        - (NSDictionary *)propertyDictionary {
              NSMutableDictionary *dict = [NSMutableDictionary dictionary];

              unsigned count;
              objc_property_t *properties = class_copyPropertyList([self class], &amp;count);

              for (int i = 0; i &lt; count; i++) {
                  NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];
                  [dict setObject:key forKey:key];
              }

              free(properties);

              // Add all superclass properties as well, until it hits NSObject
              NSString *superClassName = [[self superclass] nameOfClass];
              if (![superClassName isEqualToString:@&quot;NSObject&quot;]) {
                  for (NSString *property in [[[self superclass] propertyDictionary] allKeys]) {
                      [dict setObject:property forKey:property];
                  }
              }

              return dict;
          }
</code></pre><p><strong> 关键函数 </strong></p>
<ul>
<li><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code>:<br>  该函数将ProjectTopics类的属性拷贝到一个数组中，并返回该数组。数组中的每个元素是<code>objc_property_t</code>类型</li>
<li><code>const char *property_getName(objc_property_t property)</code><br>  该函数传入一个objc_property_t参数，并返回该属性的属性名</li>
</ul>
<p><strong> 关键步骤 </strong></p>
<ul>
<li>获取ProjectTopics类的所有属性名，将所有属性名添加入一个NSDictionary<ul>
<li>如果父类不是NSObject，也将父类的所有属性名加入同一个NSDictionary</li>
</ul>
</li>
</ul>
<p>最终得到的NSDictionary如下👇<br><img src="/lionheart/1605/property.png" alt="property"></p>
<h4 id="遍历传入的NSDictionary：dict-为ProjectTopics类的各个属性赋值"><a href="#遍历传入的NSDictionary：dict-为ProjectTopics类的各个属性赋值" class="headerlink" title="遍历传入的NSDictionary：dict,为ProjectTopics类的各个属性赋值"></a>遍历传入的NSDictionary：<code>dict</code>,为ProjectTopics类的各个属性赋值</h4><p>先再来看看这个dict👇<br><img src="/lionheart/1605/json.png" alt="JSON"><br>因为传入<code>dict</code>中的每个key其实就是ProjectTopics类中的每个属性名，所以就可以直接赋值了。当然其中也分3中情况，</p>
<ol>
<li><p>最简单的情况，这个key对应的值既不是NSArray，也不是NSDictionary(比如id, owner_id等)。对于这种情况，直接赋值，代码如下👇</p>
<pre><code>       objc_property_t property = class_getProperty([newObject class], [propertyName UTF8String]);
       if (!property) {
           continue;
       }
       NSString *classType = [newObject typeFromProperty:property];

       // check if NSDate or not
       if ([classType isEqualToString:@&quot;T@\&quot;NSDate\&quot;&quot;]) {
           //                1970年的long型数字
           NSObject *obj = [dict objectForKey:key];
           if ([obj isKindOfClass:[NSNumber class]]) {
               NSNumber *timeSince1970 = (NSNumber *)obj;
               NSTimeInterval timeSince1970TimeInterval = timeSince1970.doubleValue/1000;
               NSDate *date = [NSDate dateWithTimeIntervalSince1970:timeSince1970TimeInterval];
               [newObject setValue:date forKey:propertyName];
           }else{
               //                            日期字符串
               NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
               [formatter setDateFormat:OMDateFormat];
               [formatter setTimeZone:[NSTimeZone timeZoneWithAbbreviation:OMTimeZone]];
               NSString *dateString = [[dict objectForKey:key] stringByReplacingOccurrencesOfString:@&quot;T&quot; withString:@&quot; &quot;];
               [newObject setValue:[formatter dateFromString:dateString] forKey:propertyName];
           }
       }
       else {
           if ([dict objectForKey:key] != [NSNull null]) {
               [newObject setValue:[dict objectForKey:key] forKey:propertyName];
           }
           else {
               [newObject setValue:nil forKey:propertyName];
           }
       }
</code></pre><p>上述代码说了很多，但是主要是区分该属性是否是一个NSDate,如果不是的话就直接通过下面代码赋值就完成了</p>
<pre><code>       [newObject setValue:[dict objectForKey:key] forKey:propertyName]; // KVO
</code></pre><p>至于如何判断属性是否是NSDate，有以下几个关键函数</p>
<ul>
<li><code>objc_property_t class_getProperty(Class cls, const char *name)</code><br>该函数传入类和字符串，返回一个<code>objc_property_t</code>类型的属性</li>
<li><code>- (NSString *)typeFromProperty:(objc_property_t)property;</code><br>该函数的实现如下<pre><code>       return [[NSString stringWithUTF8String:property_getAttributes(property)] componentsSeparatedByString:@&quot;,&quot;][0];
</code></pre>它返回的NSString是长这样的：T@”NSDate”,&amp;,N,V_last_activity_at ／ T@”NSString”,&amp;,N,V_company；所以可以根据是否有NSDate进行判断</li>
</ul>
</li>
<li>如果这个key对应的是一个NSDictionary对象，那么说明这个属性也是另外一个Model对象，对该属性递归调用上面方法即可实现赋值。代码如下👇<pre><code>       NSString *propertyType = [newObject classOfPropertyNamed:propertyName];
       id nestedObj = [NSObject objectOfClass:propertyType fromJSON:[dict objectForKey:key]];
       [newObject setValue:nestedObj forKey:propertyName];
</code></pre>其中的propertyType其实就是通过上面讲道的<code>property_getAttributes</code>函数，并解析<code>T@&quot;User&quot;,&amp;,N,V_owner ／ T@&quot;Project&quot;,&amp;,N,V_project</code>这种类似的字符串，来得到这个Model对象的类型(比如 User， Project类型等)</li>
<li>如果这个key对应的是一个NSArray对象，那么就得通过<code>ProjectTopics.m</code>中的<code>propertyArrayMap</code>得知这个NSArray里面装的到底是什么对象。<br>先来看看ProjectTopics.m里面对propertyArrayMap的设置：<pre><code>       _propertyArrayMap = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;ProjectTopic&quot;, @&quot;list&quot;, nil];
</code></pre>从上面可以看出，<code>ProjectTopics</code>的<code>list</code>属性是一个NSArray对象，这个NSArray里面装的是一个一个的<code>ProjectTopic</code>对象。这就好办了，对这些ProjectTopic对象按照上述的方法对他们进行赋值。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总算写完了。。。感觉写的很乱。。。<br>总之就是对关于对象的几个属性进行操作：</p>
<ol>
<li><code>[[NSClassFromString(object) alloc] init];</code><br>这个函数可以根据字符串获得对象，比如根据”ProjectTopics”来初始化一个ProjectTopics对象</li>
<li><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code><br>这个函数可以获得对象的所有属性，并返回一个都是由<code>objc_property_t</code>组成的数组</li>
<li><code>const char *property_getName(objc_property_t property)</code><br>这个函数可以获得属性的属性名，意思就是说objc_property_t是属性，但就是不能以字符串显示出来，这个函数就可以将属性显示出来(比如：”list”啊,”page”啊,”totalRow”啊 等等)</li>
<li><code>objc_property_t class_getProperty(Class cls, const char *name)</code><br>这个函数和3相反，根据属性名获得属性 (感觉objc_property_t就是一个难以表述的东西)</li>
<li><code>const char *property_getAttributes(objc_property_t property)</code><br>这个函数根据属性返回属性的类型，比如说<code>owner</code>属性是一个<code>User</code>对象，那么该函数就返回<code>@&quot;User&quot;,&amp;,N,V_owner</code></li>
<li><code>[newObject setValue:[dict objectForKey:key] forKey:propertyName];</code><br>给属性赋值， 比如propertyName是owner, 那么就给他赋一个User对象。简单粗暴</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Method Swizzling]]></title>
      <url>/2016/03/26/iOS-method-swizzling/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有个奇怪的需求：每个UIViewController在viewDidAppear:和viewWillAppear:方法中都需要执行一些操作。这里介绍一种iOS Method Swizzling方法:让viewDidAppear:和customViewDidAppear:方法调换实现方式；让viewWillAppear:和customViewWillAppear:方法调换实现方式。</p>
<a id="more"></a>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li>新建UIViewController的一个category - Swizzle<ol>
<li>在Swizzle中实现customViewDidAppear:方法和customViewWillAppear:方法。</li>
<li>并且重写<code>load</code>方法，在load方法中将指向viewDidAppear:实现的指针和指向customViewDidAppear:实现的指针对调；将指向viewWillAppear:实现的指针和指向customViewWillAppear:实现的指针对调</li>
</ol>
</li>
<li>函数指针对调实现</li>
<li>在AppDelegate.m中import这个Swizzle category。那么在所有的UIViewController执行load方法时都会执行Swizzle中重写的load方法，以实现方法的对调；所以之后正常调用viewDidAppear:或是viewWillAppear:时，其实是调用的customViewDidAppear:和customViewWillAppear:方法</li>
</ol>
<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><ol>
<li><p>Swizzle category</p>
<pre><code>     @implementation UIViewController (Swizzle)

     + (void)load {
         swizzleAllViewController();
     }

     - (void)customViewDidAppear:(BOOL)animated {
         // do something here
         [self customViewDidAppear:animated]; // 其实是调用的viewDidAppear:
     }

     - (void)customviewWillAppear:(BOOL)animated {
         // do something here
         [self customviewWillAppear:animated]; // 其实是调用的viewWillAppear:
     }

     @end

     // 函数指针对调
     void swizzleAllViewController() {
         Swizzle([UIViewController class], @selector(viewDidAppear:), @selector(customViewDidAppear:));
         //Swizzle([UIViewController class], @selector(viewWillDisappear:), @selector(customViewWillDisappear:));
         Swizzle([UIViewController class], @selector(viewWillAppear:), @selector(customviewWillAppear:));
     }
</code></pre></li>
<li><p>函数指针对调的实现</p>
<pre><code>     void Swizzle(Class c, SEL origSEL, SEL newSEL) {
         Method origMethod = class_getInstanceMethod(c, origSEL);
         Method newMethod = nil;
         if (!origMethod) {
             origMethod = class_getClassMethod(c, origSEL);
             if (!origMethod) {
                 return;
             }
             newMethod = class_getClassMethod(c, newSEL);
             if (!newMethod) {
                 return;
             }
         } else {
             newMethod = class_getInstanceMethod(c, newSEL);
             if (!newMethod) {
                 return;
             }
         }

         if (class_addMethod(c, origSEL, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))) {
             NSLog(@&quot;vanney code log... errorhappened&quot;);
             class_replaceMethod(c, newSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
         } else {
             method_exchangeImplementations(origMethod, newMethod);
         }
     }
</code></pre></li>
</ol>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h2><p>以上代码都参考自<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）: Method Swizzling</a></li>
<li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" target="_blank" rel="external">NSObject +load and +initialize - What do they do?</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS从图库或相机获得图片]]></title>
      <url>/2016/03/24/iOS-camera-picture-album/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一款App很有可能需要访问系统的图库（照片）或者通过相机来获取图片，比如更换用户头像等等。效果如图👇</p>
<p><img src="/lionheart/1603/camerademo.gif" alt="camera demo"></p>
<p>下面来看看如何实现</p>
<a id="more"></a>
<h2 id="查看访问权限"><a href="#查看访问权限" class="headerlink" title="查看访问权限"></a>查看访问权限</h2><p>App在第一次访问系统照片或者相机时，通常需要询问是否有权限去access相片图库或者使用相机。可以通过下面代码得知目前该app的权限👇</p>
<pre><code>        @import AVFoundation;
        @import Photos;

        // 检查使用相片的权限， YES为可以访问，NO为不能使用
        + (BOOL)checkPhotoLibraryAuthorizationStatus {
            if ([PHPhotoLibrary responseToSelector:@selector(authorizationStatus)]) {
                PHAuthorizationStatus status = [PHPhotoLibrary authorizationStatus]; // 获取当前app对相片的权限
                if (status == PHAuthorizationStatusDenied || status == PHAuthorizationStatusRestricted) { // 若当前权限为不允许使用
                    [self showSettingAlertStr:@&quot;请在iPhone的“设置-&gt;隐私-&gt;照片”中打开本应用的访问权限&quot;]; // 提示用户去**设置**中更改权限
                    return NO;
                }
            }

            return YES;
        }

        // 检查使用相机的权限， YES为可以使用， NO为不能访问
        + (BOOL)checkCameraAuthorizationStatus {
            if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) { // 判断该设备是否支持拍照
                alert(@&quot;该设备不能拍照&quot;)；
                return NO;
            }

            if ([AVCaptureDevice responseToSelector:@selector(authorizationStatusForMediaType:)]) {
                AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; // 获取当前app对相机的权限
                if (status == AVAuthorizationStatusDenied || status == AVAuthorizationStatusRestricted) { // 若当前权限为不允许使用
                    [self showSettingAlertStr:@&quot;请在iPhone的“设置-&gt;隐私-&gt;相机”中打开本应用的访问权限&quot;]; // 提示用户去**设置**中更改权限
                    return NO;
                }
            }

            return YES;
        }

        // 提示用户去设置中更改权限
        + (void)showSettingAlertStr:(NSString *)tipStr {
            if (floor(NSFoundationVersionNumber) &gt; NSFoundationVersionNumber_iOS_7_1) { // iOS7.1之后的可以直接进入设置
                // 新建提示弹框
                UIAlertView *alertView = [UIAlertView bk_alertViewWithTitle:@&quot;提示&quot; message:tipStr];
                [alertView bk_setCancelButtonWithTitle:@&quot;取消&quot; handler:nil];
                [alertView bk_addButtonWithTitle:@&quot;&quot; handler:nil];
                [alertView bk_setDidDismissBlock:^(UIAlertView *alertView, NSInteger buttonIndex) {
                    if (buttonIndex == 1) {
                        // 跳转到设置界面进行设置
                        UIApplication *app = [UIApplication sharedApplication];
                        NSURL *settingsURL = [NSURL urlWithString:UIApplicationOpenSettingsURLString];
                        if ([app canOpenURL:settingsURL]) {
                            [app openURL:settingsURL];
                        }
                    }
                }];
            }
        }
</code></pre><p>效果如下👇<br><img src="/lionheart/1603/authorizationdemo.gif" alt="autorization demo"></p>
<h2 id="UIImagePickerController"><a href="#UIImagePickerController" class="headerlink" title="UIImagePickerController"></a>UIImagePickerController</h2><p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImagePickerController_Class/" target="_blank" rel="external">UIImagePickerController</a>是系统提供的用来拍照或者使用系统相片的用户界面。</p>
<p>使用UIImagePickerController需注意：</p>
<ol>
<li>sourceType属性: 该属性说明UIImagePickerController会如何显示界面。如果sourceType为UIImagePickerControllerSourceTypeCamera，那么系统会呈现一个拍照的界面；如果sourceType为UIImagePickerControllerSourceTypeSavedPhotosAlbum，那么系统会呈现一个选取系统照片的界面</li>
<li>检查app是否有权限使用相机或者系统相片</li>
</ol>
<p>下面来看看使用示例👇</p>
<pre><code>        + (void)showImagePickerController {
            UIImagePickerController *pickerController = [UIImagePickerController alloc] init]; // 初始化
            pickerController.delegate = self;
            pickerController.allowsEditing = YES; //允许用户编辑拍摄的图片或者选取的相册的图片
            if (camera) { // 选择相机
                if (![Helper checkCameraAuthorizationStatus]) { // 根据上文的函数，判断是否有使用相机的权限
                    return;
                }
                pickerController.sourceType = UIImagePickerControllerSourceTypeCamera; // 指定sourceType为Camera，pickerController将会提供一个拍摄的界面
            } else { // 选择系统图库
                if (![Helper checkPhotoLibraryAuthorizationStatus]) { // 根据上文函数，判断是否能够access系统图库
                    return;
                }
                pickerController.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; // 指定sourceType为SavedPhotosAlbum，pickerController将会提供一个选取系统相片的界面
            }
            [self presentViewController:pickerController animated:YES completion:nil]; // 展示UIImagePickerController
        }


        // UIImagePickerControllerDelegate

        // 进入UIImagePickerController后如果选择`cancel` 就不做什么处理
        - (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker {
            [picker dismissViewControllerAnimated:YES completion:nil];
        }

        // 进入UIImagePickerController后如果选择`done` 做一些处理
        - (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *, id&gt;*)info {
            // 推出UIImagePickerController并处理选取的图片
            [picker dismissViewControllerAnimated:YES completion:^{
                UIImage *editedImage, *originalImage;
                editedImage = [info objectForKey:UIImagePickerControllerEditedImage]; // 获取编辑后的图片

                // do something here: like take this edited image as user avatar or something else

                // 如果是相机拍摄的图片，那么将原图保存到系统图库
                if (picker.sourceType == UIImagePickerControllerSourceTypeCamera) {
                    originalImage = [info objectForKey:UIImagePickerControllerOriginalImage]; // 获取编辑之前的图片
                    UIImageWriteToSavedPhotosAlbum(originalImage, self, nil, NULL); //将图片保存
                }
            }];
        }
</code></pre><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h2><p>本文代码都参考自<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS全局设置]]></title>
      <url>/2016/03/24/iOS-global-setting/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个iOS项目，有很多东西是全局通用的，比如全局常量等等。在整个项目的某个地方，对其进行全局设置，会极大的方便程序的编写，而且简化程序的结构。</p>
<h2 id="不同类型的全局设置"><a href="#不同类型的全局设置" class="headerlink" title="不同类型的全局设置"></a>不同类型的全局设置</h2><a id="more"></a>
<ol>
<li>用户登录，用户数据全局存储</li>
</ol>
<h2 id="用户登录，用户数据全局存储"><a href="#用户登录，用户数据全局存储" class="headerlink" title="用户登录，用户数据全局存储"></a>用户登录，用户数据全局存储</h2><p>用户登录时，对用户数据进行存储，在全局都可以获得当前登录用户的数据。来看看如何实现</p>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a><code>NSUserDefaults</code></h3><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/" target="_blank" rel="external">NSUserDefaults</a>用来存储轻量级的本地数据灰常合适，就比如说当前的登录用户数据（用户名，密码等等）。NSUserDefaults存储时支持的数据类型有 NSNumber, NSString, NSDate, NSArray, NSDictionary, BOOL。它有点类似键值对。</p>
<h3 id="plist"><a href="#plist" class="headerlink" title="plist"></a><code>plist</code></h3><p>plist是<code>Property List</code>的缩写，它是一个xml格式的文件，用来存储串行化后的对象。因此plist文件可以用来存储历史登录用户的数据。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="用户登录时"><a href="#用户登录时" class="headerlink" title="用户登录时"></a>用户登录时</h4><pre><code>        + (void)doLogin:(NSDictionary *)loginData {
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; // 获取默认的NSUserDefaults
            [defaults setObject:[NSNumber numberWithBool:YES] forKey:@&quot;loginStatus&quot;]; // 设置登录状态为已登录
            [defaults setObject:loginData forKey:@&quot;loginData&quot;]; // 存储当前登录用户数据。注：loginData为NSDictionary，里面可以存放username、password、email等信息
            [defaults synchronize]; // 同步数据
            [self saveLoginData:loginData]; // 使用plist存储历史登录用户数据，在后文会有介绍
        }
</code></pre><p>这里使用NSUserDefaults存储登录时的数据：</p>
<ol>
<li>使用loginStatus键来存储登录状态：YES表示已登录，NO表示未登陆</li>
<li>使用loginData键来存储登录用户的数据：该键对应的值是一个NSDictionary，该字典里面可以包含username、password、email等与当前用户相关的数据</li>
<li>[defaults synchronize]; 该方法表示将NSUserDefaults数据同步到磁盘，此举避免了程序意外退出而导致数据未存储的情况</li>
<li>saveLoginData方法将这个用户数据写入plist文件，达到存储历史数据的目的，后面会介绍</li>
</ol>
<h4 id="用户退出时"><a href="#用户退出时" class="headerlink" title="用户退出时"></a>用户退出时</h4><pre><code>+ (void)doLogout {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; // 获取默认的NSUserDefaults
    [defaults setObject:[NSNumber numberWithBool:NO] forKey:@&quot;loginStatus&quot;]; // 设置登录状态为未登陆
    [defaults synchronize]; // 同步数据
    // do something else, like clear cookies
}
</code></pre><p>这里将用户登录状态设置为未登陆，并同步数据</p>
<h4 id="判断是否登录"><a href="#判断是否登录" class="headerlink" title="判断是否登录"></a>判断是否登录</h4><pre><code>+ (BOOL)isLogin {
    NSNumber *loginStatus = [NSUserDefaults standardUserDefaults] objectForKey:@&quot;loginStatus&quot;]; // 获取用户登录状态
    if (loginStatus.boolValue) { // 判断用户是否登录，并返回
        return YES;
    } else {
        return NO;
    }
}
</code></pre><p>获取NSUserDefaults中loginStatus键的值来获取用户的登录状态</p>
<h4 id="获取当前登录用户"><a href="#获取当前登录用户" class="headerlink" title="获取当前登录用户"></a>获取当前登录用户</h4><pre><code>+ (User *)curLoginUser {
    NSDictionary *loginData = [NSUserDefaults standardUserDefaults] objectForKey:@&quot;loginData&quot;]; // 获取当前用户数据
    User *curLoginUser = loginData ? [NSObject objectOfClass:@&quot;User&quot; fromJSON:loginData]; // 转化为User对象
    return curLoginUser;
}
</code></pre><p>获取NSUserDefaults中loginData的NSDictionary，并转化为User对象返回。注：User对象为一个model。</p>
<h4 id="存储历史数据"><a href="#存储历史数据" class="headerlink" title="存储历史数据"></a>存储历史数据</h4><pre><code>+ (NSString *)loginDataListPath {
    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; // 返回app存放数据的Documents文件夹路径
    NSString *listPath = [documentPath stringByAppendingPathComponent:@&quot;login_list.plist&quot;]; // 返回存放历史数据的plist文件的路径，他在Documents文件夹里面
    return listPath;
}

+ (NSMutableDictionary *)readLoginDataList {
    NSMutableDictionary *loginDataList = [NSMutableDictionary dictionaryWithContentsOfFile:[self loginDataListPath]]; // 读取plist文件内容，并将它存放在NSMutableDictionary中返回
    return loginDataList;
}

+ (BOOL)saveLoginData:(NSDictionary *)loginData {
    BOOL save = NO;
    if (loginData) {
        NSMutableDictionary *loginDataList = [self readLoginDataList]; // 获取已经存储的用户数据
        User *curUser = [NSObject objectOfClass:@&quot;User&quot; fromJSON:loginData]; // 转化为User对象
        if (curUser.username.length &gt; 0) {
            [loginDataList setObject:loginData forKey:curUser.username]; // 更新历史数据中该用户的数据
            save = YES;
        }
        if (save) {
          save = [loginDataList writeToFile:[self loginDataListPath] atomically:YES]; // 将数据写入plist文件
        }
    }
}
</code></pre><p>以上代码中包括三个函数：</p>
<ol>
<li>loginDataListPath: 该函数返回plist文件的路径</li>
<li>readLoginDataList: 该函数读取plist文件中的数据，以NSDictionary的方式返回</li>
<li>saveLoginData: 更新readLoginDataList中返回的历史数据，加入当前登录用户的数据；并再次将已经更新的历史用户数据写入plist文件</li>
</ol>
<h4 id="p-s"><a href="#p-s" class="headerlink" title="p.s"></a>p.s</h4><p>以上代码均参照<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/" target="_blank" rel="external">NSUserDefaults Reference</a></li>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2016-week4]]></title>
      <url>/2016/03/19/2016-week4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末去见老同学了，week3就不写了=。＝ 都是借口啊，来看看这周碰上一些什么问题。</p>
<h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><a id="more"></a>
<ol>
<li><code>edgesForExtendedLayout</code></li>
<li>获取版本号</li>
<li>文本自动调整大小</li>
<li>AppStore, Settings页面跳转</li>
</ol>
<h2 id="edgesForExtendedLayout"><a href="#edgesForExtendedLayout" class="headerlink" title="edgesForExtendedLayout"></a><code>edgesForExtendedLayout</code></h2><p>经常会碰到的一个问题：UITabBarController包含多个UINavgationController，每个UINavgationController又包含着自己的ViewController。这个时候ViewController的frame占据了整个屏幕（既包括了NavBar的地方，又包括了TabBar的地方），很烦；如何让这样的ViewController的View只占据NavBar和TabBar之间的区域呢？<br>这时就需要<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instp/UIViewController/edgesForExtendedLayout" target="_blank" rel="external">edgesForExtendedLayout</a>属性了。<br><code>edgesForExtendedLayout</code>是UIViewController的一个属性，它只在ViewController嵌在其他容器内时才起作用，比如UINavgationController。默认的值是UIRectEdgeAll，将它设置为UIRectEdgeNone时可以解决上述问题。如下👇</p>
<pre><code>        // 在ViewController的viewDidLoad里面设置
        self.edgesForExtendedLayout = UIRectEdgeNone;
</code></pre><p>效果如下👇<br><img src="/lionheart/1603/edges.png" alt="edgesForExtendedLayout"></p>
<h2 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h2><pre><code>        NSString *version = [NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleVersion&quot;];
</code></pre><h2 id="文本自动调整大小"><a href="#文本自动调整大小" class="headerlink" title="文本自动调整大小"></a>文本自动调整大小</h2><p>UILabel一下2个属性，可以让文本字体大小自动调整以适应UILabel的frame:</p>
<ol>
<li><code>adjustsFontSizeToFitWidth</code>: 该属性默认为NO。当设置它为YES时，当文本的长度超过UILabel时，会自动缩小文本字体，以适应UILabel的frame。该属性要配合minimumScaleFactor使用。</li>
<li><code>minimumScaleFactor</code>: 该属性表示UILabel的字体最小的缩放程度。它的默认值为0，但并不是说字体大小为0，而是使用当前指定的字体大小。</li>
</ol>
<h2 id="AppStore-Settings页面跳转"><a href="#AppStore-Settings页面跳转" class="headerlink" title="AppStore, Settings页面跳转"></a>AppStore, Settings页面跳转</h2><ol>
<li>跳转到AppStore界面<br>经常需要对app进行评分，这时就需要跳转到AppStore，跳转方法如下👇<pre><code>     NSString *appStoreUrlStr = @&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple    +Software&amp;id=923676989&quot;; // 获取Coding的AppStore的url, 注意这里要将https:换成itms-apps: 貌似是为了避免重定向
     [UIApplication sharedApplication] openURL:[NSURL urlWithString:appStoreUrlStr]; // 跳转到AppStore
</code></pre></li>
<li>跳转到设置页面<pre><code>     [UIApplication sharedApplication] openURL:[NSURL urlWithString:UIApplicationOpenSettingsURLString];
</code></pre></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/433907/how-to-link-to-apps-on-the-app-store" target="_blank" rel="external">How to link to apps on the app store</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac Colorful Terminal]]></title>
      <url>/2016/03/19/mac-colorful-terminal/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天装完Mysql之后发现之前终端的颜色不见了，本来那颜色看的也挺操蛋的。Google之后发现了<a href="https://github.com/altercation/solarized" target="_blank" rel="external">solarized</a>。来看看效果👇</p>
<p><img src="/lionheart/1603/maccolorfulterminaldemo.png" alt="mac colorful terminal"></p>
<a id="more"></a>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol>
<li><code>Terminal</code>设置</li>
<li><code>Vim</code>设置</li>
<li><code>ls</code>设置</li>
</ol>
<h2 id="Terminal设置"><a href="#Terminal设置" class="headerlink" title="Terminal设置"></a>Terminal设置</h2><ol>
<li><p>github下载solarized</p>
<pre><code>     $ git clone git://github.com/altercation/solarized.git
</code></pre></li>
<li><p>导入terminal配置文件</p>
<p>打开<code>Terminal</code>的偏好设置，导入下面的配置文件</p>
<pre><code>     solarized/osx-terminal.app-colors-solarized/Solarized Dark ansi.terminal
</code></pre></li>
</ol>
<h2 id="Vim设置"><a href="#Vim设置" class="headerlink" title="Vim设置"></a><code>Vim</code>设置</h2><p>Vim保持和Terminal相同的配色，设置如下👇</p>
<pre><code>        $ cd solarized
        $ cd vim-colors-solarized/colors
        $ mkdir -p ~/.vim/colors
        $ cp solarized.vim ~/.vim/colors/

        $ vim ~/.vimrc
        syntax enable
        set background=dark
        colorscheme solarized
</code></pre><h2 id="ls设置"><a href="#ls设置" class="headerlink" title="ls设置"></a><code>ls</code>设置</h2><ol>
<li>安装<code>Coreutils</code><pre><code>     $ brew install coreutils
</code></pre></li>
<li>生成颜色配置文件<pre><code>     $ gdircolors --print-database &gt; ~/.dir_colors
</code></pre></li>
<li>编辑配置文件(.bash_profile)<br>在.bash_profile文件中添加下面几行👇<pre><code>     if brew list | grep coreutils &gt; /dev/null ; then
         PATH=&quot;$(brew --prefix coreutils)/libexec/gnubin:$PATH&quot;
         alias ls=&#39;ls -F --show-control-chars --color=auto&#39;
         eval `gdircolors -b $HOME/.dir_colors`
     fi
</code></pre></li>
</ol>
<p><strong>p.s</strong> 照做就好了=。=</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/altercation/solarized" target="_blank" rel="external">altercation/solarized</a></li>
<li><a href="http://www.vpsee.com/2013/09/use-the-solarized-color-theme-on-mac-os-x-terminal/" target="_blank" rel="external">在 Mac OS X 终端里使用 Solarized 配色方案</a></li>
<li><a href="http://chaishiwei.com/blog/247.html" target="_blank" rel="external">定制以及彩色化自己的 Mac OS X 终端</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ActionSheetPicker源码分析]]></title>
      <url>/2016/03/15/ActionSheetPicker-sourcecode-analyse/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="external">ActionSheetPicker</a>可以快速生成UIPickerView+UIActionSheet的效果。效果如下👇</p>
<p><img src="/lionheart/1603/actionsheetdemo.gif" alt="action sheet demo"></p>
<a id="more"></a>
<h2 id="ActionSheetPicker代码结构"><a href="#ActionSheetPicker代码结构" class="headerlink" title="ActionSheetPicker代码结构"></a>ActionSheetPicker代码结构</h2><p>从<a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="external">github</a>上将项目拷贝下来后，可以看到ActionSheetPicker的文件目录如下👇</p>
<p><img src="/lionheart/1603/actionsheetdocument.png" alt="Action Sheet Picker Document"></p>
<p>ActionSheetPicker可以实现4种类型的picker:</p>
<ol>
<li>ActionSheetStringPicker</li>
<li>ActionSheetDistancePicker</li>
<li>ActionSheetDatePicker</li>
<li>ActionSheetCustomPicker</li>
</ol>
<p>这4种picker都是继承自AbstractActionSheetPicker。下面以ActionSheetStringPicker为例，来分析ActionSheetPicker的源码。</p>
<h2 id="ActionSheetStringPicker使用示例"><a href="#ActionSheetStringPicker使用示例" class="headerlink" title="ActionSheetStringPicker使用示例"></a>ActionSheetStringPicker使用示例</h2><p>ActionSheetStringPicker的使用很简单，示例代码如下👇</p>
<pre><code>                [ActionSheetStringPicker showPickerWithTitle:nil rows:@[@&quot;男&quot;, @&quot;女&quot;, @&quot;未知&quot;] initialSelection:1 doneBlock:^(ActionSheetStringPicker *picker, NSInteger selectedIndex, id selectedValue) {

                } cancelBlock:nil origin:self.view];
</code></pre><p>效果如下👇</p>
<p><img src="/lionheart/1603/stringpickerdemo.png" alt="stringPicker demo"></p>
<h2 id="ActionSheetStringPicker实现过程"><a href="#ActionSheetStringPicker实现过程" class="headerlink" title="ActionSheetStringPicker实现过程"></a>ActionSheetStringPicker实现过程</h2><ol>
<li>新建一个CGSize为(Screen_Width, 260)的UIView，这个view也是picker最外层的view，我们称它为<code>masterView</code>。</li>
<li>在masterView的最上方的44points区域内创建一个UIToolBar，我们称它为<code>toolBar</code>。在这个toolBar里面添加<code>cancelButton</code>和<code>doneButton</code>，以及这个picker的<code>title</code>。（这里的title为空）</li>
<li>执行<code>configuredPickerView</code>方法，这个方法必须在<code>ActionSheetStringPicker.m</code>中重写。这个方法里面创建了一个UIPickerView，我们称它为<code>pickerView</code>。这个pickerView占据了masterView下面的216points的空间。（<strong>注</strong> : UIPickerViewDeledate 和 UIPickerViewDataSource 也在 ActionSheetStringPicker.m 里面实现。</li>
<li>实现ActionSheet的效果：在（SWActionSheet类中实现）。该类创建一个UIWindow，并将上面创建的masterView添加到该UIWindow的rootController的view的subview中，并显示该UIWindow。</li>
</ol>
<h2 id="ActionSheetStringPicker结构示意图"><a href="#ActionSheetStringPicker结构示意图" class="headerlink" title="ActionSheetStringPicker结构示意图"></a>ActionSheetStringPicker结构示意图</h2><p><img src="/lionheart/1603/ActionSheetPicker.png" alt="ActionSheetPicker"></p>
<p>根据结构示意图可以知道：</p>
<ol>
<li>ActionSheetStringPicker新建了一个<code>UIWindow</code>,并且这个UIWindow遮挡住了默认的UIWindow(默认是在AppDelegate.m中声明)</li>
<li>UIWindow的rootController是一个<code>SWActionSheetVC</code>实例,这个SWActionSheetVC添加了一个<code>SWActionSheet</code>视图</li>
<li>SWActionSheet的subview是<code>masterView</code></li>
<li>masterView分成2个部分:一个是上部的<code>UIToolBar</code>,另一个是下部的<code>UIPickerView</code></li>
</ol>
<h2 id="ActionSheetStringPicker的重要几个文件-类"><a href="#ActionSheetStringPicker的重要几个文件-类" class="headerlink" title="ActionSheetStringPicker的重要几个文件(类)"></a>ActionSheetStringPicker的重要几个文件(类)</h2><ol>
<li><p>SWActionSheet.m</p>
<p>该文件实现了2个类,<code>SWActionSheet</code>和<code>SWActionSheetVC</code>。这两个类模仿了UIActionSheet的实现。他们创建了新的UIWindow,并将在AbstractActionSheetPicker.m中创建的masterView添加到视图中。</p>
</li>
<li><p>AbstractActionSheetPicker.m</p>
<p>该文件实现了<code>AbstractActionSheetPicker</code>类,这个类是创建4种不同类型的Picker的基类。在该类中创建了一个<code>masterView</code>,并创建了masterView上部的<code>UIToolBar</code>。</p>
</li>
<li><p>ActionSheetStringPicker.m</p>
<p>该文件实现了<code>ActionSheetStringPicker</code>类－4种这个库提供的picker之一。这个类最主要的功能就是实现了<code>UIPickerView</code>,以及UIPickerView的一些所需的delegate。这里创建的<code>UIPickerView</code>会被添加到<code>masterView</code>的subview中。还有就是用户定义的doneBlock以及cancelBlock都会存储在这个类中。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/skywinder/ActionSheetPicker-3.0" target="_blank" rel="external">skywinder/ActionSheetPicker-3.0</a></li>
</ul>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h2><p>这个库是不能直接简单的实现下面的效果的👇</p>
<p><img src="/lionheart/1603/custompickerdemo.gif" alt="custom picker demo"></p>
<p>所以呢？<br>我写了一个<code>ActionSheetStringDictPicker</code>类,用法如下👇</p>
<pre><code>                [ActionSheetStringDictPicker showPickerWithTitle:nil firstRow:firstArray secondDict:secondDict initialIndexs:@[@1, @1] doneBlock:^(ActionSheetStringDictPicker *picker, NSArray *selectedIndexs, id selectedValues) {
                        // do something here
                } cancelBlock:nil origin:self.view];
</code></pre><p>参数设置:</p>
<ol>
<li><code>firstRow</code>: picker中第一列的内容,是一个<code>NSArray</code></li>
<li><code>secondDict</code>: picker中第二列的内容,是一个<code>NSDictionary</code>。这个NSDictionary的键是第一列firstRow的值;每个键对应的值是一个NSArray,这个数组是第二列的内容。当第一列的值变化时，第二列的内容会实时变化。</li>
</ol>
<p>ActionSheetStringDictPicker的代码<a href="https://github.com/vanney9/blogDemo/tree/master/actionsheetstringdictpicker" target="_blank" rel="external">👉在这里👈</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2016 Week 2]]></title>
      <url>/2016/03/05/2016-week2/</url>
      <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>第二星期开始，先和浩哥去看了美人鱼，就开始每天继续Coding-iOS的学习了。个人感觉这个<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding-iOS</a>项目代码写的真好，开源之后简直就是iOS菜鸡开发者的福音。自己写起来之后，才发现coding速度真的是慢＝。＝</p>
<h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><a id="more"></a>
<ol>
<li><code>UITextField</code>有关</li>
<li>自定义<code>UITableViewCell</code>流程</li>
<li><code>NSUserDefaults</code>基础</li>
<li><code>dispatch_once</code> 和 <code>static</code> 变量</li>
<li>创建<code>category</code></li>
<li><code>SHA1</code>加密</li>
<li>2种<code>enum</code>类型</li>
<li>Coding调用API流程</li>
<li><code>MBProgressHUD</code>基础</li>
<li><code>keyWindow</code></li>
<li>文件操作有关</li>
<li>账户输入提示框</li>
<li><code>enumerateObjectsUsingBlock:</code></li>
<li>2种<code>UITableViewCell</code>重用方式</li>
<li><code>NSRange</code>基础</li>
<li><code>CAShapeLayer</code>基础</li>
<li>显示/隐藏导航栏</li>
<li>ViewController之间切换卡顿</li>
<li><code>SDWebImageOptions</code></li>
<li>在<code>category</code>中新增<code>property</code></li>
<li>用户名存储整个流程</li>
<li><code>UIAlertController</code>基础</li>
</ol>
<h2 id="UITextField有关"><a href="#UITextField有关" class="headerlink" title="UITextField有关"></a><code>UITextField</code>有关</h2><p>介绍几个UITextField的属性和方法</p>
<ol>
<li><code>secureTextEntry</code>: 输入的文本不可见，多用于密码输入</li>
<li><code>clearButtonMode</code>: 清空文本输入的按钮的模式控制，属于<code>UITextFieldViewMode</code>。经常用到的有:<code>UITextFieldViewModeNever</code>, <code>UITextFieldViewModeWhileEditing</code></li>
<li>触发事件: 常用的有 开始编辑(<code>UIControlEventEditingDidBegin</code>), 文本变更(<code>UIControlEventEditingChanged</code>), 结束编辑(<code>UIControlEventEditingDidEnd</code>)</li>
<li><code>keyboardType</code>: 键盘类型，可选的有 <code>UIKeyboardTypeEmailAddress</code>,<br><code>UIKeyboardTypeDefault</code>等</li>
</ol>
<h2 id="自定义UITableViewCell流程"><a href="#自定义UITableViewCell流程" class="headerlink" title="自定义UITableViewCell流程"></a>自定义<code>UITableViewCell</code>流程</h2><p>参考这里</p>
<h2 id="NSUserDefaults基础"><a href="#NSUserDefaults基础" class="headerlink" title="NSUserDefaults基础"></a><code>NSUserDefaults</code>基础</h2><p>NSUserDefaults适合存储轻量级的本地数据，非常适合用来存储登录界面的数据（用户名，密码等等）。用法也很简单👇</p>
<ol>
<li>存储数据<pre><code>     NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];        // 获取 defaults
     [defaults setObject:loginData forKey:@&quot;loginData&quot;];                      // 存放登录数据
     [defaults synchronize];                                                  // 同步到磁盘，避免数据丢失
</code></pre></li>
<li>读取数据<pre><code>     NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];        // 获取 defaults
     NSDictionary *loginData = [defaults objectForKey:@&quot;loginData&quot;];          // 获取登录数据
</code></pre></li>
</ol>
<h2 id="dispatch-once-和-static-变量"><a href="#dispatch-once-和-static-变量" class="headerlink" title="dispatch_once 和 static 变量"></a><code>dispatch_once</code> 和 <code>static</code> 变量</h2><p><code>dispatch_once</code>函数只会被执行一次，经常用来创建单例实例，先来看看<code>dispatch_once</code>函数</p>
<pre><code>        void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);
</code></pre><p>第二个参数是只会被执行一次的代码块，第一个参数用来判断代码块是否被执行。该函数与<code>static</code>变量一同使用，看看具体代码👇</p>
<pre><code>        + (instancetype)sharedManager {
            static Coding_NetAPIManager *manager = nil;
            static dispatch_once_t pred;
            dispatch_once(&amp;pred, ^{
                manager = [[Coding_NetAPIManager alloc] init];
            });

            return manager;
        }
</code></pre><p>上面的<code>static</code>变量属于类成员，如果没有在.h文件中声明该static变量，那么他就是私有的类成员。类成员不能通过实例对象或是实例方法(-)去访问，只能通过类实例或是类方法(+)访问。</p>
<h2 id="创建category文件"><a href="#创建category文件" class="headerlink" title="创建category文件"></a>创建category文件</h2><p>这个很简单啦，xcode -&gt; New File -&gt; Objective-C File -&gt; 填写所需信息 -&gt; Finish<br>例如，创建一个<code>UIButton+Common</code>的category,应该👇<br><img src="/lionheart/1603/category.png" alt="category"></p>
<h2 id="SHA1加密"><a href="#SHA1加密" class="headerlink" title="SHA1加密"></a><code>SHA1</code>加密</h2><p>加密方法如下👇</p>
<pre><code>        - (NSString *)sha1Str {
            const char *cstr = [self cStringUsingEncoding:NSUTF8StringEncoding];
            NSData *data = [NSData dataWithBytes:cstr length:self.length];

            uint8_t digest[CC_SHA1_DIGEST_LENGTH];

            CC_SHA1(data.bytes, (CC_LONG)data.length, digest);

            NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];

            for (int i = 0; i &lt; CC_SHA1_DIGEST_LENGTH; i++) {
                [output appendFormat:@&quot;%02x&quot;, digest[i]];
            }

            return output;
        }
</code></pre><p><strong>注意</strong> 该方法写在了NSString的category里面</p>
<h2 id="2种enum类型"><a href="#2种enum类型" class="headerlink" title="2种enum类型"></a>2种<code>enum</code>类型</h2><p>指定enum有两种方式:<br>1.</p>
<pre><code>        typedef enum {
            Get = 0,
            Post,
            Put,
            Delete
        } NetworkMethod;
</code></pre><p>2.</p>
<pre><code>        typedef NS_ENUM(NSInteger, IllegalContentType) {
            IllegalContentTypeTweet = 0,
            IllegalContentTypeTopic,
            IllegalContentTypeProject,
            IllegalContentTypeWebsite
        };
</code></pre><h2 id="Coding调用API流程"><a href="#Coding调用API流程" class="headerlink" title="Coding调用API流程"></a>Coding调用API流程</h2><p>参考这里</p>
<h2 id="MBProgressHUD基础"><a href="#MBProgressHUD基础" class="headerlink" title="MBProgressHUD基础"></a><code>MBProgressHUD</code>基础</h2><p><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="external"><code>MBProgressHUD</code></a>是一个用来显示提示信息的第三方库，效果图如下👇<br><img src="/lionheart/1603/mbprogresshud.gif" alt="MBProgressHUD demo"></p>
<p>事例代码：</p>
<pre><code>        - (void)viewDidLoad {
            [super viewDidLoad];
            // Do any additional setup after loading the view, typically from a nib.
            MBProgressHUD  *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
            hud.mode = MBProgressHUDModeText;
            hud.detailsLabelFont = [UIFont boldSystemFontOfSize:15];
            hud.detailsLabelText = @&quot;tip from vanney9.com&quot;;
            hud.margin = 10;
            hud.removeFromSuperViewOnHide = YES;
            [hud hide:YES afterDelay:2.0f];
        }
</code></pre><h2 id="keyWindow"><a href="#keyWindow" class="headerlink" title="keyWindow"></a><code>keyWindow</code></h2><pre><code>        [UIApplication sharedApplication].keyWindow
</code></pre><p>APP主界面</p>
<h2 id="文件操作有关"><a href="#文件操作有关" class="headerlink" title="文件操作有关"></a>文件操作有关</h2><p>3个与文件操作相关的方法</p>
<ol>
<li>[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];<br>该方法返回该APP的Documents目录，在真机上显示的结果如下:<pre><code>     /var/mobile/Containers/Data/Application/7DB19AAA-B9E7-40D8-AAFA-C5BA2FA91CF0/Documents
</code></pre>在模拟机上显示的结果如下:<pre><code>     /Users/vanney/Library/Developer/CoreSimulator/Devices/FF2B6585-B815-4762-AC40-268D51742C85/data/Containers/Data/Application/82FEAB7E-9245-4BA8-88ED-A559034BA5F0/Documents
</code></pre></li>
<li>[NSMutableDictionary dictionaryWithContentsOfFile:@”file name”];<br>该方法读取<code>@&quot;file name&quot;</code>这个文件中的内容（注意：该文件应该存放键值对，一般XML文件），并返回由该键值对组成的NSMutableDictionary</li>
<li>[loginDataList writeToFile:@”file name” atomically:YES];<br>该方法中的loginDataList是一个NSMutableDictionary,这个方法将键值对写入<code>@&quot;file name&quot;</code>这个文件中</li>
</ol>
<h2 id="账户输入提示框"><a href="#账户输入提示框" class="headerlink" title="账户输入提示框"></a>账户输入提示框</h2><p>效果如下图👇<br><img src="/lionheart/1603/easeinput.png" alt="easeinput demo"><br>实现该效果的步骤如下：</p>
<ol>
<li>创建提示的UITableView<br>显示提示的白色框框实际上是一个UITableView，UITableView的内容根据当前已经输入的内容进行改变，若没有输入到@符号，就从之前输入过的账户中搜索；若已经输入了@符号，就显示不同的邮箱后缀。</li>
<li>将上一步创建的UITableView添加到输入账号，密码的UITableView中，并将提示框UITableView的位置定在账号的cell下面。</li>
<li>至于两个UITableView的交互：当账号的cell中的UITextField内容发生变化时，调用提示框UITableView的一个block，传入当前UITextField的文本，对提示的内容进行实时的变换。</li>
</ol>
<h2 id="enumerateObjectsUsingBlock"><a href="#enumerateObjectsUsingBlock" class="headerlink" title="enumerateObjectsUsingBlock:"></a><code>enumerateObjectsUsingBlock:</code></h2><p><code>enumerateObjectsUsingBlock:</code>方法和<code>for-in</code>类似，具体代码如下👇</p>
<pre><code>        NSDictionary *dict = @{@&quot;a&quot;: @&quot;1&quot;, @&quot;b&quot;: @&quot;2&quot;};
        [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
            NSLog(@&quot;key: %@, value: %@&quot;, key, obj);
        }];
</code></pre><p>推荐使用<code>for-in</code>方法，快。</p>
<h2 id="2种UITableViewCell重用方式"><a href="#2种UITableViewCell重用方式" class="headerlink" title="2种UITableViewCell重用方式"></a>2种<code>UITableViewCell</code>重用方式</h2><p><code>UITableViewCell</code>有两种dequeueReuse方法：</p>
<ol>
<li><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;</code><br>该方法是不用事先注册Cell，但是它可能返回nil；所以当返回nil时，需要重新init。示例代码如下👇<pre><code>     static NSString *CellIdentifier = @&quot;Cell&quot;;
     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
     if (cell == nil) {
         cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
     }
</code></pre></li>
<li><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;</code><br>该方法在iOS6中取代了第一种方法，它可以保证一定会返回UITableViewCell，但是在初始化UITableView时，需要进行UITableViewCell的注册，如下👇<pre><code>     [_tableView registerClass:[CustomCell class] forCellReuseIdentifier:@&quot;Cell&quot;];
</code></pre>于是在重用UITableViewCell，不需要判断是否为nil，代码如下👇<pre><code>     CustomCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];
</code></pre></li>
</ol>
<h2 id="NSRange基础"><a href="#NSRange基础" class="headerlink" title="NSRange基础"></a><code>NSRange</code>基础</h2><p>NSRange是一个结构体，其定义如下👇</p>
<pre><code>        typedef struct _NSRange {
            NSUInteger location;
            NSUInteger length;
        } NSRange;
</code></pre><p>其中<code>location</code>表示起始位置，<code>length</code>表示长度。</p>
<h2 id="CAShapeLayer基础"><a href="#CAShapeLayer基础" class="headerlink" title="CAShapeLayer基础"></a><code>CAShapeLayer</code>基础</h2><p><code>CAShapeLayer</code>继承自<code>CALayer</code>，它表示一个形状，有一个<code>path</code>属性用来描述该形状，然后可以对这个形状进行描边，填充等操作。示例代码如下👇</p>
<pre><code>        CAShapeLayer *layer = [CAShapeLayer layer];
        // 创建path, 给layer添加path, 释放path
        CGMutablePathRef pathRef = CGPathCreateMutable();
        CGRect bounds = CGRectInset(cell.bounds, 0, 0);
        CGPathAddRect(pathRef, nil, bounds);
        layer.path = pathRef;
        CFRelease(pathRef);
        // 对layer进行填充操作
        layer.fillColor = [UIColor colorWithWhite:1.0 alpha:0.8].CGColor;
        // 添加layer
        UIView *bgView = [[UIView alloc] initWithFrame:bounds];
        [bgView.layer addSublayer:layer];
</code></pre><h2 id="显示-隐藏导航栏"><a href="#显示-隐藏导航栏" class="headerlink" title="显示/隐藏导航栏"></a>显示/隐藏导航栏</h2><p>使用下列方法实现导航栏的显示或者隐藏</p>
<pre><code>        - (void)viewWillAppear:(BOOL)animated {
            [super viewWillAppear:animated];
            // 隐藏导航栏，若Hidden设为NO，则显示导航栏
            [self.navigationController setNavigationBarHidden:YES animated:YES];
        }
</code></pre><h2 id="ViewController之间切换卡顿"><a href="#ViewController之间切换卡顿" class="headerlink" title="ViewController之间切换卡顿"></a>ViewController之间切换卡顿</h2><p>可能的原因：没有设置ViewController的backgroundColor＝。＝</p>
<h2 id="SDWebImageOptions"><a href="#SDWebImageOptions" class="headerlink" title="SDWebImageOptions"></a><code>SDWebImageOptions</code></h2><pre><code>        typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {
            SDWebImageRetryFailed = 1 &lt;&lt; 0,//下载失败了会再次尝试下载
            WebImageLowPriority = 1 &lt;&lt; 1,//当UIScrollView等正在滚动时，延迟下载图片（放置scrollView滚动卡）
            SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只缓存到内存中
            SDWebImageProgressiveDownload = 1 &lt;&lt; 3,// 图片会边下边显示
            SDWebImageRefreshCached = 1 &lt;&lt; 4,//将硬盘缓存交给系统自带的NSURLCache去处理
            SDWebImageContinueInBackground = 1 &lt;&lt; 5,//后台下载
            SDWebImageHandleCookies = 1 &lt;&lt; 6,// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie
            SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,// 允许不受信任的SSL证书。主要用于测试目的。
            SDWebImageHighPriority = 1 &lt;&lt; 8,
            SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,
            SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,
        };
</code></pre><h2 id="在category中新增property"><a href="#在category中新增property" class="headerlink" title="在category中新增property"></a>在<code>category</code>中新增<code>property</code></h2><p>正常情况下，在category中是不能新增property的，要按如下步骤进行＝。＝</p>
<ol>
<li>导入头文件<pre><code>     #import &lt;objc/runtime.h&gt;
</code></pre></li>
<li>新增@property<pre><code>     @property (nonatomic, strong) UIActivityIndicatorView *buttonIndicatorView;
</code></pre></li>
<li><p>自定义<code>setter</code>和<code>getter</code></p>
<pre><code>     static char EAButtonIndicatorViewKey;

     - (void)setButtonIndicatorView:(UIActivityIndicatorView *)buttonIndicatorView {
         objc_setAssociatedObject(self, &amp;EAButtonIndicatorViewKey, buttonIndicatorView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);  
     }

     - (UIActivityIndicatorView *)buttonIndicatorView {
         return objc_getAssociatedObject(self, &amp;EAButtonIndicatorViewKey);
     }
</code></pre></li>
</ol>
<h2 id="用户名存储整个流程"><a href="#用户名存储整个流程" class="headerlink" title="用户名存储整个流程"></a>用户名存储整个流程</h2><p>参考这里</p>
<h2 id="UIAlertController基础"><a href="#UIAlertController基础" class="headerlink" title="UIAlertController基础"></a><code>UIAlertController</code>基础</h2><p>从iOS8开始，<code>UIAlertController</code>开始替代<code>UIAlertAction</code>,先来看看UIAlertController的效果图👇<br><img src="/lionheart/1603/alertcontroller.png" alt="UIAlertController demo"><br>实现代码👇</p>
<pre><code>        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;欢迎注册 Coding，请尽快去邮箱查收邮件并激活账号。如若在收件箱中未看到激活邮件，请留意一下垃圾邮件箱(T_T)。&quot; preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *ok = [UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
            [alertController dismissViewControllerAnimated:YES completion:nil];
        }];

        [alertController addAction:ok];
        [self presentViewController:alertController animated:YES completion:nil];
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/ryantang03/article/details/8622415" target="_blank" rel="external">iOS学习笔记42—利用dispatch_once创建单例</a></li>
<li><a href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/" target="_blank" rel="external">Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</a></li>
<li><a href="http://blog.sunnyxx.com/2014/04/30/ios_iterator/" target="_blank" rel="external">ios中集合遍历方法的比较和技巧</a></li>
<li><a href="http://eric-gao.iteye.com/blog/2234047" target="_blank" rel="external">UITableView的两种重用Cell方法的区别</a></li>
<li><a href="http://www.henishuo.com/ios-cashapelayer-learning/" target="_blank" rel="external">iOS CAShapeLayer精讲</a></li>
<li><a href="http://www.jianshu.com/p/c07df06c60be" target="_blank" rel="external">SDWebImage源码剖析</a></li>
</ul>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h2><p>以上都不是重点，重点是ollie要过立了＝。＝</p>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JazzHands]]></title>
      <url>/2016/02/27/jazzhands/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">JazzHands</a>, Github上的开源库，非常适用于app的介绍界面。先看看效果图👇<br><img src="/lionheart/1602/jazzhandsdemo.gif" alt="JazzHands demo"><br><a href="https://github.com/vanney9/blogDemo/tree/master/blogJazzHands" target="_blank" rel="external">👉demo代码在这里👈</a></p>
<a id="more"></a>
<h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><ol>
<li>创建JazzHandsViewController</li>
<li>定义介绍页面的页数</li>
<li>添加图片</li>
<li>定义每张图片的位置</li>
<li>添加滑动时候的效果</li>
</ol>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>使用cocoapod添加JazzHands</p>
<pre><code> pod &#39;JazzHands&#39;, &#39;2.0.8&#39;
</code></pre></li>
<li><p>创建工程，新增<code>JazzHandsViewController</code>,<br>继承自<code>IFTTTAnimatedPagingScrollViewController</code></p>
</li>
<li><p>导入头文件</p>
<pre><code> #import &lt;IFTTTJazzHands.h&gt;
</code></pre></li>
</ol>
<h3 id="定义页面页数"><a href="#定义页面页数" class="headerlink" title="定义页面页数"></a>定义页面页数</h3><p>其实就是重写 <code>- (NSUInteger)numberOfPages;</code> 函数</p>
<h3 id="添加subView"><a href="#添加subView" class="headerlink" title="添加subView"></a>添加subView</h3><p>将每张图片封装到UIImageView,并添加到<code>JazzHandsViewController</code>的subView里面<br>关键代码:<br><img src="/lionheart/1602/jazzhandscode1.png" alt="JazzHands code1"></p>
<h3 id="定义每张图片位置"><a href="#定义每张图片位置" class="headerlink" title="定义每张图片位置"></a>定义每张图片位置</h3><p>使用<code>keepView:onPages:</code>或者<code>keepView:onPages:atTimes:</code>定义位置</p>
<h4 id="keepView-onPages"><a href="#keepView-onPages" class="headerlink" title="keepView:onPages:"></a>keepView:onPages:</h4><pre><code>    [self keepView:iconView onPage:i];
</code></pre><p>i表示目前处于介绍页面的第i页，该函数说明<code>iconView</code>只能显示在第i页面上</p>
<h4 id="keepView-onPages-atTimes"><a href="#keepView-onPages-atTimes" class="headerlink" title="keepView:onPages:atTimes:"></a>keepView:onPages:atTimes:</h4><p><strong>这篇文章的精华所在＝。＝</strong></p>
<pre><code>    [self keepView:tipView onPages:@[@(i + 1), @(i), @(i - 1)] atTimes:@[@(i - 1), @(i), @(i + 1)]];
</code></pre><p>上面的语句说明了3件事:(将i设为2进行说明， 所有 <strong>3</strong> 对应 <strong>i + 1</strong>, <strong>2</strong> 对应 <strong>i</strong>, <strong>1</strong> 对应 <strong>i - 1</strong>)</p>
<ol>
<li><code>tipView</code>可以显示在第3，2，1页面上</li>
<li>当当前屏幕显示的是第2页面时，<code>tipView</code>应该在第2页面；当当前屏幕显示的是第1页面时，<code>tipView</code>应该在第3页面：这说明了当屏幕从第2页滑动到第1页时(意会一下：这里手指的操作是向👉滑动)，<code>tipView</code>从第2页滑动到了第3页(意会一下：就是<code>tipView</code>咻咻的一下跟着手指被滑到👉，并且比后面的页面更快地滑出界面了)</li>
<li>当当前屏幕显示的是第2页面时，<code>tipView</code>应该在第2页面；当当前屏幕显示的是第3页面时，<code>tipView</code>应该在第1页面：这说明了当屏幕从第2页滑动到第3页时(意会一下：这里手指的操作是向👈滑动)，<code>tipView</code>从第2页滑动到了第1页(意会一下：就是<code>tipView</code>咻咻的一下跟着手指被滑到👈，并且比后面的页面更快地滑出界面了)</li>
</ol>
<h3 id="添加滑动时候的效果"><a href="#添加滑动时候的效果" class="headerlink" title="添加滑动时候的效果"></a>添加滑动时候的效果</h3><p>这里使用的是淡入淡出效果,通过<code>IFTTTAlphaAnimation</code>控制view的透明度<br>关键代码：<br><img src="/lionheart/1602/jazzhandscode2.png" alt="JazzHands code2"><br>还是将i设为2进行说明：</p>
<ol>
<li>当当前页面刚好在第2页的时候，这个时候是不透明的，完全显示</li>
<li>当当前页面刚好在第2.5/1.5页的时候，这个时候是完全透明的，不显示</li>
<li>在1.5-2.5之间,<code>tipView</code>渐变显示</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>动画可以分为2部分，淡入淡出和滑动</li>
<li>滑动的控制使用<code>keepView:onPages:</code>或者<code>keepView:onPages:atTimes:</code>，这部分关键在于意会…</li>
<li>淡入淡出使用<code>IFTTTAlphaAnimation</code>控制</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">JazzHands</a></li>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding iOS 客户端源代码</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[2016 Week 1]]></title>
      <url>/2016/02/27/2016-week1/</url>
      <content type="html"><![CDATA[<p>开年第一周，准备换个方式写博客。就当周记吧，可以肯定这种模式也是持续不了多久的＝。＝</p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>2月20号回到武汉；21号回到学校，被基友叫过去看三打白骨精（其实想去看美人鱼来着的…）；然后就开始工作了。<br>开学第一周，没啥具体的任务。自己在github上找了<a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding_iOS</a>的源码，照着做了起来。来看看第一周碰到的各类问题。</p>
<a id="more"></a>
<h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><ol>
<li>状态栏（<code>UIStatusBar</code>)的显示</li>
<li>导航栏（<code>UINavigationBar</code>）的设置</li>
<li>判断iPhone机型</li>
<li>第三方库: <code>JazzHands</code></li>
<li><code>UIPageControl</code>使用</li>
<li>圆角Button</li>
<li>ViewController的两种跳转</li>
<li>UITableView的<code>tableHeaderView</code>和<code>tableFooterView</code></li>
<li><code>UIActionSheet</code>使用</li>
<li>SDWebImage cache相关</li>
</ol>
<p>进入正文…</p>
<h2 id="状态栏（UIStatusBar-的显示"><a href="#状态栏（UIStatusBar-的显示" class="headerlink" title="状态栏（UIStatusBar)的显示"></a>状态栏（<code>UIStatusBar</code>)的显示</h2><p>之前有一篇博客讲到UIStatusBar的设置(<a href="http://vanney9.com/2016/01/05/iOS-navbar-statusbar-setting/" target="_blank" rel="external">iOS导航栏和状态栏设置</a>),这里的是另一种方法–全局设置UIStatusBar。</p>
<ol>
<li>在.plist文件中，将<code>UIViewControllerBasedStatusBarAppearance</code>设置为NO</li>
<li>要全局设置UIStatusBar的话<pre><code> [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent]; // 将状态了设置为亮色（白色）
 [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault]; // 将状态栏还原为默认（黑色）
</code></pre></li>
</ol>
<h2 id="导航栏（UINavigationBar）的设置"><a href="#导航栏（UINavigationBar）的设置" class="headerlink" title="导航栏（UINavigationBar）的设置"></a>导航栏（<code>UINavigationBar</code>）的设置</h2><p>同样，在<a href="http://vanney9.com/2016/01/05/iOS-navbar-statusbar-setting/" target="_blank" rel="external">iOS导航栏和状态栏设置</a>这篇里讲过UINavigationBar的设置，这里说的是全局设置UINavigationBar的方法。<br>方法其实很简单啦，就是通过<code>[UINavigationBar appearance]</code>获得设置UINavigationBar的全局代理，一般在 <strong>AppDelegate.m</strong> 文件里面设置。代码如下👇</p>
<pre><code>        UINavigationBar *navBarAppearance = [UINavigationBar appearance];
        [navBarAppearance setBarTintColor:[UIColor colorWithHexString:@&quot;0x28303b&quot;]];
        [navBarAppearance setTintColor:[UIColor whiteColor]];
        NSDictionary *textAttributes = @{ NSFontAttributeName : [UIFont boldSystemFontOfSize:kNavTitleFontSize],
                                      NSForegroundColorAttributeName : [UIColor whiteColor] };
        [navBarAppearance setTitleTextAttributes:textAttributes];
</code></pre><h2 id="判断iPhone机型"><a href="#判断iPhone机型" class="headerlink" title="判断iPhone机型"></a>判断iPhone机型</h2><p>判断iPhone机型的代码，会经常用到，就放在.pch文件里面吧。代码如下👇</p>
<pre><code>    #define kDevice_Is_iPhone6 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(750, 1334), [[UIScreen mainScreen] currentMode].size) : NO)
</code></pre><p>另外，各种机型对应的CGSize:</p>
<ol>
<li>iPhone4(s): CGSizeMake(640, 960)</li>
<li>iPhone5(s): CGSizeMake(640, 1136)</li>
<li>iPhone6(s): CGSizeMake(750, 1334)</li>
<li>iPhone6(s)Plus: CGSizeMake(1242, 2208)</li>
</ol>
<h2 id="第三方库-JazzHands"><a href="#第三方库-JazzHands" class="headerlink" title="第三方库: JazzHands"></a>第三方库: <code>JazzHands</code></h2><p><a href="https://github.com/IFTTT/JazzHands" target="_blank" rel="external">JazzHands</a>, 超适合用来做开始界面，来看下面的动态图👇<br><img src="/lionheart/1602/jazzhands.gif" alt="JazzHands demo"><br>有关JazzHands的具体使用将在<a href="/2016/02/27/jazzhands/">这篇文章(JazzHands)</a>里面介绍＝。＝</p>
<h2 id="UIPageControl使用"><a href="#UIPageControl使用" class="headerlink" title="UIPageControl使用"></a><code>UIPageControl</code>使用</h2><p>主要就是UIPageControl的几个属性:</p>
<ol>
<li>numberOfPages: 总页数</li>
<li>currentPage: 当前页数</li>
<li>pageIndicatorTintColor: 小圆点的默认颜色</li>
<li>currentPageIndicatorTintColor: 高亮当前小圆点的颜色</li>
</ol>
<h2 id="圆角Button"><a href="#圆角Button" class="headerlink" title="圆角Button"></a>圆角Button</h2><p>设置圆角Button与设置圆角相同，关键就是设置:</p>
<ol>
<li><code>button.layer.masksToBounds = YES;</code></li>
<li><p><code>button.layer.cornerRadius = cornerRadius;</code><br>具体代码如下👇</p>
<pre><code>     self.loginButton = [UIButton buttonWithType:UIButtonTypeCustom];
     self.loginButton.backgroundColor = [UIColor whiteColor];
     [self.loginButton setTitle:@&quot;登录&quot; forState:UIControlStateNormal];
     [self.loginButton setTitleColor:darkColor forState:UIControlStateNormal];
     self.loginButton.titleLabel.font = [UIFont boldSystemFontOfSize:20];

     [self.loginButton addTarget:self action:@selector(loginButtonClick) forControlEvents:UIControlEventTouchUpInside];

     [self.view addSubview:self.loginButton];
     [self.loginButton mas_makeConstraints:^(MASConstraintMaker *make) {
         // auto-layout code here...
     }];

     self.loginButton.layer.masksToBounds = YES;
     self.loginButton.layer.cornerRadius = buttonHeight / 2;
     self.loginButton.layer.borderColor = darkColor.CGColor;
     self.loginButton.layer.borderWidth = 1.0f;
</code></pre></li>
</ol>
<h2 id="ViewController的两种跳转"><a href="#ViewController的两种跳转" class="headerlink" title="ViewController的两种跳转"></a>ViewController的两种跳转</h2><p>在ViewController之间跳转，有一下2种方法：</p>
<ol>
<li><code>[self presentViewController:loginVC animated:YES completion:nil];</code><br>这种方法实现从 self(Source ViewController) 跳转到 loginVC(Dest ViewController)</li>
<li><code>[self.navigationController pushViewController:destVC animated:YES];</code><br>这种方法实现从 self(Source ViewController) 跳转到 destVC(Dest ViewController), 但是这里的self(ViewController)必须在一个UINavigationController里面</li>
</ol>
<h2 id="UITableView的tableHeaderView和tableFooterView"><a href="#UITableView的tableHeaderView和tableFooterView" class="headerlink" title="UITableView的tableHeaderView和tableFooterView"></a>UITableView的<code>tableHeaderView</code>和<code>tableFooterView</code></h2><ol>
<li>tableHeaderView - table - tableFooterView 依次排列</li>
<li>这两个view属于scrollview, 他们会随着table一起移动</li>
</ol>
<h2 id="UIActionSheet使用"><a href="#UIActionSheet使用" class="headerlink" title="UIActionSheet使用"></a><code>UIActionSheet</code>使用</h2><p>先看看实现效果👇<br><img src="/lionheart/1602/uiactionsheet.png" alt="UIActionSheet demo"></p>
<p>具体实现:</p>
<ol>
<li>初始化<pre><code>     _actionSheet = [[UIActionSheet alloc] initWithTitle:nil
                                                delegate:self
                                       cancelButtonTitle:@&quot;Cancel&quot;
                                  destructiveButtonTitle:nil
                                       otherButtonTitles:@&quot;Clear Cache&quot;, nil];
</code></pre></li>
<li>实现<code>UIActionSheetDelegate</code>的点击时间委托<pre><code>     - (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {
         switch (buttonIndex) {
             case 0:
                 // do something here
                 break;
             case 1:
                 // do something here
                 break;
             default:
                 break;
         }
     }
</code></pre></li>
</ol>
<h2 id="SDWebImage-cache相关"><a href="#SDWebImage-cache相关" class="headerlink" title="SDWebImage cache相关"></a>SDWebImage cache相关</h2><ol>
<li>清除缓存<pre><code>     SDWebImageManager *imageManager = [SDWebImageManager sharedManager];
     [imageManager.imageCache clearDiskOnCompletion:^{
         NSLog(@&quot;vanney code log... cache cleared&quot;);
     }];
</code></pre></li>
<li>显示缓存信息<pre><code>     SDWebImageManager *imageManager = [SDWebImageManager sharedManager];
     [imageManager.imageCache getSize]; // 缓存的大小 除2次1024 得到MB
     [imageManager.imageCache getDiskCount]; // 缓存图片的数量
</code></pre></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/b18de01e0cc8" target="_blank" rel="external">SDWebImage源码学习-One</a>  </li>
<li><a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding iOS 客户端源代码</a>            </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[UITableView基础应用]]></title>
      <url>/2016/01/11/UITableView-Demo/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天介绍一个简单的UITableView，简单的界面，涉及到UITableView的一些基础的DataSource和Delegate。<br>效果图👇</p>
<p><img src="/lionheart/1601/tableViewDemo.png" alt="UITableView Demo"></p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在跟着github上的一个项目：<a href="https://github.com/meilbn/MyOne-iOS" target="_blank" rel="external">MyOne-iOS</a>，做着高仿的一个app（韩寒出品），其中的设置界面就需要做到上述的效果。效果图使用了UITableView，它涉及到UITableView基础的DataSource和Delegate。下面我就来分享一下其中代码。</p>
<h2 id="UITableView代码实现"><a href="#UITableView代码实现" class="headerlink" title="UITableView代码实现"></a>UITableView代码实现</h2><p>UITableView按Section来分成各个区域，其中每个Section又包含一个Header和多个Cell。效果图中一眼看出该UITableView分为4个Section。因此UITableView的代码思路也应该按Section来展开。</p>
<h3 id="UITableView的整体设计"><a href="#UITableView的整体设计" class="headerlink" title="UITableView的整体设计"></a>UITableView的整体设计</h3><p>所谓整体设计就是设计UITableView的每个Section的共有特性，以及UITableView的DataSource。<br>先来看看DataSource(使用数组来存放)：</p>
<p><img src="/lionheart/1601/datasourceset.png" alt="DataSource Set"></p>
<p><strong>注意:</strong> 这里多设计了一个Section，将在<a href="#jump">后面解释</a>。</p>
<p>再来设计UITableView的共有特性:</p>
<p><img src="/lionheart/1601/tableviewbaseproperty.png" alt="UITableView Property"></p>
<h3 id="Section-number和Cell-number"><a href="#Section-number和Cell-number" class="headerlink" title="Section number和Cell number"></a>Section number和Cell number</h3><p>UITableView整体设计结束后，就该想想这个UITableView给有多少个Section，以及每个Section该有几个Cell。它其实都包含在上一步的DataSource的数组中。<br>UITableView通过一下两个UITableViewDataSource方法得到Section和Cell得数目：</p>
<pre><code>    - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;
    - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
</code></pre><h3 id="Section-Header设计"><a href="#Section-Header设计" class="headerlink" title="Section Header设计"></a>Section Header设计</h3><p>Section Header的设计包括设计Header的高度以及Header的View，通过如下两个UITableViewDataSource实现：</p>
<pre><code>    - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;    //  返回Section Header高度
    - (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;     //  返回Section Header的View
</code></pre><p>具体代码如下：</p>
<p><img src="/lionheart/1601/sectionheader.png" alt="Section Header"></p>
<h3 id="Section-Cell设计"><a href="#Section-Cell设计" class="headerlink" title="Section Cell设计"></a>Section Cell设计</h3><p>Cell设计就是实现并返回一个UITableViewCell，它通过UITableViewDataSource方法实现：</p>
<pre><code>    - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre><p>注意到：</p>
<ol>
<li><p>iOS会复用上面代码注册的UITableViewCell，</p>
<pre><code> UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;stefanie&quot;];
</code></pre></li>
<li><p>每个UITableViewCell有一个textLabel属性用来设置Cell的标题，该属性是一个UILabel对象</p>
<ol>
<li>每个UITableViewCell有 accessoryType和 accessoryView属性，用来设计Cell最右边的样式</li>
</ol>
</li>
</ol>
<p>具体代码如下：</p>
<p><img src="/lionheart/1601/tableviewcell.png" alt="UITableViewCell"></p>
<h3 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h3><ol>
<li><p>当手指选中某个Cell时，改变UITableViewCell的背景色；当手指离开时背景色还原。只需实现如下UITableViewDelegate就可：</p>
<pre><code> - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
     [tableView deselectRowAtIndexPath:indexPath animated:YES];
 }
</code></pre></li>
<li><p>默认情况下<span id="jump"></span>，Header的上下都没有分割线，只有在两个Cell之间才有分割线，而且不到最左边但到最右边。这也解释了上面为什么要多设计一个与UITableView背景色相同的空的Section。因为如果只有4个Section，最后的“退出当前账号”下方会有一个奇怪的分割线。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/meilbn/MyOne-iOS" target="_blank" rel="external">github高仿《一个》客户端</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS导航栏和状态栏设置]]></title>
      <url>/2016/01/05/iOS-navbar-statusbar-setting/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯代码设置iOS导航栏和状态栏。效果图👇</p>
<p><img src="/lionheart/1601/navbar.png" alt="iOS导航栏和状态栏设置"></p>
<a id="more"></a>
<h2 id="导航栏设置-Navigation-Bar"><a href="#导航栏设置-Navigation-Bar" class="headerlink" title="导航栏设置(Navigation Bar)"></a>导航栏设置(Navigation Bar)</h2><p>iOS中的导航栏使用<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationBar_Class/" target="_blank" rel="external">UINavigationBar</a>，它继承自UIView。可以通过它控制导航栏显示的内容等等，一个导航栏通常包括：标题和左右侧按钮。</p>
<h3 id="UINavigationBar示意图"><a href="#UINavigationBar示意图" class="headerlink" title="UINavigationBar示意图:"></a>UINavigationBar示意图:</h3><p><img src="/lionheart/1601/navbardetail.png" alt="nav bar detail"></p>
<p>UINavigationBar几个重要属性：</p>
<ol>
<li><strong>tintColor</strong>: 导航栏左右侧按钮的颜色</li>
<li><strong>titleTextAttributes</strong>: 导航栏标题的属性</li>
<li><strong>translucent</strong>: 导航栏半透明属性，是一个BOOL值，默认为YES（即：默认导航栏是半透明的）</li>
<li><strong>barTintColor</strong>: 导航栏背景色</li>
</ol>
<h3 id="UINavigationBar内部结构"><a href="#UINavigationBar内部结构" class="headerlink" title="UINavigationBar内部结构:"></a>UINavigationBar内部结构:</h3><p>导航栏(UINavigationBar)内部可以包含多个UINavigationItem，UINavigationBar的UINavigationItem可以通过它的items属性获得。<br>UINavigationBar通过类似进栈和出栈的方式压入和弹出UINavigationItem。通常只需一个UINavigationItem。</p>
<ol>
<li>向UINavigationBar中插入UINavigationItem:<pre><code> - (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated
</code></pre></li>
<li>弹出最上方的一个UINavigationItem:<pre><code> - (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated
</code></pre></li>
<li>获取最上方的UINavigationItem: 通过UINavigationBar的topItem属性</li>
</ol>
<h3 id="UINavigationItem"><a href="#UINavigationItem" class="headerlink" title="UINavigationItem:"></a>UINavigationItem:</h3><p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationItem_Class/index.html#//apple_ref/doc/c_ref/UINavigationItem" target="_blank" rel="external">UINavigationItem</a>管理着显示在UINavigationBar中的内容。一个UINavigationItem通常包含:标题和左右侧的按钮。</p>
<h4 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h4><ol>
<li><strong>title</strong>: 标题</li>
<li><strong>leftBarButtonItem</strong>: 左侧按钮</li>
<li><strong>rightBarButtonItem</strong>: 右侧按钮</li>
</ol>
<h4 id="左右侧按钮设置"><a href="#左右侧按钮设置" class="headerlink" title="左右侧按钮设置"></a>左右侧按钮设置</h4><p>左右侧按钮通常都是UIBarButtonItem对象，可以通过如下代码设置：</p>
<pre><code>    UIBarButtonItem *btnLeft = [[UIBarButtonItem alloc] initWithTitle:@&quot;Back&quot; style:UIBarButtonItemStyleDone target:self action:nil];
</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><p><img src="/lionheart/1601/navbarcode.png" alt="navbar code"></p>
<h2 id="状态栏设置-Status-Bar"><a href="#状态栏设置-Status-Bar" class="headerlink" title="状态栏设置(Status Bar)"></a>状态栏设置(Status Bar)</h2><p>状态栏就是现实时间，运营商，电量的地方；如果导航栏背景色为深色的话，默认的状态栏无法清楚的显示。<br>状态栏的设置步骤有如下几步：</p>
<ol>
<li>在.plist文件将 UIViewControllerBasedStatusBarAppearance 设置为 YES</li>
<li>在 viewDidLoad 方法中添加<pre><code> [self setNeedsStatusBarAppearanceUpdate];
</code></pre></li>
<li>添加 preferredStatusBarStyle 方法：<pre><code> - (UIStatusBarStyle)preferredStatusBarStyle
 {
     return UIStatusBarStyleLightContent;
 }
</code></pre></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/19029833/ios-7-navigation-bar-text-and-arrow-color" target="_blank" rel="external">IOS 7 Navigation Bar text and arrow color</a></li>
<li><a href="http://stackoverflow.com/questions/17678881/how-to-change-status-bar-text-color-in-ios-7" target="_blank" rel="external">How to change Status Bar text color in iOS 7</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ShortCut(快捷键) － Xcode]]></title>
      <url>/2015/12/12/ShortCut-xcode/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间听了前端同学关于Sublime Text编辑器使用快捷键的分享，意识到快捷键的确是提高开发速率的神器。熟悉掌握所用编辑器的快捷键，也将极大的发挥出编辑器的威力。下面就介绍一些Xcode的快捷键（随时更新补充）。</p>
<a id="more"></a>
<h2 id="Xcode常用符号简写"><a href="#Xcode常用符号简写" class="headerlink" title="Xcode常用符号简写"></a>Xcode常用符号简写</h2><ol>
<li>command: <strong>⌘</strong></li>
<li>option: <strong>⌥</strong></li>
<li>shift: <strong>⇧</strong></li>
<li>caps lock: <strong>⇪</strong></li>
<li>control: <strong>⌃</strong></li>
</ol>
<h2 id="Xcode-ShortCut"><a href="#Xcode-ShortCut" class="headerlink" title="Xcode ShortCut"></a>Xcode ShortCut</h2><ol>
<li>.h和.m文件切换: control + cmd + ↑ <strong>(⌃ + ⌘ + ↑)</strong></li>
<li>显示/隐藏导航栏: cmd + 0 <strong>(⌘ + 0)</strong></li>
<li>运行程序: cmd + R <strong>(⌘ + R)</strong></li>
<li>展开/折叠函数: option + cmd + ← | → <strong>(⌥ + ⌘ + ← | →)</strong></li>
<li>👈/👉选择一个单词: shift + option + ← | → <strong>(⇧ + ⌥ + ← | →)</strong></li>
<li>👈/👉选择到行头/行尾: shift + cmd + ← | → <strong>(⇧ + ⌘ + ← | →)</strong></li>
<li>将光标移动到行尾: cmd + → <strong>(⌘ + →)</strong></li>
<li>将光标移动到行头: cmd + ← <strong>(⌘ + ←)</strong> //觉得很鸡肋的一个快捷键， 后来被我用插件覆盖了这一快捷键</li>
<li>切换tab: cmd + shift + [ | ] <strong>(⌘ + ⇧ + [ | ])</strong></li>
<li>展开/显示工具栏: cmd + option + 0 <strong>(⌘ + ⌥ + 0)</strong></li>
<li>新建文件: cmd + N <strong>(⌘ + N)</strong></li>
<li>clean: cmd + shift + K <strong>(⌘ + ⇧ + K)</strong></li>
<li>build: cmd + B <strong>(⌘ + B)</strong></li>
</ol>
<h2 id="Xcode-simulator-ShortCut"><a href="#Xcode-simulator-ShortCut" class="headerlink" title="Xcode simulator ShortCut"></a>Xcode simulator ShortCut</h2><ol>
<li>转换屏幕显示方向: cmd + ← | → <strong>(⌘ + ← | →)</strong></li>
<li>屏幕截图: cmd + S <strong>(⌘ + S)</strong></li>
<li>Home键: shift + cmd + H <strong>(⇧ + ⌘ + H)</strong>, 双击Home键就是 <strong>⇧ + ⌘ + H + H</strong></li>
</ol>
<h2 id="安装Package-Manager-Alcatraz"><a href="#安装Package-Manager-Alcatraz" class="headerlink" title="安装Package Manager:Alcatraz"></a>安装Package Manager:Alcatraz</h2><p>Alcatraz是一个开源的Xcode插件管理器,打开终端，输入命令:</p>
<pre>curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh</pre>

<p>打开Alcatraz: shift + cmd + 9 <strong>(⇧ + ⌘ + 9)</strong></p>
<p>搜索XCode4_beginning_of_line并安装，覆盖原有的移动光标到行头的快捷键。所以:<br><br>将光标移动到一行的第一个非空白处: cmd + ← <strong>(cmd + ←)</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://softu.cn/447" target="_blank" rel="external">Mac如何输入⌘、⌥、⇧、⌃、⎋等特殊字符</a></li>
<li><a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz:The package manager for Xcode</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx配置的一些问题]]></title>
      <url>/2015/08/03/nginx-conf-problem/</url>
      <content type="html"><![CDATA[<p>今天小学弟问了些关于nginx和ci配置的问题，主要就是去掉index.php后可以正常访问，但是加上index.php后居然不能正常访问，而且重定向到了welcome/index页面，最后的最后，还是小学弟找到了解决方法=.=</p>
<a id="more"></a>
<p>先上链接</p>
<ol>
<li><a href="http://blog.sina.com.cn/s/blog_48d40b7a0100saqh.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_48d40b7a0100saqh.html</a></li>
<li><a href="http://www.chenyudong.com/archives/codeigniter-in-nginx-and-url-rewrite.html" target="_blank" rel="external">http://www.chenyudong.com/archives/codeigniter-in-nginx-and-url-rewrite.html</a></li>
<li><a href="http://blog.csdn.net/ei__nino/article/details/8599304" target="_blank" rel="external">http://blog.csdn.net/ei__nino/article/details/8599304</a></li>
</ol>
<p>目前还不知道什么原因，先看看前后nginx配置的不同<br>先前的配置：<br><img src="/lionheart/nginx_conf_old.png"><br>后来的配置：<br><img src="/lionheart/nginx_conf_new.png"></p>
<p>但是为什么要这样配置呢… 还不清楚</p>
]]></content>
      
        <categories>
            
            <category> server </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[重识git]]></title>
      <url>/2015/07/28/review-git/</url>
      <content type="html"><![CDATA[<p>　　今天，在<a href="www.coding.net">coding.net</a>上面，自己见了一个项目来熟悉git的基本操作。并没有用到github，主要使用的是coding.net来托管代码。<br>　　最主要的参考资料是阮一峰大神的一篇博客：<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a><br>　　下面对今天的一系列操作做个记录，以便以后使用。<br><a id="more"></a></p>
<h4 id="在coding-net上面新建项目"><a href="#在coding-net上面新建项目" class="headerlink" title="在coding.net上面新建项目"></a>在coding.net上面新建项目</h4><ol>
<li>在coding.net上面添加ssh公钥<br>$ cd ~/.ssh<pre><code> $ ssh-keygen
</code></pre>将生成的id_rsa.pub复制，添加到coding.net，参考<a href="http://segmentfault.com/a/1190000002737818" target="_blank" rel="external"> 将公钥部署到远程Git仓库（coding.net）</a></li>
<li>新建项目</li>
</ol>
<h4 id="本地拷贝远程仓库"><a href="#本地拷贝远程仓库" class="headerlink" title="本地拷贝远程仓库"></a>本地拷贝远程仓库</h4><pre><code>    $ git clone https://git.coding.net/xxx/xxx.git
</code></pre><h4 id="本地添加代码，并提交到coding"><a href="#本地添加代码，并提交到coding" class="headerlink" title="本地添加代码，并提交到coding"></a>本地添加代码，并提交到coding</h4><ol>
<li>在本地新建一个文档，(example:README.md)，由于远程仓库是空的，所以进行第一次提交时，需要执行：<br>$ git add README.md<pre><code> $ git commit -m &#39;first commit&#39;
 $ git push origin master #git push &lt;远程主机名&gt; &lt;本地分支&gt;:&lt;远程分支&gt;
</code></pre>这样就完成了第一次提交，也在本地和远端都建立了一个master分支</li>
<li>将本地和远程的相同分支建立追踪：<br>$ git branch –set-upstream-to=origin/master master<br>这样以后只需要执行：<pre><code>$ git pull OR git push
</code></pre>而不用执行如下繁琐命令：<pre><code>$ git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt; OR git push &lt;远程主机&gt; &lt;本地分支&gt;:&lt;远程分支&gt;
</code></pre>注意： 上述繁琐语句中的冒号后面的内容一般可以省略，因为远程分支和本地分支一般名字相同</li>
<li>每次pull或是push是都需要输入username和密码，可以在.git文件夹下面修改config文件。<br>url = <a href="https://[your" target="_blank" rel="external">https://[your</a> username]:[your password]@git.coding.net/xxx/xxx.git</li>
</ol>
<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><ul>
<li>在coding.net上面新建一个dev分支，与当前的master一致，在本地通过如下代码将其拷贝下来：<br>$ git branch dev  //新建本地dev分支<pre><code> $ git checkout dev //切换到本地dev分支
 $ git pull origin dev //拷贝远程dev分支到本地dev分支
 $ git branch --set-upstream-to=origin/dev dev //建立dev分支追踪
</code></pre>通过这种方式实现本地dev分支和远端dev分支的同步；并且，由于建了追踪的原因，之后在dev分支下面的pull和push操作也只需要git pull和git push就行。</li>
</ul>
<h4 id="本地新建分支，追踪远端分支"><a href="#本地新建分支，追踪远端分支" class="headerlink" title="本地新建分支，追踪远端分支"></a>本地新建分支，追踪远端分支</h4><p>还有一种情况就是：远端现在与master和dev两个分支，而本地只有master分支；如何在本地创建dev分支，并让他追踪远端dev分支呢？👇</p>
<pre><code>                git fetch                // 检查远端分支更新
                git branch --track dev origin/dev    // 本地创建dev分支并追踪远端origin/dev分支
                git checkout dev                // 切换到dev分支
</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a></li>
<li><a href="http://stackoverflow.com/questions/11262703/track-a-new-remote-branch-created-on-github" target="_blank" rel="external">Track a new remote branch created on GitHub</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[python爬取cs193p课件]]></title>
      <url>/2015/07/27/python-grab-cs193/</url>
      <content type="html"><![CDATA[<p>最近在上stanford的cs193p的课程，闲着没事，先将它的课件用python从网上爬了下来…</p>
<a id="more"></a>
<h4 id="目标网站"><a href="#目标网站" class="headerlink" title="目标网站"></a>目标网站</h4><p><a href="http://www.stanford.edu/class/cs193p/cgi-bin/drupal/downloads-2013-fall" target="_blank" rel="external">CS 193P iPhone Application Development</a><br><img src="/lionheart/cs193p_index.png"></p>
<h4 id="先看源码"><a href="#先看源码" class="headerlink" title="先看源码"></a>先看源码</h4><p><img src="/lionheart/cs193p_html_code.png"><br>在class=view-content的div里面是所需的课件的下载链接，他们以&lt;h3$gt;和&lt;div&gt;的顺序排列。<br>看看每个&lt;div&gt;的具体内容<br><img src="/images/lionheart/cs193p_html_code1.png"><br>每一个&lt;div&gt;下面的&lt;a&gt;标签里面的href链接所对应的内容都应该下载下来</p>
<h4 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h4><ol>
<li><p>mkdir.sh</p>
<blockquote>
<p>#!/bin/sh</p>
<p>for var in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18<br>do<br>　　mkdir $var<br>done</p>
</blockquote>
<p> 创建多个目录，用来存放每节课的lecture</p>
</li>
<li><p>download-lecture.py</p>
<blockquote>
<p>import os<br>import requests<br>import bs4<br>import re</p>
<p>original_url = ‘<a href="http://www.stanford.edu/class/cs193p/cgi-bin/drupal/downloads-2013-fall" target="_blank" rel="external">http://www.stanford.edu/class/cs193p/cgi-bin/drupal/downloads-2013-fall</a>‘<br>response = requests.get(original_url)<br>html = response.text<br>soup = bs4.BeautifulSoup(html)</p>
<p>view_content = soup.findAll(“div”, {“class” : “view-content”})</p>
<p>lectures = view_content[0].findAll(“h3”);<br>for lecture in lectures:<br>　　lecture_title = lecture.text<br>　　lecture_content = lecture.findNextSibling(“div”)<br>　　sample = lecture_content.find(“div”, {“class” : “views-field-field-sample-code-fid”})<br>　　slide = lecture_content.find(“div”, {“class” : “views-field-field-lecture-slides-fid”})</p>
<p>　　#regular expression<br>　　pattern = re.compile(r’Title: Lecture’);<br>　　match = pattern.match(lecture_title);<br>　　if match:<br>　　　　title_array = lecture_title.split(‘: Lecture’);<br>　　　　lecture_num = ((title_array[1].split(‘ ‘))[1].split(‘:’))[0]<br>　　else:<br>　　　　continue</p>
<p>　　sample_urls = sample.findAll(‘a’)<br>　　slide_urls = slide.findAll(‘a’)</p>
<p> current_dir = ‘cd ‘ + lecture_num<br> os.system(current_dir)<br> for sample_url in sample_urls:<br>　　　　href = sample_url[‘href’]<br>　　　　os.system(current_dir + ‘ &amp;&amp; wget ‘ + href)<br> for slide_url in slide_urls:<br>　　　　href = slide_url[‘href’]<br>　　　　os.system(current_dir + ‘ &amp;&amp; wget ‘ + href)</p>
</blockquote>
<p> 使用了BeautifulSoup来分析HTML代码</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdowning...]]></title>
      <url>/2015/07/22/Markdowning/</url>
      <content type="html"><![CDATA[<h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><blockquote>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。 —-<a href="http://baike.baidu.com/link?url=NbjzNRdzUWluzLSRvvm7Tb-B3Qv4fqGSzZ36JaVtHNMubM6qxLrsoYUq3PcrMvDSCbV5kCCjzGw6jCVV_WyZTK" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<a id="more"></a>
<h2 id="editor"><a href="#editor" class="headerlink" title="editor"></a>editor</h2><p><a href="http://pad.haroopress.com/" target="_blank" rel="external">Haroopad</a>：一款覆盖三大主流桌面系统的编辑器，支持 Windows、Mac OS X 和 Linux。 主题样式丰富，语法标亮支持 54 种编程语言。该工具重点推荐 Ubuntu/Linux 用户使用，从此可以告别 gedit 加 Markdown 插件这种工作方式了。<br>很逗的<strong>logo</strong> : <img src="http://pad.haroopress.com/assets/images/logo-small.png" alt=""></p>
<h2 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h2><p><a href="http://wowubuntu.com/markdown/#p" target="_blank" rel="external">Markdown语法详解</a></p>
<ol>
<li><strong>如何设置字体<font size="5" color="red"><em>大</em></font><font size="2" color="blue"><em>小</em></font></strong><br>使用<strong><em>html font</em></strong>…我以为会有简单的方法…(这样的话下面几点也就不介绍了，markdown无法完成的就老老实实用html了)</li>
<li><strong>图片位置调整</strong><br>使用<strong>&lt;img&gt;</strong>标签</li>
<li><strong>特殊字符转义</strong><br>转义用 <strong>\</strong><br>example : <strong>加粗的两个星号</strong> <strong>**</strong>  (<strong>**\*\***</strong>)</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>/2015/07/21/Hello-Hexo/</url>
      <content type="html"><![CDATA[<p>#Hexo</p>
<p><strong>Markdown?</strong></p>
<p>还在找更简洁，简单的写作方式，顺便删掉自带的hello world. 话说，如何插图？</p>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是XXX。欢迎来到我的个人技术博客。</p>
<p>这里用markdown写下你的简介，就跟平时写md一样就可以了。</p>
]]></content>
    </entry>
    
  
</search>
