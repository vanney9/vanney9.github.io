<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

    <title>iOS Core Animation - Setting Things in Motion | Vanney</title>
    <meta name="author" content="Vanney">
    
    <meta name="description" content="前言iOS Core Animation 读书笔记（二） Setting Things in Motion">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="iOS Core Animation - Setting Things in Motion"/>
    <meta property="og:site_name" content="Vanney"/>

    
    <meta property="og:image" content="undefined"/>
    

    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" href="/atom.xml" title="Vanney" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

    
        <link rel="stylesheet" href="/css/lib/atelier-dune-dark.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
    <img src="/weixin_favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

    <nav class="blue-grey">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <a href="/" class="brand-logo hide-on-med-and-down">Vanney</a>
            <ul class="right hide-on-med-and-down">
                
                    <li>
                        <a class="menu-home " href="/" >
                            <i class="fa fa-home "></i>
                            
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-archive " href="/archives" >
                            <i class="fa fa-archive "></i>
                            
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-about " href="/about" >
                            <i class="fa fa-user "></i>
                            
                            关于
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-search modal-trigger " href="#search" >
                            <i class="fa fa-search "></i>
                            
                            搜索
                        </a>
                    </li>
                
            </ul>
            <div>
    <ul class="side-nav teal lighten-2" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding">
                    <img class="avatar-image circle responsive-img" src="/lionheart/avatar.jpeg" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">vanney</p>
                        <p class="desc">iOS开发</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    首页
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    归档
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-about " href="/about" >
                    <i class="fa fa-user "></i>
                    
                    关于
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    搜索
                </a>
            </li>
        
    </ul>

    <ul class="side-nav teal lighten-2" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/周记/">
                    周记 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/杂七杂八/">
                    杂七杂八 <span class="right">5 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/iOS/">
                    iOS <span class="right">18 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/iOS/源码分析/">
                    源码分析 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-2" collapse-level="2">
                <a class="no-padding" href="/categories/iOS/源码分析/因缺斯听/">
                    因缺斯听 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/iOS/心得/">
                    心得 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/OS-X/">
                    OS-X <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/OS-X/乱七八糟/">
                    乱七八糟 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/心得/">
                    心得 <span class="right">1 篇</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">搜索</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>


    <main>
        <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper teal lighten-2">
        <span class="breadcrumb">当前位置（分类目录）</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/iOS/">iOS</a>


        

        
    </div>
</nav>

<article>
    <div class="card">
        <div class="card-content">
            

            <div class="article-title">
                
    
        <h1>iOS Core Animation - Setting Things in Motion</h1>
    


            </div>
            <time class="teal-link-context" datetime="2016-07-08T08:29:36.000Z"><a href="/2016/07/08/iOS-Core-Animation-reading-note-two/">2016-07-08</a></time>

            <span id="busuanzi_container_page_pv" class="read-times-container">
    <!--<i class="fa fa-eye"></i>-->
    <span id="busuanzi_value_page_pv"></span>
</span>

            

            <div class="toc teal-link-context hide-on-med-and-down">
    <ol class="section table-of-contents"><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#前言"><span class="section table-of-contents-text">前言</span></a></li><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#笔记"><span class="section table-of-contents-text">笔记</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-3"><a class="section table-of-contents-link" href="#Implicit-Animations"><span class="section table-of-contents-text">Implicit Animations</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Transcations"><span class="section table-of-contents-text">Transcations</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Completion-Blocks"><span class="section table-of-contents-text">Completion Blocks</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Layer-Actions"><span class="section table-of-contents-text">Layer Actions</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Presentation-Versus-Model"><span class="section table-of-contents-text">Presentation Versus Model</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-3"><a class="section table-of-contents-link" href="#Explicit-Animations"><span class="section table-of-contents-text">Explicit Animations</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Property-Animations"><span class="section table-of-contents-text">Property Animations</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Animation-Groups"><span class="section table-of-contents-text">Animation Groups</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Transitions"><span class="section table-of-contents-text">Transitions</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Canceling-an-Animation-in-Progress"><span class="section table-of-contents-text">Canceling an Animation in Progress</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-3"><a class="section table-of-contents-link" href="#Layer-Time"><span class="section table-of-contents-text">Layer Time</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#The-CAMediaTiming-Protocol"><span class="section table-of-contents-text">The CAMediaTiming Protocol</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Hierarchical-Time"><span class="section table-of-contents-text">Hierarchical Time</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Manual-Animation"><span class="section table-of-contents-text">Manual Animation</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-3"><a class="section table-of-contents-link" href="#Easing"><span class="section table-of-contents-text">Easing</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Animation-Velocity"><span class="section table-of-contents-text">Animation Velocity</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Custom-Easing-Functions"><span class="section table-of-contents-text">Custom Easing Functions</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-3"><a class="section table-of-contents-link" href="#Timer-Based-Animation"><span class="section table-of-contents-text">Timer-Based Animation</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Frame-Timing"><span class="section table-of-contents-text">Frame Timing</span></a></li><li class="section table-of-contents-item section table-of-contents-level-4"><a class="section table-of-contents-link" href="#Physical-Simulation"><span class="section table-of-contents-text">Physical Simulation</span></a></li></ol></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#参考"><span class="section table-of-contents-text">参考</span></a></li></ol>
</div>


            <div class="entry teal-link-context">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>iOS Core Animation</strong> 读书笔记（二） <strong>Setting Things in Motion</strong></p>
<a id="more"></a>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Implicit-Animations"><a href="#Implicit-Animations" class="headerlink" title="Implicit Animations"></a>Implicit Animations</h3><p>隐式的动画由framework自动执行，除非你叫他不执行。</p>
<h4 id="Transcations"><a href="#Transcations" class="headerlink" title="Transcations"></a>Transcations</h4><ol>
<li><p>Core Animation会去假设你所有创建在屏幕上的东西都会animation。所以animation并不用你刻意的去启动。这也是Core Animation比OpenGL慢的一点，OpenGL不用去考虑这些东西，就不需要花费额外的性能代价。</p>
</li>
<li><p>当你改变一个CALayer的属性时，它会自动平滑的执行动画从当前属性到新的属性，而不是瞬变。不需要你额外的做些什么。这种动画就叫做隐式动画。</p>
</li>
<li><p><strong>Transcations</strong>是Core Animation将一系列动画汇集成一个的机制。一旦transaction提交(committed)之后，这些动画就会开始执行。</p>
</li>
<li><p><strong>CATransaction</strong>类控制着transaction的行为。该类没有alloc init这样的初始化，也并不是如名字那样代表一个transaction，它表示一个transaction的栈。可以使用<code>+begin</code> 和 <code>-commit</code>方法来将一个transaction进栈或者出栈。</p>
</li>
<li><p>使用<code>+setAnimationDuration:</code>方法来设置当前transaction的动画时间。没有指定的话，默认是0.25s。使用该方法时，最好显示的开始一个新的transaction，将其压入栈中，表示只改变这个transaction的duration；不然可能改变同时发生的一些animation，比如旋转屏幕。</p>
</li>
<li><p>看一下代码：</p>
<pre><code class="objective-c">- (IBAction)changeColor {
    //begin a new transaction
    [CATransaction begin];

    //set the animation duration to 1 second
    [CATransaction setAnimationDuration:1.0];

    //randomize the layer background color
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX; 
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;

     //commit the transaction
    [CATransaction commit]; 
}
</code></pre>
<p>这里使用<code>+begin</code>方法，表示显式的开始一个transaction，transaction其实就是一个属性改变的动画的集合；显式开始一个transaction可以精准的控制这一系列动画的执行时间等等，而且不予其他的动画搞混。当执行<code>+commit</code>方法时，这些动画变开始执行。而对于一些没有使用begin,commit的动画，其实他们也是属于不同的transaction，只是这些transaction没有被显式的压入(begin)或推出(commit)transaction的数组而已；他们被隐式的执行罢了。</p>
</li>
<li><p>其实UIView的<code>+animateWithDuration:animations:</code>方法，也是在内部调用上述6中的方法而已。</p>
</li>
<li><p>UIView的<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>和CALayer的<code>+begin</code>以及<code>+commit</code>相同。</p>
</li>
</ol>
<h4 id="Completion-Blocks"><a href="#Completion-Blocks" class="headerlink" title="Completion Blocks"></a>Completion Blocks</h4><ol>
<li>UIView中的animation的completion block实际上就是调用CATransaction的<code>+setCompletionBlock:</code>方法。</li>
</ol>
<h4 id="Layer-Actions"><a href="#Layer-Actions" class="headerlink" title="Layer Actions"></a>Layer Actions</h4><p>CALayer在属性变化时执行的动画叫做<strong>actions</strong>，来看看整个的流程。</p>
<ol>
<li>当CALayer的一个属性变化时，调用<code>-actionsForKey:</code>方法，这里传入的key就是这个属性的名字。</li>
<li>这时layer先查看他是否有delegate，也就是CALayerDelegate；再看看这个delegate里面是否实现了<code>-actionForLayer:forKey:</code>方法。如果实现了这个方法，那么就会调用这个方法并且返回。</li>
<li>如果没有这个delegate或者delegate里面没有实现上述的方法，那么layer就会去检查他的actions属性。这个字典包含了属性名到action的映射。</li>
<li>如果还是没找到这个要动画的属性名的话，就去style字典里面找。</li>
<li>最后的最后，还是没有找到的话，就会调用<code>-defaultActionForKey:</code>方法；这个方法定义了标准的动画为那些已知的属性。</li>
</ol>
<p>如果上述步骤的第二步中的<code>-actionForLayer:forKey:</code>方法返回nil的话就不会有动画发生了；如果返回的是一个符合CAAction协议的对象，比如返回CABasicAnimation，那么就会执行动画。</p>
<p>因为UIView的backing layer的delegate是UIView本身。UIView实现<code>-actionForLayer:forKey:</code>方法的方式就是：如果UIView的属性改变不发生在一个显式的动画工程之中就返回nil；如果在动画过程之中，就返回可动画的对象。测试代码如下：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *layerView; 
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];

    //test layer action when outside of animation block
    NSLog(@&quot;Outside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);

    //begin animation block
    [UIView beginAnimations:nil context:nil];
    //test layer action when inside of animation block
    NSLog(@&quot;Inside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);
    //end animation block
    [UIView commitAnimations]; 
}
@end
</code></pre>
<p>打印的结果如下：</p>
<pre><code>$ LayerTest[21215:c07] Outside: &lt;null&gt;
$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;
</code></pre><p>所以说UIView是disable隐式动画的。</p>
<p><code>[CATransaction setDisableActions:YES];</code>这个方法也可以 禁用动画。</p>
<p>在layer的<strong>actions</strong>字典属性里面设置如下：</p>
<pre><code>CATransition *transition = [CATransition animation]; 
transition.type = kCATransitionPush;
transition.subtype = kCATransitionFromLeft; 
self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
</code></pre><h4 id="Presentation-Versus-Model"><a href="#Presentation-Versus-Model" class="headerlink" title="Presentation Versus Model"></a>Presentation Versus Model</h4><ol>
<li>当你更改一个CALayer的属性时，这个属性是立刻发生改变的，但是并不在屏幕上立即显示出来。</li>
<li>当改变CALayer的属性时，CALayer相当于一个<em>model</em>，用来存储动画结束时该呈现何种状态；而Core Animation则相当于<em>controller</em>，用来控制<em>view</em>的变化。这也是一个MVC结构啊。所以有时候layer tree也叫作model layer tree。</li>
<li>iOS中，屏幕1／60秒重新绘制一次。所以如果动画时间超过这一时长的话，那么Core  Animation就需要从设置动画开始到动画结束内每1／60秒更新一次界面。所以这也需要CALayer能够记住当前的属性值和最终的属性值。</li>
<li>动画过程中，当前显示的layer的属性值，存储在一个<strong>presentation layer</strong>中，它可以通过<code>-presentationLayer;</code>方法取得。这个layer实际上就是<strong>model layer</strong>的复制，唯一的区别就是当前动画的属性值不同。当在presentation layer上调用<code>-modelLayer</code>方法时，返回的是presentation layer的原始的model layer。</li>
</ol>
<h3 id="Explicit-Animations"><a href="#Explicit-Animations" class="headerlink" title="Explicit Animations"></a>Explicit Animations</h3><p>使用显式动画的好处是可以完全控制动画的行为，比如运动轨迹，动画时间等等。</p>
<h4 id="Property-Animations"><a href="#Property-Animations" class="headerlink" title="Property Animations"></a>Property Animations</h4><ol>
<li><p><strong>CAAnimation</strong>类是所有Core Animation支持的动画类的共有的父类；它有一个子类是<strong>CAPropertyAnimation</strong>，也就是属性动画。</p>
</li>
<li><p><strong>CABasicAnimation</strong>是CAPropertyAnimation的一个子类。CAPropertyAnimation指定一个属性通过指定keypath。CABasicAnimation有3个属性：<em>fromValue</em>, <em>toValue</em>, <em>byValue</em>。这三个都是id类型，因为他们可以是数值，颜色，图片等等。当然只需要指定3个中的两个就可以确定一个动画。</p>
</li>
<li><p>使用CABasicAnimation就是显式动画了，来看一个例子：</p>
<pre><code class="objective-c">//create a basic animation
CABasicAnimation *animation = [CABasicAnimation animation]; 
animation.keyPath = @&quot;backgroundColor&quot;;
animation.toValue = (__bridge id)color.CGColor;
//apply animation to layer
[self.colorLayer addAnimation:animation forKey:nil];
</code></pre>
</li>
<li><p>使用上述的代码在动画结束后，颜色还是会回到以前的颜色，是因为动画只是改变了presentation layer，并没有改变model layer。实际上，隐式动画改变属性时，动画使用的也是CABasicAnimation，属性改变时，会在<code>-actionForLayer:forKey:</code>方法中返回一个CABasicAnimation。所以我们可以在动画执行之前改变属性，如下：</p>
<pre><code class="objective-c">animation.fromValue = (__bridge id)self.colorLayer.backgroundColor; self.colorLayer.backgroundColor = color.CGColor;
</code></pre>
</li>
</ol>
<ol>
<li><p>选择在动画之前改变属性值，而不是在动画结束之后。是因为，在动画结束之后，会先跳回原始值，在跳到最终值。</p>
</li>
<li><p>使用CAAnimationDelegate可以解决上述问题。它可以知道动画准确的结束时间。实现<code>-animationDidStop:finished:</code>方法即可。代码如下：</p>
<pre><code class="objective-c">// first specify delegate
animation.delegate = self;

// implement delegate method
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag {
    //set the backgroundColor property to match animation toValue
    [CATransaction begin];
    [CATransaction setDisableActions:YES]; 
      self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;         [CATransaction commit];
}
</code></pre>
</li>
<li><p>CABasicAnimation在使用<code>-addAnimation:forKey:</code>方法添加给CALayer时，可以指定一个NSString类型的Key。这个Key可以唯一的标示一个animation。所以在<code>-animationDidStop:finished:</code>方法中可以使用key来辨别是否是某个特定的animation。</p>
</li>
<li><p>CAAnimation还有一套自己的方法，来标示一个animation。可以使用<code>-setValue:forKey:</code>以及<code>-valueForKey:</code>方法。代码如下：</p>
<pre><code class="objective-c">// when set up animation
[animation setValue:handView forKey:@&quot;handView&quot;];

// when finish animation
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag {
      // get value that set last step
      UIView *handView = [anim valueForKey:@&quot;handView&quot;];
      // do something later
}
</code></pre>
</li>
<li><p>注意：这个动画结束的delegate被调用，可能发生在其值回退之前。所以，为什么要说在动画之前就设置动画结束的值。</p>
</li>
<li><p><strong>CAKeyframeAnimation</strong>很强大，和CABasicAnimation一样，也是CAPropertyAnimation的一个子类。它和CABasicAnimation一样，也只对一个属性进行动画。CAKeyframeAnimation只需要你来提供关键帧，然后Core Animation会自动帮你填充关键帧之间的空白。看一个例子：</p>
</li>
</ol>
<pre><code class="objective-c">   CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @&quot;backgroundColor&quot;;
   animation.duration = 2.0;
   animation.values = @[
                       (__bridge id)[UIColor blueColor].CGColor, 
                         (__bridge id)[UIColor redColor].CGColor, 
                         (__bridge id)[UIColor greenColor].CGColor, 
                         (__bridge id)[UIColor blueColor].CGColor 
                       ];
   //apply animation to layer
   [self.colorLayer addAnimation:animation forKey:nil];
</code></pre>
<p>   通过<strong>values</strong>属性(是一个NSArray)，指定关键帧。必须指定开始和结束的帧，因为CAKeyframeAnimation不会默认使用这个属性当前的值来作为第一帧。</p>
<ol>
<li>CAKeyframeAnimation还可以使用CGPath。来看看例子：</li>
</ol>
<pre><code class="objective-c">   //create a path
   UIBezierPath *bezierPath = [[UIBezierPath alloc] init]; 
   [bezierPath moveToPoint:CGPointMake(0, 150)]; 
   [bezierPath addCurveToPoint:CGPointMake(300, 150)
                 controlPoint1:CGPointMake(75, 0) 
                  controlPoint2:CGPointMake(225, 300)];

   //draw the path using a CAShapeLayer
   CAShapeLayer *pathLayer = [CAShapeLayer layer]; 
   pathLayer.path = bezierPath.CGPath; 
   pathLayer.fillColor = [UIColor clearColor].CGColor; 
   pathLayer.strokeColor = [UIColor redColor].CGColor; 
   pathLayer.lineWidth = 3.0f; 
   [self.containerView.layer addSublayer:pathLayer];

   //add the ship
   CALayer *shipLayer = [CALayer layer];
   shipLayer.frame = CGRectMake(0, 0, 64, 64); 
   shipLayer.position = CGPointMake(0, 150); 
   shipLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Ship.png&quot;].CGImage; [self.containerView.layer addSublayer:shipLayer];

   //create the keyframe animation
   CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @&quot;position&quot;;
   animation.duration = 4.0;
   animation.path = bezierPath.CGPath;
   [shipLayer addAnimation:animation forKey:nil];
</code></pre>
<p>   指定CAKeyframeAnimation的<strong>path</strong>属性为一个CGPath。然后就可以沿着这个path运动。另外，CAKeyframeAnimation还有一个<strong>rotationMode</strong>属性，该属性指定动画的layer的旋转特性。将该属性指定为kCAAnimationRotationAuto的话，上面的shipLayer就会一直旋转，以调整角度去对齐bezierPath的切线方向。</p>
<ol>
<li>CAPropertyAnimation不单单可以作用于实际存在的属性，还可以作用于虚拟的属性。是一个keys path：比如<code>animation.keyPath = @&quot;transform.rotation&quot;;</code>。</li>
</ol>
<h4 id="Animation-Groups"><a href="#Animation-Groups" class="headerlink" title="Animation Groups"></a>Animation Groups</h4><ol>
<li><strong>CAAnimationGroup</strong>是CAAnimation的一个子类，他可以聚集一堆动画。</li>
<li>他有一个<strong>animations</strong>属性，是一个包含CAAnimation的数组。</li>
</ol>
<h4 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h4><p><strong>CATransition</strong>也是CAAnimation的一个子类，它影响整个layer。它会先对原先的layer照个快照，然后创建新的layer。之后以动画的形式，将新的layer快照，替代原先的layer快照，比方说从左向右推入。它主要用来动画一些不可动画的属性，比如UIImage的image属性。看看代码：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIImageView *imageView; 
@property (nonatomic, copy) NSArray *images;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    //set up images
    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;], 
                    [UIImage imageNamed:@&quot;Cone.png&quot;],
                    [UIImage imageNamed:@&quot;Igloo.png&quot;], 
                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];
}

- (IBAction)switchImage {
    //set up crossfade transition
    CATransition *transition = [CATransition animation]; 
      transition.type = kCATransitionFade;
    //apply transition to imageview backing layer
    [self.imageView.layer addAnimation:transition forKey:nil];

      //cycle to next image
    UIImage *currentImage = self.imageView.image;
    NSUInteger index = [self.images indexOfObject:currentImage]; 
      index = (index + 1) % [self.images count]; 
      self.imageView.image = self.images[index];
}
@end
</code></pre>
<p>CALayer的contents属性，自动应用CATransition动画，当改变一个不是backing layer的contents时，会自动应用动画。</p>
<p>自己实现CATransaction效果：</p>
<ol>
<li>CALayer的<code>-renderInContext:</code>方法可以用来获取将当前的layer的contents画到一个context里面，也就实现了获取当前的快照。</li>
<li>将这个快照放在当前屏幕的最上面，掩盖住原来的view；之后就可以在原来的view上面进行变化了。</li>
<li>再使用动画推出这个快照，就完成了transition。</li>
</ol>
<p>看看代码实现：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIView *baseView = [[UIView alloc]initWithFrame:self.view.bounds];
    baseView.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:baseView];

    // preserve the current snapshot
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);
    [baseView.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();

    // insert snapshot view
    UIImageView *coverView = [[UIImageView alloc]initWithImage:coverImage];
    coverView.frame = self.view.bounds;
    [self.view addSubview:coverView];

    // update original view
    baseView.backgroundColor = [UIColor redColor];
    [UIView animateWithDuration:1.0 animations:^{
        CGAffineTransform transform = CGAffineTransformMakeScale(0.1, 0.1);
        transform = CGAffineTransformRotate(transform, M_PI_2);
        coverView.transform = transform;
        coverView.alpha = 0.5;
    } completion:^(BOOL finished) {
        [coverView removeFromSuperview];
    }];
}
</code></pre>
<h4 id="Canceling-an-Animation-in-Progress"><a href="#Canceling-an-Animation-in-Progress" class="headerlink" title="Canceling an Animation in Progress"></a>Canceling an Animation in Progress</h4><ol>
<li>当使用CALayer的<code>-addAnimation:forKey:</code>方法给一个layer添加了动画之后，可以使用<code>-(CAAnimation *)animationForKey:(NSString *)key;</code>方法来根据key重新获取这个animation。</li>
<li>修改正在运行的动画的属性，是没有效果的。</li>
<li>可以使用<code>- (void)removeAnimationForKey:(NSString *)key;</code>方法来删除layer的某个animation。</li>
<li>可以使用<code>- (void)removeAllAnimations;</code>来删除layer的所有动画。</li>
<li>只要一删除动画，屏幕就会根据model layer来重新绘制。</li>
</ol>
<h3 id="Layer-Time"><a href="#Layer-Time" class="headerlink" title="Layer Time"></a>Layer Time</h3><h4 id="The-CAMediaTiming-Protocol"><a href="#The-CAMediaTiming-Protocol" class="headerlink" title="The CAMediaTiming Protocol"></a>The CAMediaTiming Protocol</h4><ol>
<li><p><strong>CAMediaTiming</strong>协议定义了多种属性及方法用来控制动画工程中的时间，CALayer和CAAnimation都符合该协议。</p>
</li>
<li><p><strong>duration</strong>属性：一次动画执行的时间。</p>
</li>
<li><p><strong>repeatCount</strong>属性：动画重复执行的次数。可以是小数，比如3.5次。。</p>
</li>
<li><p>duration和repeatCount的默认值都是0，但不表示0次和0秒。表示的是默认的0.25s和1次。</p>
</li>
<li><p>还可以使用<strong>repeatDuration</strong>属性，指定整个重复动画的时间；<strong>autoreverses</strong>属性指定动画是否要原路径反着来一遍。</p>
</li>
<li><p>每个动画的时间都是各成体系的。每个动画内的时间可以被延迟，加速，减速等等。</p>
</li>
<li><p><strong>beginTime</strong>属性：如果一个animation是在一个animation group中，则beginTime就是其parent object——animation group 开始的一个偏移。如果一个animation 的 beginTime为5，则此动画在group aniamtion开始之后的5s在开始动画。如果一个animation是直接添加在layer上，beginTime同样是是其parent object——layer 开始的一个偏移，但是一个layer的beginning是一个过去的时间（猜想layer的beginning可能是其被添加到layer tree上的时间），因此不能简单的设置beginTime为5去延迟动画5s之后开始，因为有可能layer的beginning加上5s之后也是一个过去的时间（很有可能），因此，当要延迟一个添加到layer上的动画的时候，需要定义一个addTime，因此：</p>
<pre><code class="objective-c">addTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; // 取得layer时间系下的现在时间
animation.beginTime = addTime + delay; // 设置animation的时间系的原点，要参照layer的时间系。
</code></pre>
<p>如果一个layer他自己的beginTime已经设置，则animation的addTime的计算必须在layer的beginTime设置之后，因为要有一个时间的转移，具体看下面的例子：</p>
<pre><code class="objective-c">CFTimeInterval currentTime = CACurrentMediaTime();
CFTimeInterval currentTimeInSuperLayer = [superLayer convertTime:currentTime fromLayer:nil];
layer.beginTime = currentTimeInSuperLayer + 2; // 设置layer的时间系 从layer的superLayer进行设置。也就是说layer的时间系的原点是现在的Global时间在superLayer时间系里面加2s。 但是要把现在的global时间换成superLayer的时间。
CFTimeInterval currentTimeInLayer = [layer convertTime:currentTimeInSuperLayer fromLayer:superLayer];
CFTimeInterval addTime = currentTimeInLayer;
CAAnimationGroup *group = [CAAnimationGroup animation];
group.beginTime = addTime + 1; // 设置groupAnimation的时间系， 是现在时间的Global时间在layer的时间系里面加1s。(若speed都一样的话，那么就是layer时间系的-1s的位置)。
group.animations = [NSArray arrayWithObject:anim];
group.duration = 2;
anim.beginTime = 0.5;
[layer addAnimation:group forKey:nil];
</code></pre>
<p>​</p>
</li>
<li><p><strong>speed</strong>属性：表示的是时间的系数。默认为1，表示1倍速。如果duration是1s，但是speed是2，那么执行时间只有0.5s，也就是2倍速。</p>
</li>
<li><p><strong>timeOffset</strong>属性：表示动画从timeOffset的位置开始，动画到终点结束后回到起点再动画到timeOffset的位置。它计算出来的开始位置不受speed的影响。</p>
</li>
<li><p>当设置<strong>removeOnCompletion</strong>属性为NO时，说明动画完成时，这个动画没有从layer上面删除。这时候可以设置<strong>fillMode</strong>属性。这个属性默认为kCAFillModeRemoved，表示被动画的属性在model layer上面都不曾变化。可以将fillMode属性设置成其他的，那么model layer上面的属性会在动画结束时自动更新将其设置成presentation layer上面一样的值。这个时候要注意，在添加animation的时候要指定一个key，以确保之后可以方便删除这个动画。</p>
</li>
</ol>
<h4 id="Hierarchical-Time"><a href="#Hierarchical-Time" class="headerlink" title="Hierarchical Time"></a>Hierarchical Time</h4><ol>
<li><p>layer的动画时间也是有相对坐标系的，类似layer的位置，时间也是相对于super layer的。</p>
</li>
<li><p>改变CALayer或者CAGroupAnimation的beginTime，timeOffset以及speed属性会影响到sublayer的动画时间。</p>
</li>
<li><p>Core Animation有一个<strong>global time</strong>的概念，也就是一个设备的各个程序间共同的一个时间体系。它是一个<em>mach time</em>，可以通过下列代码获得当前的global time：</p>
<pre><code class="objective-c">CFTimeInterval time = CACurrentMediaTime();
</code></pre>
<p>这个函数返回的值很奇怪，它表示设备从上一次reboot到现在的秒数。</p>
</li>
<li><p>每个CALayer和CAAnimation还有自己的一个<strong>local time</strong>的概念。可以将2个layer之间的时间进行转换：</p>
<pre><code class="objective-c">- (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; 
- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l;
</code></pre>
</li>
<li><p>使用<code>self.window.layer.speed = 100;</code>会使你的整个app以100倍速运行。</p>
</li>
<li><p>来看一个自己写的代码：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    UIView *baseView1 = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 50, 50)];
    baseView1.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView1];
    UIView *baseView2 = [[UIView alloc]initWithFrame:CGRectMake(50, 250, 50, 50)];
    baseView2.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView2];
    UIView *baseView3 = [[UIView alloc]initWithFrame:CGRectMake(50, 450, 50, 50)];
    baseView3.backgroundColor = [UIColor redColor];
    [self.view addSubview:baseView3];
    UIView *baseView = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 50, 50)];
    baseView.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:baseView];

    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.duration = 4;
    //animation.repeatCount = 2;
    //baseView.layer.speed = 0.5;
    animation.keyPath = @&quot;position&quot;;
    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(75, 475)];
    animation.timeOffset = 2;
    //animation.removedOnCompletion = NO;
    //animation.fillMode = kCAFillModeBoth;
    animation.beginTime = [baseView.layer convertTime:CACurrentMediaTime() fromLayer:nil] + 2;
    [baseView.layer addAnimation:animation forKey:@&quot;base&quot;];
}
</code></pre>
</li>
</ol>
<h4 id="Manual-Animation"><a href="#Manual-Animation" class="headerlink" title="Manual Animation"></a>Manual Animation</h4><p>看段代码：</p>
<pre><code class="objective-c">@interface ViewController ()
@property (nonatomic, strong) CALayer *doorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    self.doorLayer = [CALayer layer];
    self.doorLayer.frame = CGRectMake(0, 0, 128, 256);
    self.doorLayer.position = CGPointMake(150 - 64, 150);
    self.doorLayer.anchorPoint = CGPointMake(0, 0.5);
    //self.doorLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Door.png&quot;].CGImage;
    self.doorLayer.backgroundColor = [UIColor redColor].CGColor;
    [self.view.layer addSublayer:self.doorLayer];

    //apply perspective transform
    CATransform3D perspective = CATransform3DIdentity; perspective.m34 = -1.0 / 500.0;
    self.view.layer.sublayerTransform = perspective;
    //add pan gesture recognizer to handle swipes
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] init];
    [pan addTarget:self action:@selector(pan:)];
    [self.view addGestureRecognizer:pan];
    //pause all layer animations
    self.doorLayer.speed = 0.0;
    //apply swinging animation (which won&#39;t play because layer is paused)
    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @&quot;transform.rotation.y&quot;; animation.toValue = @(-M_PI_2);
    animation.duration = 1.0;
    [self.doorLayer addAnimation:animation forKey:nil];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (void)pan:(UIPanGestureRecognizer *)pan {
    //get horizontal component of pan gesture
    CGFloat x = [pan translationInView:self.view].x;
    //convert from points to animation duration //using a reasonable scale factor
    x /= 200.0f;
    //update timeOffset and clamp result
    CFTimeInterval timeOffset = self.doorLayer.timeOffset;
    timeOffset = MIN(0.999, MAX(0.0, timeOffset - x));
    self.doorLayer.timeOffset = timeOffset;
    //reset pan gesture
    [pan setTranslation:CGPointZero inView:self.view];
}

@end
</code></pre>
<p>由于在动画执行过程中无法改变animation的属性，所以可以更改它的上一级，也就是layer的属性。将speed设置成0，所以动画暂停，相当于动画一直在执行却始终是在第一帧上面执行。根据手势来改变layer的timeOffset，那么在下一次动画渲染屏幕的时候（也就是画下一帧presentation layer的时候），动画发现还处在第一帧，但是timeOffset已经变了，所以就跟着手指移动了。</p>
<h3 id="Easing"><a href="#Easing" class="headerlink" title="Easing"></a>Easing</h3><h4 id="Animation-Velocity"><a href="#Animation-Velocity" class="headerlink" title="Animation Velocity"></a>Animation Velocity</h4><ol>
<li>Easing是为了模仿现实中的有加速度的这种运动。</li>
<li>为了使用easing，可以设置CAAnimation的<strong>timingFunction</strong>属性；也可以使用CATransaction的<code>+setAnimationTimingFunction:</code>方法将easing应用到隐式动画上面。这个属性是一个<strong>CAMediaTimingFunction</strong>对象。</li>
<li>创建CAMediaTimingFunction对象的方法很多。简单的就是使用<code>+timingFunctionWithName:</code>方法。在UIView的动画中，kCAMediaTimingFunctionEaseInEaseOut是默认的，但是CAAnimation就要你自己去指定一个。注意隐式动画中的默认值是kCAMediaTimingFunctionDefault，但是显式动画中没有默认的值。</li>
<li>CAKeyframeAnimation有一个<strong>timingFunctions</strong>属性，它是一个数组。数组的长度是<strong>keyframes</strong>数组的长度减一。它表示每个关键帧之间的easing属性。</li>
</ol>
<h4 id="Custom-Easing-Functions"><a href="#Custom-Easing-Functions" class="headerlink" title="Custom Easing Functions"></a>Custom Easing Functions</h4><ol>
<li><p>可以使用CAMediaTimingFunction的<code>+functionWithControlPoints::::</code>方法来创建自定义的easing效果。这个方法的命名不太符合apple的规范。</p>
</li>
<li><p>上面函数的4个点用来构成一个bezierPath，这个bezierPath可以表示这个动画的easing效果。bezierPath的切线就是速度。todo 图片</p>
</li>
<li><p>apple定义的几个easing效果也是这样实现的，可以使用CAMediaTimingFunction的<code>-getControlPointAtIndex:values:</code>方法来获取4个点。第一个点是起点，第四个点是终点，中间两个点是控制点1和控制点2。来看看将几种系统实现的easing效果的bezierPath画出来的代码：</p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    //create timing function
    CAMediaTimingFunction *function = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
    //get control points
    CGPoint controlPoint1, controlPoint2;
    [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];         [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];
    //create curve
    UIBezierPath *path = [[UIBezierPath alloc] init]; 
      [path moveToPoint:CGPointZero];
    [path addCurveToPoint:CGPointMake(1, 1) controlPoint1:controlPoint1 controlPoint2:controlPoint2];
    //scale the path up to a reasonable size for display
    [path applyTransform:CGAffineTransformMakeScale(200, 200)];
    //create shape layer
    CAShapeLayer *shapeLayer = [CAShapeLayer layer]; 
      shapeLayer.strokeColor = [UIColor redColor].CGColor; 
      shapeLayer.fillColor = [UIColor clearColor].CGColor; 
      shapeLayer.lineWidth = 4.0f;
    shapeLayer.path = path.CGPath; 
      [self.layerView.layer addSublayer:shapeLayer];
    //flip geometry so that 0,0 is in the bottom-left
    self.layerView.layer.geometryFlipped = YES; 
}
</code></pre>
</li>
<li><p>奇怪的是这个函数的调用，它不传CGPoint，而是传递的float。如下：</p>
<pre><code class="objective-c">[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];
</code></pre>
<p>其中（1，0）表示第一个控制点，（0.75， 1）表示第二个控制点。</p>
</li>
<li><p>至于更加复杂的easing效果可以使用Keyframe-Based Easing。就是将复杂的easing分成多个keyframe，每个keyframe之间由一个简单的自定义easing效果来实现。这个方法需要繁琐的计算量。 todo 复杂的bezierPath的图片</p>
</li>
<li><p>还有一个简单的方法就是：每1/60s定义一个keyframe，在每个keyframe之间都是线性变化的。只要求得每个keyframe的位置就可以做出流畅的动画。取1/60s是因为iOS1/60s渲染一次屏幕，这个值已经是最佳的了，每次渲染屏幕的时候都有一个自己设的值，已经是到达最精确的控制了。其实这个时候两个关键帧之间用什么变化都无所谓的，他只是渲染两次而已，不存在什么变化。至于每个关键帧的位置如何求得，可以在<a href="http://robertpenner.com/easing找到算法。" target="_blank" rel="external">http://robertpenner.com/easing找到算法。</a></p>
</li>
</ol>
<h3 id="Timer-Based-Animation"><a href="#Timer-Based-Animation" class="headerlink" title="Timer-Based Animation"></a>Timer-Based Animation</h3><h4 id="Frame-Timing"><a href="#Frame-Timing" class="headerlink" title="Frame Timing"></a>Frame Timing</h4><ol>
<li><p>上面讲到的1/60s定义一个keyframe，其实还可以使用NSTimer来实现。也就是1/60s就执行一次更新属性的操作，然后就会重新绘制出来。但是使用NSTimer会不太精确。</p>
</li>
<li><p>NSTimer和屏幕重新绘制都是主线程的任务，主线程中的任务都要等到之前的任务执行完成后再开始执行。所以当到了执行NSTimer或者当需要开始重新绘制屏幕时，如果这时候之前的任务还没有执行结束，则需要等待。这时无论NSTimer还是重新绘制都会有一些延迟。所以可能出现，需要绘制时，NSTimer还没更新，或者在一次绘制时NSTimer已经更新了多次的情况。这时候就会出现animation的迟滞或者跳帧。看看这个的解决方案。</p>
</li>
<li><p><strong>CADisplayLink</strong>和NSTimer类似，但是他能保证在屏幕重新绘制之前被触发。但是他不是通过指定一个<strong>timeInterval</strong>来触发，而是通过<strong>frameInterval</strong>来指定两次触发之间相隔多少帧。但是它还是无法保证重新绘制屏幕能按时发生。</p>
</li>
<li><p>根据上面的问题，这时就需要精确计算上一帧发生的时间，和当前帧发生的时间。两者相减就可以知道间隔时间，就能算出现在这一帧该动画到什么程度。来看看代码：</p>
<pre><code class="objective-c">- (void)animate {
    //reset ball to top of screen
    self.ballView.center = CGPointMake(150, 32);
    //configure the animation
    self.duration = 1.0;
    self.timeOffset = 0.0;
    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];             self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];
    //stop the timer if it&#39;s already running
    [self.timer invalidate];
    //start the timer
    self.lastStep = CACurrentMediaTime();
    self.timer = [CADisplayLink displayLinkWithTarget:self
    selector:@selector(step:)]; 
      [self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
}
- (void)step:(CADisplayLink *)timer {
    //calculate time delta
    CFTimeInterval thisStep = CACurrentMediaTime(); 
      CFTimeInterval stepDuration = thisStep - self.lastStep; self.lastStep = thisStep;
    //update time offset
    self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration);
    //get normalized time offset (in range 0 - 1)
    float time = self.timeOffset / self.duration;
    //apply easing
    time = bounceEaseOut(time);
    //interpolate position
    id position = [self interpolateFromValue:self.fromValue toValue:self.toValue time:time]; 
      self.ballView.center = [position CGPointValue];
    //stop the timer if we&#39;ve reached the end of the animation
    if (self.timeOffset &gt;= self.duration) {
        [self.timer invalidate];
        self.timer = nil; 
    }
}
</code></pre>
</li>
</ol>
<h4 id="Physical-Simulation"><a href="#Physical-Simulation" class="headerlink" title="Physical Simulation"></a>Physical Simulation</h4><p>看的晕头转向。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/yaozhuoyu/article/details/9566511" target="_blank" rel="external">CAMediaTiming 协议属性详解</a></li>
<li><a href="http://robertpenner.com/easing" target="_blank" rel="external">Robert Penner`s Easing Functions</a></li>
</ol>

                
<p class="teal-link-context">
    <a href="/2016/07/14/iOS-Core-Animation-reading-note-three/" rel="next" title="iOS Core Animation - The Performance of a Lifetime">
    上一篇：iOS Core Animation - The Performance of a Lifetime
  </a>
</p>



<p class="teal-link-context">
    <a href="/2016/07/01/iOS-Core-Animation-reading-note-one/" rel="next" title="iOS Core Animation - The Layer Beneath">
    下一篇：iOS Core Animation - The Layer Beneath
  </a>
</p>


            </div>
			
        </div>
    </div>
</article>






</div>

        <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large lime">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect lime darken-1" title="回到顶部"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse lime darken-2"  data-activates="main-menu" title="菜单"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

    </main>
    <footer class="page-footer blue-grey darken-1">
    
    <div class="footer-container container">
        <div class="row">
            
            <div class="social-group col m4 s12">
                <h5 class="white-text">社交</h5>
                
                    <a class="social-link" href="http://weibo.com/3911241332" target="_blank">
                        <i class="fa fa-2x fa-weibo"></i>
                    </a>
                
                    <a class="social-link" href="https://github.com/vanney9" target="_blank">
                        <i class="fa fa-2x fa-github"></i>
                    </a>
                
                    <a class="social-link" href="/atom.xml" target="_blank">
                        <i class="fa fa-2x fa-rss"></i>
                    </a>
                
                

            </div>
            

            
            <div class="col m8 s12">
                <h5 class="white-text">友情链接</h5>
                
                    <a class="social-link" href="http://raytaylorlin.com/" target="_blank">实验室前端大神，博客主题作者 寿寿</a>
                
                    <a class="social-link" href="http://tutuge.me/" target="_blank">实验室iOS大神 土哥</a>
                
            </div>
            
        </div>
    </div>
    

    <div class="footer-copyright teal-link-context">
        <div class="container">
            © 2017 vanney9.com, All rights reserved.
            <p class="right" style="margin-top: 0;">本博客由 <a href="https://hexo.io">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a></p>
            <script src="https://s95.cnzz.com/z_stat.php?id=1257182745&web_id=1257182745" language="JavaScript"></script>
        </div>
    </div>
</footer>


    <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('teal accent-1 lighten-2');

            
            // 添加new标签
            $('.menu-about').append('<span class="new badge lime lighten-1"></span>');
            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "search.xml";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword teal lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword teal lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/google/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>








</body>
</html>
